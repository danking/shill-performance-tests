/usr/src/bin/ls/ls.c:					mac_t label;
/usr/src/bin/ls/ls.c:					error = mac_prepare_file_label(&label);
/usr/src/bin/ls/ls.c:						error = mac_get_file(name,
/usr/src/bin/ls/ls.c:						error = mac_get_link(name,
/usr/src/bin/ls/ls.c:						mac_free(label);
/usr/src/bin/ls/ls.c:					error = mac_to_text(label,
/usr/src/bin/ls/ls.c:						mac_free(label);
/usr/src/bin/ls/ls.c:					mac_free(label);
/usr/src/bin/ps/print.c:	mac_t proclabel;
/usr/src/bin/ps/print.c:	if (mac_prepare_process_label(&proclabel) == -1) {
/usr/src/bin/ps/print.c:		warn("mac_prepare_process_label");
/usr/src/bin/ps/print.c:	error = mac_get_pid(k->ki_p->ki_pid, proclabel);
/usr/src/bin/ps/print.c:		if (mac_to_text(proclabel, &string) == -1)
/usr/src/bin/ps/print.c:	mac_free(proclabel);
/usr/src/contrib/bind9/lib/dns/dst_parse.c:check_hmac_md5(const dst_private_t *priv, isc_boolean_t old) {
/usr/src/contrib/bind9/lib/dns/dst_parse.c:check_hmac_sha(const dst_private_t *priv, unsigned int ntags,
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_md5(priv, old));
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_sha(priv, HMACSHA1_NTAGS, alg));
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_sha(priv, HMACSHA224_NTAGS, alg));
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_sha(priv, HMACSHA256_NTAGS, alg));
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_sha(priv, HMACSHA384_NTAGS, alg));
/usr/src/contrib/bind9/lib/dns/dst_parse.c:		return (check_hmac_sha(priv, HMACSHA512_NTAGS, alg));
/usr/src/contrib/bind9/lib/dns/hmac_link.c: * $Id: hmac_link.c,v 1.19 2011/01/11 23:47:13 tbox Exp $
/usr/src/contrib/binutils/bfd/coff-rs6000.c:static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data =
/usr/src/contrib/binutils/bfd/coff-rs6000.c:const bfd_target pmac_xcoff_vec =
/usr/src/contrib/binutils/bfd/coff-rs6000.c:    (void *) &bfd_pmac_xcoff_backend_data,
/usr/src/contrib/binutils/bfd/targets.c:extern const bfd_target pmac_xcoff_vec;
/usr/src/contrib/binutils/bfd/targets.c:	&pmac_xcoff_vec,
/usr/src/contrib/binutils/binutils/dwarf.c:    case DW_AT_mac_info:		return "DW_AT_mac_info";
/usr/src/contrib/binutils/gas/config/tc-arm.c:do_neon_mac_maybe_scalar (void)
/usr/src/contrib/binutils/gas/config/tc-arm.c:    do_neon_mac_maybe_scalar ();
/usr/src/contrib/binutils/gas/config/tc-arm.c:neon_mac_reg_scalar_long (unsigned regtypes, unsigned scalartypes)
/usr/src/contrib/binutils/gas/config/tc-arm.c:do_neon_mac_maybe_scalar_long (void)
/usr/src/contrib/binutils/gas/config/tc-arm.c:  neon_mac_reg_scalar_long (N_S16 | N_S32 | N_U16 | N_U32, N_SU_32);
/usr/src/contrib/binutils/gas/config/tc-arm.c:  neon_mac_reg_scalar_long (N_S16 | N_S32, N_S16 | N_S32);
/usr/src/contrib/binutils/gas/config/tc-arm.c:    do_neon_mac_maybe_scalar_long ();
/usr/src/contrib/binutils/gas/config/tc-arm.c: nCEF(vmla,     vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
/usr/src/contrib/binutils/gas/config/tc-arm.c: nCEF(vmls,     vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
/usr/src/contrib/binutils/gas/config/tc-arm.c: nUF(vmlaq,     vmla,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
/usr/src/contrib/binutils/gas/config/tc-arm.c: nUF(vmlsq,     vmls,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
/usr/src/contrib/binutils/gas/config/tc-arm.c: nUF(vmlal,     vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
/usr/src/contrib/binutils/gas/config/tc-arm.c: nUF(vmlsl,     vmlsl,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
/usr/src/contrib/gcc/dwarf2out.c:    case DW_AT_mac_info:
/usr/src/contrib/gcc/dwarf2out.c:      return "DW_AT_mac_info";
/usr/src/contrib/gdb/gdb/dwarf2read.c:    case DW_AT_mac_info:
/usr/src/contrib/gdb/gdb/dwarf2read.c:      return "DW_AT_mac_info";
/usr/src/contrib/gdb/gdb/dwarf2read.c:  char *mac_ptr, *mac_end;
/usr/src/contrib/gdb/gdb/dwarf2read.c:  mac_ptr = dwarf_macinfo_buffer + offset;
/usr/src/contrib/gdb/gdb/dwarf2read.c:  mac_end = dwarf_macinfo_buffer + dwarf_macinfo_size;
/usr/src/contrib/gdb/gdb/dwarf2read.c:      if (mac_ptr >= mac_end)
/usr/src/contrib/gdb/gdb/dwarf2read.c:      macinfo_type = read_1_byte (abfd, mac_ptr);
/usr/src/contrib/gdb/gdb/dwarf2read.c:      mac_ptr++;
/usr/src/contrib/gdb/gdb/dwarf2read.c:            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/gdb/gdb/dwarf2read.c:            body = read_string (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/gdb/gdb/dwarf2read.c:            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/gdb/gdb/dwarf2read.c:            file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/gdb/gdb/dwarf2read.c:                  if (mac_ptr >= mac_end)
/usr/src/contrib/gdb/gdb/dwarf2read.c:                  /* We don't increment mac_ptr here, so this is just
/usr/src/contrib/gdb/gdb/dwarf2read.c:                  next_type = read_1_byte (abfd, mac_ptr);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/gdb/gdb/dwarf2read.c:            string = read_string (abfd, mac_ptr, &bytes_read);
/usr/src/contrib/gdb/gdb/dwarf2read.c:            mac_ptr += bytes_read;
/usr/src/contrib/ipfilter/ipsend/dlcommon.c:	(void) printf("addr_length %d mac_type %s current_state %s\n",
/usr/src/contrib/ipfilter/ipsend/dlcommon.c:		dlmactype(dlp->info_ack.dl_mac_type),
/usr/src/contrib/libpcap/gencode.c:static struct block *gen_mac_multicast(int);
/usr/src/contrib/libpcap/gencode.c:		 * of off_mac_pl + off_nl from the beginning of the
/usr/src/contrib/libpcap/gencode.c:gen_mac_multicast(offset)
/usr/src/contrib/libpcap/gencode.c:			return gen_mac_multicast(0);
/usr/src/contrib/libpcap/gencode.c:			return gen_mac_multicast(1);
/usr/src/contrib/libpcap/gencode.c:			return gen_mac_multicast(2);
/usr/src/contrib/libpcap/gencode.c:			b0 = gen_mac_multicast(16);
/usr/src/contrib/libpcap/gencode.c:			b1 = gen_mac_multicast(4);
/usr/src/contrib/libpcap/gencode.c:			b1 = gen_mac_multicast(4);
/usr/src/contrib/libpcap/gencode.c:			b0 = gen_mac_multicast(2);
/usr/src/contrib/libpcap/gencode.c:				b0 = gen_mac_multicast(off_mac);
/usr/src/contrib/libpcap/pcap-dlpi.c:	if (infop->dl_mac_type == DL_IPATM)
/usr/src/contrib/libpcap/pcap-dlpi.c:	if (pcap_process_mactype(p, infop->dl_mac_type) != 0)
/usr/src/contrib/libpcap/pcap-dos.c:static u_long mac_count    = 0;
/usr/src/contrib/libpcap/pcap-dos.c:      mac_count++;
/usr/src/contrib/libpcap/pcap-dos.c:u_long pcap_mac_packets (void)
/usr/src/contrib/libpcap/pcap-dos.c:  return (mac_count);
/usr/src/contrib/sendmail/libmilter/engine.c:		if (ctx->ctx_mac_list[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:			len += strlen(ctx->ctx_mac_list[i]) + 1 +
/usr/src/contrib/sendmail/libmilter/engine.c:				if (ctx->ctx_mac_list[i] == NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:				l = strlen(ctx->ctx_mac_list[i]) + 1;
/usr/src/contrib/sendmail/libmilter/engine.c:						ctx->ctx_mac_list[i], l);
/usr/src/contrib/sendmail/libmilter/engine.c:		if (ctx->ctx_mac_ptr[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:			free(ctx->ctx_mac_ptr[i]);
/usr/src/contrib/sendmail/libmilter/engine.c:			ctx->ctx_mac_ptr[i] = NULL;
/usr/src/contrib/sendmail/libmilter/engine.c:		if (ctx->ctx_mac_buf[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:			free(ctx->ctx_mac_buf[i]);
/usr/src/contrib/sendmail/libmilter/engine.c:			ctx->ctx_mac_buf[i] = NULL;
/usr/src/contrib/sendmail/libmilter/engine.c:		if (ctx->ctx_mac_list[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:			free(ctx->ctx_mac_list[i]);
/usr/src/contrib/sendmail/libmilter/engine.c:			ctx->ctx_mac_list[i] = NULL;
/usr/src/contrib/sendmail/libmilter/engine.c:	if (g->a_ctx->ctx_mac_ptr[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:		free(g->a_ctx->ctx_mac_ptr[i]);
/usr/src/contrib/sendmail/libmilter/engine.c:	if (g->a_ctx->ctx_mac_buf[i] != NULL)
/usr/src/contrib/sendmail/libmilter/engine.c:		free(g->a_ctx->ctx_mac_buf[i]);
/usr/src/contrib/sendmail/libmilter/engine.c:	g->a_ctx->ctx_mac_ptr[i] = argv;
/usr/src/contrib/sendmail/libmilter/engine.c:	g->a_ctx->ctx_mac_buf[i] = g->a_buf;
/usr/src/contrib/sendmail/libmilter/smfi.c:	if (ctx->ctx_mac_list[where] != NULL)
/usr/src/contrib/sendmail/libmilter/smfi.c:	ctx->ctx_mac_list[where] = strdup(macros);
/usr/src/contrib/sendmail/libmilter/smfi.c:	if (ctx->ctx_mac_list[where] == NULL)
/usr/src/contrib/sendmail/libmilter/smfi.c:		if ((s = ctx->ctx_mac_ptr[i]) == NULL ||
/usr/src/contrib/sendmail/libmilter/smfi.c:		    ctx->ctx_mac_buf[i] == NULL)
/usr/src/contrib/sendmail/src/envelope.c:	for (p = &e->e_macro.mac_table[0];
/usr/src/contrib/sendmail/src/envelope.c:	     p <= &e->e_macro.mac_table[MAXMACROID];
/usr/src/contrib/sendmail/src/envelope.c:	e->e_macro.mac_rpool = rpool;
/usr/src/contrib/sendmail/src/macro.c:**				-- value was allocated from mac->mac_rpool
/usr/src/contrib/sendmail/src/macro.c:			mac->mac_table[id] == NULL ? "" : "re", macname(id));
/usr/src/contrib/sendmail/src/macro.c:	if (mac->mac_rpool == NULL)
/usr/src/contrib/sendmail/src/macro.c:		if (mac->mac_table[id] != NULL &&
/usr/src/contrib/sendmail/src/macro.c:		    bitnset(id, mac->mac_allocated))
/usr/src/contrib/sendmail/src/macro.c:			freeit = mac->mac_table[id];
/usr/src/contrib/sendmail/src/macro.c:			clrbitn(id, mac->mac_allocated);
/usr/src/contrib/sendmail/src/macro.c:			setbitn(id, mac->mac_allocated);
/usr/src/contrib/sendmail/src/macro.c:		mac->mac_table[id] = newvalue;
/usr/src/contrib/sendmail/src/macro.c:			newvalue = sm_rpool_strdup_x(mac->mac_rpool, value);
/usr/src/contrib/sendmail/src/macro.c:		mac->mac_table[id] = newvalue;
/usr/src/contrib/sendmail/src/macro.c:	mac->mac_table[i] = value;
/usr/src/contrib/sendmail/src/macro.c:		char *p = e->e_mci->mci_macro.mac_table[n];
/usr/src/contrib/sendmail/src/macro.c:		char *p = e->e_macro.mac_table[n];
/usr/src/contrib/sendmail/src/macro.c:	return GlobalMacros.mac_table[n];
/usr/src/contrib/sendmail/src/mci.c:		mci->mci_macro.mac_rpool = NULL;
/usr/src/contrib/sendmail/src/mci.c:	if (mci->mci_macro.mac_rpool == NULL)
/usr/src/contrib/sendmail/src/mci.c:		mci->mci_macro.mac_rpool = mci->mci_rpool;
/usr/src/contrib/sendmail/src/mci.c:	mci->mci_macro.mac_rpool = mci->mci_rpool;
/usr/src/contrib/sendmail/src/srvrsmtp.c:	e->e_macro.mac_rpool = e->e_rpool;
/usr/src/contrib/sendmail/src/stab.c:						s->s_mci.mci_macro.mac_rpool = NULL;
/usr/src/contrib/tcpdump/print-sflow.c:    u_int8_t    mac_transmit_errors[4];
/usr/src/contrib/tcpdump/print-sflow.c:    u_int8_t    mac_receive_errors[4];
/usr/src/contrib/tcpdump/print-sflow.c:	   EXTRACT_32BITS(sflow_eth_counter->mac_transmit_errors));
/usr/src/contrib/tcpdump/print-sflow.c:	   EXTRACT_32BITS(sflow_eth_counter->mac_receive_errors),
/usr/src/contrib/tcpdump/signature.c:signature_compute_hmac_md5(const u_int8_t *text, int text_len, unsigned char *key,
/usr/src/contrib/tcpdump/signature.c:    signature_compute_hmac_md5(pptr, plen, (unsigned char *)sigsecret,
/usr/src/contrib/tnftp/src/cmds.c:			fprintf(ttyout, "\t%s\n", macros[i].mac_name);
/usr/src/contrib/tnftp/src/cmds.c:	(void)strlcpy(macros[macnum].mac_name, argv[1],
/usr/src/contrib/tnftp/src/cmds.c:	    sizeof(macros[macnum].mac_name));
/usr/src/contrib/tnftp/src/cmds.c:		macros[macnum].mac_start = macbuf;
/usr/src/contrib/tnftp/src/cmds.c:		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
/usr/src/contrib/tnftp/src/cmds.c:	tmp = macros[macnum].mac_start;
/usr/src/contrib/tnftp/src/cmds.c:			if (tmp == macros[macnum].mac_start) {
/usr/src/contrib/tnftp/src/cmds.c:				macros[macnum++].mac_end = tmp;
/usr/src/contrib/tnftp/src/cmds.c:				macros[macnum++].mac_end = tmp - 1;
/usr/src/contrib/tnftp/src/domacro.c:		if (!strncmp(argv[1], macros[i].mac_name, 9))
/usr/src/contrib/tnftp/src/domacro.c:	cp1 = macros[i].mac_start;
/usr/src/contrib/tnftp/src/domacro.c:	while (cp1 != macros[i].mac_end) {
/usr/src/contrib/tnftp/src/domacro.c:		if (cp1 != macros[i].mac_end)
/usr/src/contrib/tnftp/src/ruserpass.c:			tmp = macros[macnum].mac_name;
/usr/src/contrib/tnftp/src/ruserpass.c:				macros[macnum].mac_start = macbuf;
/usr/src/contrib/tnftp/src/ruserpass.c:				macros[macnum].mac_start =
/usr/src/contrib/tnftp/src/ruserpass.c:				    macros[macnum-1].mac_end + 1;
/usr/src/contrib/tnftp/src/ruserpass.c:			tmp = macros[macnum].mac_start;
/usr/src/contrib/tnftp/src/ruserpass.c:					if (tmp == macros[macnum].mac_start) {
/usr/src/contrib/tnftp/src/ruserpass.c:						macros[macnum++].mac_end = tmp;
/usr/src/contrib/tnftp/src/ruserpass.c:						macros[macnum++].mac_end =
/usr/src/contrib/tnftp/src/util.c:		if (!strcmp("init", macros[n].mac_name)) {
/usr/src/contrib/wpa/hostapd/config_file.c:	const struct mac_acl_entry *aa = a;
/usr/src/contrib/wpa/hostapd/config_file.c:	const struct mac_acl_entry *bb = b;
/usr/src/contrib/wpa/hostapd/config_file.c:				       struct mac_acl_entry **acl, int *num)
/usr/src/contrib/wpa/hostapd/config_file.c:	struct mac_acl_entry *newacl;
/usr/src/contrib/wpa/hostapd/config_file.c:	if (hostapd_mac_comp_empty(bss->bssid) != 0) {
/usr/src/contrib/wpa/hostapd/config_file.c:			    (hostapd_mac_comp(conf->bss[i].bssid,
/usr/src/contrib/wpa/hostapd/config_file.c:		} else if (os_strcmp(buf, "accept_mac_file") == 0) {
/usr/src/contrib/wpa/hostapd/config_file.c:					   "read accept_mac_file '%s'",
/usr/src/contrib/wpa/hostapd/config_file.c:		} else if (os_strcmp(buf, "deny_mac_file") == 0) {
/usr/src/contrib/wpa/hostapd/config_file.c:					   "read deny_mac_file '%s'",
/usr/src/contrib/wpa/src/ap/ap_config.c:int hostapd_mac_comp(const void *a, const void *b)
/usr/src/contrib/wpa/src/ap/ap_config.c:int hostapd_mac_comp_empty(const void *a)
/usr/src/contrib/wpa/src/ap/ap_config.c:int hostapd_maclist_found(struct mac_acl_entry *list, int num_entries,
/usr/src/contrib/wpa/src/ap/hostapd.c:		if (hostapd_mac_comp_empty(iface->conf->bss[j].bssid) == 0) {
/usr/src/contrib/wpa/src/ap/hostapd.c:static int mac_in_conf(struct hostapd_config *conf, const void *a)
/usr/src/contrib/wpa/src/ap/hostapd.c:		if (hostapd_mac_comp(conf->bss[i].bssid, a) == 0) {
/usr/src/contrib/wpa/src/ap/hostapd.c:		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0) {
/usr/src/contrib/wpa/src/ap/hostapd.c:			} while (mac_in_conf(hapd->iconf, hapd->own_addr));
/usr/src/contrib/wpa/src/ap/hostapd.c:			if (hostapd_mac_comp(hapd->own_addr,
/usr/src/contrib/wpa/src/ap/hostapd.c:		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
/usr/src/contrib/wpa/src/ap/iapp.c:	u8 mac_addr[ETH_ALEN];
/usr/src/contrib/wpa/src/ap/iapp.c:	u8 mac_addr[ETH_ALEN];
/usr/src/contrib/wpa/src/ap/iapp.c:	u8 mac_addr[ETH_ALEN];
/usr/src/contrib/wpa/src/ap/iapp.c:	u8 mac_addr[ETH_ALEN];
/usr/src/contrib/wpa/src/ap/iapp.c:	u8 mac_addr[ETH_ALEN];
/usr/src/contrib/wpa/src/ap/iapp.c:static void iapp_send_add(struct iapp_data *iapp, u8 *mac_addr, u16 seq_num)
/usr/src/contrib/wpa/src/ap/iapp.c:	os_memcpy(add->mac_addr, mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/ap/iapp.c:	sta = ap_get_sta(iapp->hapd, add->mac_addr);
/usr/src/contrib/wpa/src/ap/iapp.c:	hostapd_logger(iapp->hapd, add->mac_addr, HOSTAPD_MODULE_IAPP,
/usr/src/contrib/wpa/src/ap/iapp.c:	hostapd_logger(iapp->hapd, add->mac_addr, HOSTAPD_MODULE_IAPP,
/usr/src/contrib/wpa/src/ap/ieee802_1x.c:	hmac_md5(sm->eap_if->eapKeyData + 32, 32, buf, sizeof(*hdr) + len,
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	if (kde.rsn_ie == NULL || kde.mac_addr == NULL ||
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	    kde.mac_addr_len < ETH_ALEN) {
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	/* Initiator = sm->addr; Peer = kde.mac_addr */
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	search.addr = kde.mac_addr;
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:			   MAC2STR(kde.mac_addr));
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:		wpa_smk_send_error(wpa_auth, sm, kde.mac_addr, STK_MUI_SMK,
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	pos = wpa_add_kde(pos, RSN_KEY_DATA_MAC_ADDR, kde->mac_addr, ETH_ALEN,
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	    kde.mac_addr == NULL || kde.mac_addr_len < ETH_ALEN ||
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	/* Peer = sm->addr; Initiator = kde.mac_addr;
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	search.addr = kde.mac_addr;
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:			   MAC2STR(kde.mac_addr));
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:		wpa_smk_send_error(wpa_auth, sm, kde.mac_addr, STK_MUI_SMK,
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	if (kde.mac_addr == NULL || kde.mac_addr_len < ETH_ALEN ||
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:	search.addr = kde.mac_addr;
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:			   MAC2STR(kde.mac_addr), MAC2STR(sm->addr));
/usr/src/contrib/wpa/src/ap/peerkey_auth.c:			 MAC2STR(kde.mac_addr), mui, error_type);
/usr/src/contrib/wpa/src/ap/wpa_auth.c:			   kde.mac_addr) {
/usr/src/contrib/wpa/src/ap/wpa_auth_ie.c:		ie->mac_addr = pos + 2 + RSN_SELECTOR_LEN;
/usr/src/contrib/wpa/src/ap/wpa_auth_ie.c:		ie->mac_addr_len = pos[1] - RSN_SELECTOR_LEN;
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:static int hostapd_wps_new_psk_cb(void *ctx, const u8 *mac_addr, const u8 *psk,
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		   MACSTR, MAC2STR(mac_addr));
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:	os_memcpy(p->addr, mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		fprintf(f, MACSTR " %s\n", MAC2STR(mac_addr), hex);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:			  uuid, MAC2STR(dev->mac_addr), dev->device_name,
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:			t.sec, uuid, MAC2STR(dev->mac_addr), dev->device_name,
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:static void hostapd_wps_reg_success_cb(void *ctx, const u8 *mac_addr,
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		MAC2STR(mac_addr), uuid);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:					 mac_addr, uuid_e);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		   MAC2STR(cred->mac_addr));
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		uuid_gen_mac_addr(hapd->own_addr, wps->uuid);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:	os_memcpy(wps->dev.mac_addr, hapd->own_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:	const u8 *mac_addr, const struct wpabuf *msg,
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:	wpa_printf(MSG_DEBUG, "WPS UPnP: PutWLANResponse ev_type=%d mac_addr="
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:		   MACSTR, ev_type, MAC2STR(mac_addr));
/usr/src/contrib/wpa/src/ap/wps_hostapd.c:	sta = ap_get_sta(hapd, mac_addr);
/usr/src/contrib/wpa/src/common/wpa_common.c:		return hmac_md5(key, 16, buf, len, mic);
/usr/src/contrib/wpa/src/common/wpa_common.c:		if (hmac_sha1(key, 16, buf, len, hash))
/usr/src/contrib/wpa/src/common/wpa_common.c:		hmac_sha256_vector(pmk, pmk_len, 3, addr, len, hash);
/usr/src/contrib/wpa/src/common/wpa_common.c:		hmac_sha1_vector(pmk, pmk_len, 3, addr, len, hash);
/usr/src/contrib/wpa/src/crypto/crypto_libtomcrypt.c:		hmac_state hmac;
/usr/src/contrib/wpa/src/crypto/crypto_libtomcrypt.c:		if (hmac_init(&ctx->u.hmac, find_hash("md5"), key, key_len) !=
/usr/src/contrib/wpa/src/crypto/crypto_libtomcrypt.c:		if (hmac_init(&ctx->u.hmac, find_hash("sha1"), key, key_len) !=
/usr/src/contrib/wpa/src/crypto/crypto_libtomcrypt.c:		ctx->error = hmac_process(&ctx->u.hmac, data, len) != CRYPT_OK;
/usr/src/contrib/wpa/src/crypto/crypto_libtomcrypt.c:		if (hmac_done(&ctx->u.hmac, mac, &clen) != CRYPT_OK) {
/usr/src/contrib/wpa/src/crypto/crypto_openssl.c:	unsigned int mac_len;
/usr/src/contrib/wpa/src/crypto/crypto_openssl.c:	if (!EVP_DigestFinal(&ctx, mac, &mac_len)) {
/usr/src/contrib/wpa/src/crypto/md5-non-fips.c: * hmac_md5_vector_non_fips_allow - HMAC-MD5 over data vector (RFC 2104)
/usr/src/contrib/wpa/src/crypto/md5-non-fips.c:int hmac_md5_vector_non_fips_allow(const u8 *key, size_t key_len,
/usr/src/contrib/wpa/src/crypto/md5-non-fips.c: * hmac_md5_non_fips_allow - HMAC-MD5 over data buffer (RFC 2104)
/usr/src/contrib/wpa/src/crypto/md5-non-fips.c:int hmac_md5_non_fips_allow(const u8 *key, size_t key_len, const u8 *data,
/usr/src/contrib/wpa/src/crypto/md5-non-fips.c:	return hmac_md5_vector_non_fips_allow(key, key_len, 1, &data,
/usr/src/contrib/wpa/src/crypto/md5.c: * hmac_md5_vector - HMAC-MD5 over data vector (RFC 2104)
/usr/src/contrib/wpa/src/crypto/md5.c:int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
/usr/src/contrib/wpa/src/crypto/md5.c: * hmac_md5 - HMAC-MD5 over data buffer (RFC 2104)
/usr/src/contrib/wpa/src/crypto/md5.c:int hmac_md5(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
/usr/src/contrib/wpa/src/crypto/md5.c:	return hmac_md5_vector(key, key_len, 1, &data, &data_len, mac);
/usr/src/contrib/wpa/src/crypto/milenage.c: * @mac_a: Buffer for MAC-A = 64-bit network authentication code, or %NULL
/usr/src/contrib/wpa/src/crypto/milenage.c: * @mac_s: Buffer for MAC-S = 64-bit resync authentication code, or %NULL
/usr/src/contrib/wpa/src/crypto/milenage.c:		const u8 *sqn, const u8 *amf, u8 *mac_a, u8 *mac_s)
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (mac_a)
/usr/src/contrib/wpa/src/crypto/milenage.c:		os_memcpy(mac_a, tmp1, 8); /* f1 */
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (mac_s)
/usr/src/contrib/wpa/src/crypto/milenage.c:		os_memcpy(mac_s, tmp1 + 8, 8); /* f1* */
/usr/src/contrib/wpa/src/crypto/milenage.c:	u8 mac_a[8], ak[6];
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (milenage_f1(opc, k, _rand, sqn, amf, mac_a, NULL) ||
/usr/src/contrib/wpa/src/crypto/milenage.c:	os_memcpy(autn + 8, mac_a, 8);
/usr/src/contrib/wpa/src/crypto/milenage.c:	u8 ak[6], mac_s[8];
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (milenage_f1(opc, k, _rand, sqn, amf, NULL, mac_s) ||
/usr/src/contrib/wpa/src/crypto/milenage.c:	    memcmp(mac_s, auts + 6, 8) != 0)
/usr/src/contrib/wpa/src/crypto/milenage.c:	u8 mac_a[8], ak[6], rx_sqn[6];
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (milenage_f1(opc, k, _rand, rx_sqn, amf, mac_a, NULL))
/usr/src/contrib/wpa/src/crypto/milenage.c:	wpa_hexdump(MSG_DEBUG, "Milenage: MAC_A", mac_a, 8);
/usr/src/contrib/wpa/src/crypto/milenage.c:	if (os_memcmp(mac_a, autn + 8, 8) != 0) {
/usr/src/contrib/wpa/src/crypto/sha1-pbkdf2.c:	if (hmac_sha1_vector((u8 *) passphrase, passphrase_len, 2, addr, len,
/usr/src/contrib/wpa/src/crypto/sha1-pbkdf2.c:		if (hmac_sha1((u8 *) passphrase, passphrase_len, tmp,
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:	hmac_md5_vector_non_fips_allow(S1, L_S1, 2, &MD5_addr[1], &MD5_len[1],
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:	hmac_sha1_vector(S2, L_S2, 2, &SHA1_addr[1], &SHA1_len[1], A_SHA1);
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:			hmac_md5_vector_non_fips_allow(S1, L_S1, 3, MD5_addr,
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:			hmac_md5_non_fips_allow(S1, L_S1, A_MD5, MD5_MAC_LEN,
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:			hmac_sha1_vector(S2, L_S2, 3, SHA1_addr, SHA1_len,
/usr/src/contrib/wpa/src/crypto/sha1-tlsprf.c:			hmac_sha1(S2, L_S2, A_SHA1, SHA1_MAC_LEN, A_SHA1);
/usr/src/contrib/wpa/src/crypto/sha1-tprf.c:		if (hmac_sha1_vector(key, key_len, 5, addr, len, hash))
/usr/src/contrib/wpa/src/crypto/sha1.c: * hmac_sha1_vector - HMAC-SHA1 over data vector (RFC 2104)
/usr/src/contrib/wpa/src/crypto/sha1.c:int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
/usr/src/contrib/wpa/src/crypto/sha1.c: * hmac_sha1 - HMAC-SHA1 over data buffer (RFC 2104)
/usr/src/contrib/wpa/src/crypto/sha1.c:int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
/usr/src/contrib/wpa/src/crypto/sha1.c:	return hmac_sha1_vector(key, key_len, 1, &data, &data_len, mac);
/usr/src/contrib/wpa/src/crypto/sha1.c:			if (hmac_sha1_vector(key, key_len, 3, addr, len,
/usr/src/contrib/wpa/src/crypto/sha1.c:			if (hmac_sha1_vector(key, key_len, 3, addr, len,
/usr/src/contrib/wpa/src/crypto/sha256.c: * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)
/usr/src/contrib/wpa/src/crypto/sha256.c:void hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
/usr/src/contrib/wpa/src/crypto/sha256.c: * hmac_sha256 - HMAC-SHA256 over data buffer (RFC 2104)
/usr/src/contrib/wpa/src/crypto/sha256.c:void hmac_sha256(const u8 *key, size_t key_len, const u8 *data,
/usr/src/contrib/wpa/src/crypto/sha256.c:	hmac_sha256_vector(key, key_len, 1, &data, &data_len, mac);
/usr/src/contrib/wpa/src/crypto/sha256.c:			hmac_sha256_vector(key, key_len, 4, addr, len,
/usr/src/contrib/wpa/src/crypto/sha256.c:			hmac_sha256_vector(key, key_len, 4, addr, len, hash);
/usr/src/contrib/wpa/src/crypto/tls_gnutls.c:	gnutls_mac_algorithm_t read_mac_algorithm;
/usr/src/contrib/wpa/src/crypto/tls_gnutls.c:	gnutls_mac_algorithm_t write_mac_algorithm;
/usr/src/contrib/wpa/src/drivers/driver_ndis.c:static const u8 * wpa_driver_ndis_get_mac_addr(void *priv)
/usr/src/contrib/wpa/src/drivers/driver_ndis.c:	wpa_driver_ndis_get_mac_addr,
/usr/src/contrib/wpa/src/drivers/driver_wired.c:	u8 *mac_address;
/usr/src/contrib/wpa/src/drivers/driver_wired.c:	mac_address = (u8 *) &(msg->chaddr);
/usr/src/contrib/wpa/src/drivers/driver_wired.c:		   MAC2STR(mac_address));
/usr/src/contrib/wpa/src/drivers/driver_wired.c:	event.new_sta.addr = mac_address;
/usr/src/contrib/wpa/src/eap_common/eap_gpsk_common.c:		hmac_sha256_vector(psk, 32, 2, addr, vlen, hash);
/usr/src/contrib/wpa/src/eap_common/eap_gpsk_common.c:		hmac_sha256(sk, sk_len, data, len, mic);
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c: * @mac_id: MAC ID (EAP_PAX_MAC_*) / currently, only HMAC_SHA1_128 is supported
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:int eap_pax_kdf(u8 mac_id, const u8 *key, size_t key_len,
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	if (mac_id != EAP_PAX_MAC_HMAC_SHA1_128)
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:		hmac_sha1_vector(key, key_len, 3, addr, len, mac);
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c: * @mac_id: MAC ID (EAP_PAX_MAC_*) / currently, only HMAC_SHA1_128 is supported
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:int eap_pax_mac(u8 mac_id, const u8 *key, size_t key_len,
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	if (mac_id != EAP_PAX_MAC_HMAC_SHA1_128)
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	hmac_sha1_vector(key, key_len, count, addr, len, hash);
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c: * @mac_id: MAC ID (EAP_PAX_MAC_*) / currently, only HMAC_SHA1_128 is supported
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:int eap_pax_initial_key_derivation(u8 mac_id, const u8 *ak, const u8 *e,
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	if (eap_pax_kdf(mac_id, ak, EAP_PAX_AK_LEN, "Master Key",
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	    eap_pax_kdf(mac_id, mk, EAP_PAX_MK_LEN, "Confirmation Key",
/usr/src/contrib/wpa/src/eap_common/eap_pax_common.c:	    eap_pax_kdf(mac_id, mk, EAP_PAX_MK_LEN, "Integrity Check Key",
/usr/src/contrib/wpa/src/eap_common/eap_peap_common.c:		hmac_sha1_vector(key, key_len, 5, addr, len, hash);
/usr/src/contrib/wpa/src/eap_common/eap_sake_common.c:			hmac_sha1_vector(key, key_len, 4, addr, len,
/usr/src/contrib/wpa/src/eap_common/eap_sake_common.c:			hmac_sha1_vector(key, key_len, 4, addr, len,
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:	hmac_sha1_vector(k_aut, EAP_SIM_K_AUT_LEN, 2, addr, len, hmac);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:	hmac_sha1_vector(k_aut, EAP_SIM_K_AUT_LEN, 2, addr, len, hmac);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:		hmac_sha256_vector(k, 32, 5, addr, len, hash);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:int eap_sim_verify_mac_sha256(const u8 *k_aut, const struct wpabuf *req,
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:	hmac_sha256_vector(k_aut, EAP_AKA_PRIME_K_AUT_LEN, 2, addr, len, hmac);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:void eap_sim_add_mac_sha256(const u8 *k_aut, const u8 *msg, size_t msg_len,
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:	hmac_sha256_vector(k_aut, EAP_AKA_PRIME_K_AUT_LEN, 2, addr, len, hmac);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:	hmac_sha256_vector(key, sizeof(key), 5, addr, len, hash);
/usr/src/contrib/wpa/src/eap_common/eap_sim_common.c:		eap_sim_add_mac_sha256(k_aut, (u8 *) wpabuf_head(msg->buf),
/usr/src/contrib/wpa/src/eap_common/ikev2_common.c:		hmac_sha1(key, key_len, data, data_len, tmphash);
/usr/src/contrib/wpa/src/eap_common/ikev2_common.c:		hmac_md5(key, key_len, data, data_len, tmphash);
/usr/src/contrib/wpa/src/eap_common/ikev2_common.c:		hmac_sha1_vector(key, key_len, num_elem, addr, len, hash);
/usr/src/contrib/wpa/src/eap_common/ikev2_common.c:		hmac_md5_vector(key, key_len, num_elem, addr, len, hash);
/usr/src/contrib/wpa/src/eap_peer/eap_aka.c:		return eap_sim_verify_mac_sha256(data->k_aut, req, mac, extra,
/usr/src/contrib/wpa/src/eap_peer/eap_fast.c:	hmac_sha1(cmk, EAP_FAST_CMK_LEN, (u8 *) rbind, sizeof(*rbind),
/usr/src/contrib/wpa/src/eap_peer/eap_fast.c:	hmac_sha1(cmk, EAP_FAST_CMK_LEN, (u8 *) _bind, bind_len,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	u8 mac_id, dh_group_id, public_key_id;
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	pax->mac_id = req->mac_id;
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	if (eap_pax_initial_key_derivation(req->mac_id, data->ak, data->rand.e,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_mac(req->mac_id, data->ck, EAP_PAX_CK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_mac(req->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	data->mac_id = req->mac_id;
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_mac(data->mac_id, data->ck, EAP_PAX_CK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_mac(data->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:		   "flags 0x%x mac_id 0x%x dh_group_id 0x%x "
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:		   req->op_code, req->flags, req->mac_id, req->dh_group_id,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	if (data->state != PAX_INIT && data->mac_id != req->mac_id) {
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:			   data->mac_id, req->mac_id);
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	if (req->mac_id != EAP_PAX_MAC_HMAC_SHA1_128) {
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:			   req->mac_id);
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:		eap_pax_mac(req->mac_id, (u8 *) "", 0,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:		eap_pax_mac(req->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_kdf(data->mac_id, data->mk, EAP_PAX_MK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_pax.c:	eap_pax_kdf(data->mac_id, data->mk, EAP_PAX_MK_LEN,
/usr/src/contrib/wpa/src/eap_peer/eap_peap.c:	hmac_sha1_vector(data->cmk, 20, 2, addr, len, mac);
/usr/src/contrib/wpa/src/eap_peer/eap_peap.c:	hmac_sha1(data->cmk, 20, buf, sizeof(buf), mac);
/usr/src/contrib/wpa/src/eap_peer/eap_psk.c:	if (omac1_aes_128(data->ak, buf, buflen, hdr2->mac_p)) {
/usr/src/contrib/wpa/src/eap_peer/eap_psk.c:	wpa_hexdump(MSG_DEBUG, "EAP-PSK: MAC_P", hdr2->mac_p, EAP_PSK_MAC_LEN);
/usr/src/contrib/wpa/src/eap_peer/eap_psk.c:	wpa_hexdump(MSG_DEBUG, "EAP-PSK: MAC_S", hdr3->mac_s, EAP_PSK_MAC_LEN);
/usr/src/contrib/wpa/src/eap_peer/eap_psk.c:	if (os_memcmp(mac, hdr3->mac_s, EAP_PSK_MAC_LEN) != 0) {
/usr/src/contrib/wpa/src/eap_server/eap_server_aka.c:		return eap_sim_verify_mac_sha256(data->k_aut, req, mac, extra,
/usr/src/contrib/wpa/src/eap_server/eap_server_fast.c:	hmac_sha1(data->cmk, EAP_FAST_CMK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_fast.c:	hmac_sha1(data->cmk, EAP_FAST_CMK_LEN, (u8 *) b, bind_len,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	u8 mac_id;
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	data->mac_id = EAP_PAX_MAC_HMAC_SHA1_128;
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	pax->mac_id = data->mac_id;
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_mac(data->mac_id, (u8 *) "", 0,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	pax->mac_id = data->mac_id;
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_mac(data->mac_id, data->ck, EAP_PAX_CK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_mac(data->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:		   "flags 0x%x mac_id 0x%x dh_group_id 0x%x "
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:		   resp->op_code, resp->flags, resp->mac_id, resp->dh_group_id,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	if (data->mac_id != resp->mac_id) {
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:			   "received 0x%x", data->mac_id, resp->mac_id);
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:		eap_pax_mac(data->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	if (eap_pax_initial_key_derivation(data->mac_id, data->ak,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_mac(data->mac_id, data->ck, EAP_PAX_CK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_mac(data->mac_id, data->ick, EAP_PAX_ICK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_kdf(data->mac_id, data->mk, EAP_PAX_MK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_pax.c:	eap_pax_kdf(data->mac_id, data->mk, EAP_PAX_MK_LEN,
/usr/src/contrib/wpa/src/eap_server/eap_server_peap.c:		hmac_sha1_vector(data->cmk, 20, 2, addr, len, mac);
/usr/src/contrib/wpa/src/eap_server/eap_server_peap.c:	hmac_sha1(data->cmk, 20, buf, sizeof(buf), mac);
/usr/src/contrib/wpa/src/eap_server/eap_server_psk.c:	if (omac1_aes_128(data->ak, buf, buflen, psk->mac_s))
/usr/src/contrib/wpa/src/eap_server/eap_server_psk.c:	wpa_hexdump(MSG_DEBUG, "EAP-PSK: MAC_P", resp->mac_p, EAP_PSK_MAC_LEN);
/usr/src/contrib/wpa/src/eap_server/eap_server_psk.c:	if (os_memcmp(mac, resp->mac_p, EAP_PSK_MAC_LEN) != 0) {
/usr/src/contrib/wpa/src/eapol_supp/eapol_supp_sm.c:	hmac_md5(keydata.sign_key, sign_key_len,
/usr/src/contrib/wpa/src/radius/radius.c:		hmac_md5(secret, secret_len, wpabuf_head(msg->buf),
/usr/src/contrib/wpa/src/radius/radius.c:	hmac_md5(secret, secret_len, wpabuf_head(msg->buf),
/usr/src/contrib/wpa/src/radius/radius.c:	hmac_md5(secret, secret_len, wpabuf_head(msg->buf),
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	if (kde.rsn_ie == NULL || kde.mac_addr == NULL ||
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	    kde.mac_addr_len < ETH_ALEN) {
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		   MAC2STR(kde.mac_addr));
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		wpa_supplicant_send_smk_error(sm, src_addr, kde.mac_addr,
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	os_memcpy(peerkey->addr, kde.mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c: * @mac_p: Peer MAC address
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c: * @mac_i: Initiator MAC address
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:static void rsn_smkid(const u8 *smk, const u8 *pnonce, const u8 *mac_p,
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		      const u8 *inonce, const u8 *mac_i, u8 *smkid,
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	addr[2] = mac_p;
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	addr[4] = mac_i;
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		hmac_sha256_vector(smk, PMK_LEN, 5, addr, len, hash);
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		hmac_sha1_vector(smk, PMK_LEN, 5, addr, len, hash);
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		   MAC2STR(kde->mac_addr));
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		   MAC2STR(kde->mac_addr));
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:			   "unacceptable cipher", MAC2STR(kde->mac_addr));
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		wpa_supplicant_send_smk_error(sm, src_addr, kde->mac_addr,
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	if (kde.mac_addr == NULL || kde.mac_addr_len < ETH_ALEN ||
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		if (os_memcmp(peerkey->addr, kde.mac_addr, ETH_ALEN) == 0 &&
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:			   MAC2STR(kde.mac_addr));
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	if (kde.mac_addr && kde.mac_addr_len >= ETH_ALEN)
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:		os_memcpy(peer, kde.mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:	if (kde.mac_addr &&
/usr/src/contrib/wpa/src/rsn_supp/peerkey.c:			if (os_memcmp(peerkey->addr, kde.mac_addr, ETH_ALEN) ==
/usr/src/contrib/wpa/src/rsn_supp/wpa_ie.c:		ie->mac_addr = pos + 2 + RSN_SELECTOR_LEN;
/usr/src/contrib/wpa/src/rsn_supp/wpa_ie.c:		ie->mac_addr_len = pos[1] - RSN_SELECTOR_LEN;
/usr/src/contrib/wpa/src/tls/tlsv1_client.c:	os_memcpy(conn->rl.write_mac_secret, pos, conn->rl.hash_size);
/usr/src/contrib/wpa/src/tls/tlsv1_client.c:	os_memcpy(conn->rl.read_mac_secret, pos, conn->rl.hash_size);
/usr/src/contrib/wpa/src/tls/tlsv1_record.c:		hmac = crypto_hash_init(rl->hash_alg, rl->write_mac_secret,
/usr/src/contrib/wpa/src/tls/tlsv1_record.c:		hmac = crypto_hash_init(rl->hash_alg, rl->read_mac_secret,
/usr/src/contrib/wpa/src/tls/tlsv1_server.c:	os_memcpy(conn->rl.read_mac_secret, pos, conn->rl.hash_size);
/usr/src/contrib/wpa/src/tls/tlsv1_server.c:	os_memcpy(conn->rl.write_mac_secret, pos, conn->rl.hash_size);
/usr/src/contrib/wpa/src/wps/wps.c:		os_memcpy(data->mac_addr_e, cfg->wps->dev.mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps.c:		os_memcpy(data->peer_dev.mac_addr, cfg->peer_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_attr_build.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 2, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_attr_build.c:	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, wpabuf_head(msg),
/usr/src/contrib/wpa/src/wps/wps_attr_parse.c:		attr->mac_addr = pos;
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 2, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, head, len, hash);
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:static int wps_process_cred_mac_addr(struct wps_credential *cred,
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:				     const u8 *mac_addr)
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	if (mac_addr == NULL) {
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	wpa_printf(MSG_DEBUG, "WPS: MAC Address " MACSTR, MAC2STR(mac_addr));
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	os_memcpy(cred->mac_addr, mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	    wps_process_cred_mac_addr(cred, attr->mac_addr) ||
/usr/src/contrib/wpa/src/wps/wps_attr_process.c:	    wps_process_cred_mac_addr(cred, attr->mac_addr))
/usr/src/contrib/wpa/src/wps/wps_common.c:		hmac_sha256_vector(key, SHA256_MAC_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_common.c:	addr[1] = wps->mac_addr_e;
/usr/src/contrib/wpa/src/wps/wps_common.c:	hmac_sha256_vector(dhkey, sizeof(dhkey), 3, addr, len, kdk);
/usr/src/contrib/wpa/src/wps/wps_common.c:	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN, dev_passwd,
/usr/src/contrib/wpa/src/wps/wps_common.c:	hmac_sha256(wps->authkey, WPS_AUTHKEY_LEN,
/usr/src/contrib/wpa/src/wps/wps_common.c:void uuid_gen_mac_addr(const u8 *mac_addr, u8 *uuid)
/usr/src/contrib/wpa/src/wps/wps_common.c:	addr[1] = mac_addr;
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:static int wps_build_mac_addr(struct wps_data *wps, struct wpabuf *msg)
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	wpabuf_put_data(msg, wps->mac_addr_e, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	    wps_build_mac_addr(wps, msg) ||
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:static int wps_build_cred_mac_addr(struct wps_data *wps, struct wpabuf *msg)
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	wpabuf_put_data(msg, wps->wps->dev.mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:		wps_build_cred_mac_addr(wps, plain) ||
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	if (os_memcmp(wps->cred.mac_addr, wps->wps->dev.mac_addr, ETH_ALEN) !=
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:			   ")", MAC2STR(wps->cred.mac_addr),
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:			   MAC2STR(wps->wps->dev.mac_addr));
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:	if (os_memcmp(cred.mac_addr, wps->wps->dev.mac_addr, ETH_ALEN) !=
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:			   ")", MAC2STR(cred.mac_addr),
/usr/src/contrib/wpa/src/wps/wps_enrollee.c:			   MAC2STR(wps->wps->dev.mac_addr));
/usr/src/contrib/wpa/src/wps/wps_er.c:	ev->mac_addr = sta->addr;
/usr/src/contrib/wpa/src/wps/wps_er.c:	evap->mac_addr = ap->mac_addr;
/usr/src/contrib/wpa/src/wps/wps_er.c:	if (attr.mac_addr)
/usr/src/contrib/wpa/src/wps/wps_er.c:		os_memcpy(ap->mac_addr, attr.mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_er.c:			os_memcpy(sta->cred->mac_addr, sta->addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_er.c:			   er->mac_addr)) {
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	int (*new_psk_cb)(void *ctx, const u8 *mac_addr, const u8 *psk,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	void (*reg_success_cb)(void *ctx, const u8 *mac_addr,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:		if (os_memcmp(dev->dev.mac_addr, addr, ETH_ALEN) == 0)
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	os_memcpy(dst->mac_addr, src->mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	d = wps_device_get(reg, dev->mac_addr);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:static int wps_cb_new_psk(struct wps_registrar *reg, const u8 *mac_addr,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	return reg->new_psk_cb(reg->cb_ctx, mac_addr, psk, psk_len);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:static void wps_cb_reg_success(struct wps_registrar *reg, const u8 *mac_addr,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	reg->reg_success_cb(reg->cb_ctx, mac_addr, uuid_e);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:static int wps_build_cred_mac_addr(struct wpabuf *msg,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:		   MAC2STR(cred->mac_addr));
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	wpabuf_put_data(msg, cred->mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	    wps_build_cred_mac_addr(msg, cred))
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	os_memcpy(wps->cred.mac_addr, wps->mac_addr_e, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	hmac_sha256_vector(wps->authkey, WPS_AUTHKEY_LEN, 4, addr, len, hash);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:static int wps_process_mac_addr(struct wps_data *wps, const u8 *mac_addr)
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	if (mac_addr == NULL) {
/usr/src/contrib/wpa/src/wps/wps_registrar.c:		   MAC2STR(mac_addr));
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	os_memcpy(wps->mac_addr_e, mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	os_memcpy(wps->peer_dev.mac_addr, mac_addr, ETH_ALEN);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	    wps_process_mac_addr(wps, attr->mac_addr) ||
/usr/src/contrib/wpa/src/wps/wps_registrar.c:					      wps->mac_addr_e, wps->uuid_e)) {
/usr/src/contrib/wpa/src/wps/wps_registrar.c:					      wps->mac_addr_e, wps->uuid_e);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:		if (wps->wps->wps_upnp && attr.mac_addr) {
/usr/src/contrib/wpa/src/wps/wps_registrar.c:				wps->wps->wps_upnp, attr.mac_addr,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:		if (wps_cb_new_psk(wps->wps->registrar, wps->mac_addr_e,
/usr/src/contrib/wpa/src/wps/wps_registrar.c:	wps_cb_reg_success(wps->wps->registrar, wps->mac_addr_e, wps->uuid_e);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:						 wps->mac_addr_e, wps->uuid_e);
/usr/src/contrib/wpa/src/wps/wps_registrar.c:						wps->mac_addr_e,
/usr/src/contrib/wpa/src/wps/wps_ufd.c:			u8 *mac_addr = wps->dev.mac_addr;
/usr/src/contrib/wpa/src/wps/wps_ufd.c:				    mac_addr[2], mac_addr[3], mac_addr[4],
/usr/src/contrib/wpa/src/wps/wps_ufd.c:				    mac_addr[5]);
/usr/src/contrib/wpa/src/wps/wps_upnp.c: * @from_mac_addr: Source (Enrollee) MAC address for the event
/usr/src/contrib/wpa/src/wps/wps_upnp.c:				    const u8 from_mac_addr[ETH_ALEN],
/usr/src/contrib/wpa/src/wps/wps_upnp.c:	const u8 *mac = from_mac_addr;
/usr/src/contrib/wpa/src/wps/wps_upnp.c:	char mac_text[18];
/usr/src/contrib/wpa/src/wps/wps_upnp.c:	os_snprintf(mac_text, sizeof(mac_text), MACSTR, MAC2STR(mac));
/usr/src/contrib/wpa/src/wps/wps_upnp.c:		   mac_text);
/usr/src/contrib/wpa/src/wps/wps_upnp.c:	os_memcpy(raw + pos, mac_text, 17);
/usr/src/contrib/wpa/src/wps/wps_upnp.c:			   sm->mac_addr)) {
/usr/src/contrib/wpa/wpa_supplicant/ap.c:static void ap_wps_reg_success_cb(void *ctx, const u8 *mac_addr,
/usr/src/contrib/wpa/wpa_supplicant/ap.c:int wpa_supplicant_ap_mac_addr_filter(struct wpa_supplicant *wpa_s,
/usr/src/contrib/wpa/wpa_supplicant/ap.c:	conf->accept_mac = os_zalloc(sizeof(struct mac_acl_entry));
/usr/src/contrib/wpa/wpa_supplicant/wpa_supplicant.c:		const u8 *addr = wpa_drv_get_mac_addr(wpa_s);
/usr/src/contrib/wpa/wpa_supplicant/wpa_supplicant.c:					   wpa_drv_get_mac_addr(wpa_s),
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:	bss = wpa_bss_get(wpa_s, cred->mac_addr, ssid->ssid, ssid->ssid_len);
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		   MAC2STR(cred->mac_addr));
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		uuid_str, MAC2STR(ap->mac_addr), dev_type, ap->wps_state,
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		uuid_str, MAC2STR(enrollee->mac_addr), enrollee->m1_received,
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		uuid_str, MAC2STR(enrollee->mac_addr));
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:static int wpas_wps_new_psk_cb(void *ctx, const u8 *mac_addr, const u8 *psk,
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		   "STA " MACSTR, MAC2STR(mac_addr));
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:			  uuid, MAC2STR(dev->mac_addr), dev->device_name,
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:	os_memcpy(wps->dev.mac_addr, wpa_s->own_addr, ETH_ALEN);
/usr/src/contrib/wpa/wpa_supplicant/wps_supplicant.c:		uuid_gen_mac_addr(wpa_s->own_addr, wps->uuid);
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:			printf("\t%s\n",macros[i].mac_name);
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:	strlcpy(macros[macnum].mac_name,
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:			sizeof(macros[macnum].mac_name));
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:		macros[macnum].mac_start = macbuf;
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:	tmp = macros[macnum].mac_start;
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:			if (tmp == macros[macnum].mac_start) {
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:				macros[macnum++].mac_end = tmp;
/usr/src/crypto/heimdal/appl/ftp/ftp/cmds.c:				macros[macnum++].mac_end = tmp - 1;
/usr/src/crypto/heimdal/appl/ftp/ftp/domacro.c:		if (!strncmp(argv[1], macros[i].mac_name, 9)) {
/usr/src/crypto/heimdal/appl/ftp/ftp/domacro.c:	cp1 = macros[i].mac_start;
/usr/src/crypto/heimdal/appl/ftp/ftp/domacro.c:	while (cp1 != macros[i].mac_end) {
/usr/src/crypto/heimdal/appl/ftp/ftp/domacro.c:		if (cp1 != macros[i].mac_end) {
/usr/src/crypto/heimdal/appl/ftp/ftp/ftp.c:	if (!strcmp("init", macros[n].mac_name)) {
/usr/src/crypto/heimdal/appl/ftp/ftp/ruserpass.c:	    tmp = macros[macnum].mac_name;
/usr/src/crypto/heimdal/appl/ftp/ftp/ruserpass.c:		macros[macnum].mac_start = macbuf;
/usr/src/crypto/heimdal/appl/ftp/ftp/ruserpass.c:		macros[macnum].mac_start = macros[macnum-1].mac_end + 1;
/usr/src/crypto/heimdal/appl/ftp/ftp/ruserpass.c:	    tmp = macros[macnum].mac_start;
/usr/src/crypto/heimdal/appl/ftp/ftp/ruserpass.c:			macros[macnum++].mac_end = tmp - 1;
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_des_mac_k = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_hmac_sha1_des3 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_hmac_sha1_aes128 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_hmac_sha1_aes256 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_hmac_md5 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct checksum_type checksum_hmac_md5_enc = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_des_mac_k,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_des3,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_aes128,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_aes256,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_md5,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_md5_enc
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct encryption_type enctype_arcfour_hmac_md5 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_md5,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_des3,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_des3,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct encryption_type enctype_aes128_cts_hmac_sha1 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_aes128,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:static struct encryption_type enctype_aes256_cts_hmac_sha1 = {
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &checksum_hmac_sha1_aes256,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &enctype_arcfour_hmac_md5,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &enctype_aes128_cts_hmac_sha1,
/usr/src/crypto/heimdal/lib/krb5/crypto.c:    &enctype_aes256_cts_hmac_sha1,
/usr/src/crypto/openssh/hostfile.c:	HMAC_CTX mac_ctx;
/usr/src/crypto/openssh/hostfile.c:	HMAC_Init(&mac_ctx, salt, len, md);
/usr/src/crypto/openssh/hostfile.c:	HMAC_Update(&mac_ctx, host, strlen(host));
/usr/src/crypto/openssh/hostfile.c:	HMAC_Final(&mac_ctx, result, NULL);
/usr/src/crypto/openssh/hostfile.c:	HMAC_cleanup(&mac_ctx);
/usr/src/crypto/openssh/kex.c:	if (mac_setup(mac, name) < 0)
/usr/src/crypto/openssh/mac.c:mac_setup_by_id(Mac *mac, int which)
/usr/src/crypto/openssh/mac.c:		mac->key_len = mac->mac_len = (u_int)evp_len;
/usr/src/crypto/openssh/mac.c:		mac->mac_len = macs[which].len / 8;
/usr/src/crypto/openssh/mac.c:		mac->umac_ctx = NULL;
/usr/src/crypto/openssh/mac.c:		mac->mac_len = macs[which].truncatebits / 8;
/usr/src/crypto/openssh/mac.c:mac_setup(Mac *mac, char *name)
/usr/src/crypto/openssh/mac.c:				mac_setup_by_id(mac, i);
/usr/src/crypto/openssh/mac.c:			debug2("mac_setup: found %s", name);
/usr/src/crypto/openssh/mac.c:	debug2("mac_setup: unknown %s", name);
/usr/src/crypto/openssh/mac.c:mac_init(Mac *mac)
/usr/src/crypto/openssh/mac.c:		fatal("mac_init: no key");
/usr/src/crypto/openssh/mac.c:		mac->umac_ctx = umac_new(mac->key);
/usr/src/crypto/openssh/mac.c:		mac->umac_ctx = umac128_new(mac->key);
/usr/src/crypto/openssh/mac.c:mac_compute(Mac *mac, u_int32_t seqno, u_char *data, int datalen)
/usr/src/crypto/openssh/mac.c:	if (mac->mac_len > sizeof(m))
/usr/src/crypto/openssh/mac.c:		fatal("mac_compute: mac too long %u %lu",
/usr/src/crypto/openssh/mac.c:		    mac->mac_len, (u_long)sizeof(m));
/usr/src/crypto/openssh/mac.c:		umac_update(mac->umac_ctx, data, datalen);
/usr/src/crypto/openssh/mac.c:		umac_final(mac->umac_ctx, m, nonce);
/usr/src/crypto/openssh/mac.c:		umac128_update(mac->umac_ctx, data, datalen);
/usr/src/crypto/openssh/mac.c:		umac128_final(mac->umac_ctx, m, nonce);
/usr/src/crypto/openssh/mac.c:		fatal("mac_compute: unknown MAC type");
/usr/src/crypto/openssh/mac.c:mac_clear(Mac *mac)
/usr/src/crypto/openssh/mac.c:		if (mac->umac_ctx != NULL)
/usr/src/crypto/openssh/mac.c:			umac_delete(mac->umac_ctx);
/usr/src/crypto/openssh/mac.c:		if (mac->umac_ctx != NULL)
/usr/src/crypto/openssh/mac.c:			umac128_delete(mac->umac_ctx);
/usr/src/crypto/openssh/mac.c:	mac->umac_ctx = NULL;
/usr/src/crypto/openssh/mac.c:mac_valid(const char *names)
/usr/src/crypto/openssh/mac.c:		if (mac_setup(NULL, p) < 0) {
/usr/src/crypto/openssh/monitor_wrap.c:		if (mac->name == NULL || mac_setup(mac, mac->name) == -1)
/usr/src/crypto/openssh/packet.c:		(void) mac_compute(active_state->packet_discard_mac,
/usr/src/crypto/openssh/packet.c:		mac_clear(mac);
/usr/src/crypto/openssh/packet.c:	if (cipher_authlen(enc->cipher) == 0 && mac_init(mac) == 0)
/usr/src/crypto/openssh/packet.c:		macbuf = mac_compute(mac, active_state->p_send.seqnr,
/usr/src/crypto/openssh/packet.c:			macbuf = mac_compute(mac,
/usr/src/crypto/openssh/packet.c:		buffer_append(&active_state->output, macbuf, mac->mac_len);
/usr/src/crypto/openssh/packet.c:	maclen = mac && mac->enabled ? mac->mac_len : 0;
/usr/src/crypto/openssh/packet.c:		macbuf = mac_compute(mac, active_state->p_read.seqnr,
/usr/src/crypto/openssh/packet.c:			macbuf = mac_compute(mac, active_state->p_read.seqnr,
/usr/src/crypto/openssh/packet.c:		    mac->mac_len) != 0) {
/usr/src/crypto/openssh/packet.c:		buffer_consume(&active_state->input, mac->mac_len);
/usr/src/crypto/openssh/readconf.c:		if (!mac_valid(arg))
/usr/src/crypto/openssh/servconf.c:		if (!mac_valid(arg))
/usr/src/crypto/openssh/ssh.c:"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
/usr/src/crypto/openssh/ssh.c:			if (mac_valid(optarg))
/usr/src/crypto/openssh/umac.c:struct umac_ctx {
/usr/src/crypto/openssh/umac.c:} umac_ctx;
/usr/src/crypto/openssh/umac.c:int umac_reset(struct umac_ctx *ctx)
/usr/src/crypto/openssh/umac.c:int umac_delete(struct umac_ctx *ctx)
/usr/src/crypto/openssh/umac.c:            ctx = (struct umac_ctx *)ctx->free_ptr;
/usr/src/crypto/openssh/umac.c:struct umac_ctx *umac_new(u_char key[])
/usr/src/crypto/openssh/umac.c:/* Dynamically allocate a umac_ctx struct, initialize variables, 
/usr/src/crypto/openssh/umac.c:    struct umac_ctx *ctx, *octx;
/usr/src/crypto/openssh/umac.c:            ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);
/usr/src/crypto/openssh/umac.c:int umac_final(struct umac_ctx *ctx, u_char tag[], u_char nonce[8])
/usr/src/crypto/openssh/umac.c:int umac_update(struct umac_ctx *ctx, u_char *input, long len)
/usr/src/crypto/openssh/umac.c:int umac(struct umac_ctx *ctx, u_char *input, 
/usr/src/crypto/openssh/umac.c:/* All-in-one version simply calls umac_update() and umac_final().        */
/usr/src/crypto/openssh/umac128.c:#undef umac_new
/usr/src/crypto/openssh/umac128.c:#define umac_new		ssh_umac128_new
/usr/src/crypto/openssh/umac128.c:#undef umac_update
/usr/src/crypto/openssh/umac128.c:#define umac_update		ssh_umac128_update
/usr/src/crypto/openssh/umac128.c:#undef umac_final
/usr/src/crypto/openssh/umac128.c:#define umac_final		ssh_umac128_final
/usr/src/crypto/openssh/umac128.c:#undef umac_delete
/usr/src/crypto/openssh/umac128.c:#define umac_delete		ssh_umac128_delete
/usr/src/crypto/openssl/apps/dgst.c:	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow);
/usr/src/crypto/openssl/apps/dgst.c:	char *hmac_key=NULL;
/usr/src/crypto/openssl/apps/dgst.c:			hmac_key = "etaonrishdlcupfm";
/usr/src/crypto/openssl/apps/dgst.c:			hmac_key=*++argv;
/usr/src/crypto/openssl/apps/dgst.c:			  siglen,"","(stdin)",bmd,hmac_key,non_fips_allow);
/usr/src/crypto/openssl/apps/dgst.c:				size_t len = strlen(name)+strlen(argv[i])+(hmac_key ? 5 : 0)+5;
/usr/src/crypto/openssl/apps/dgst.c:							 hmac_key ? "HMAC-" : "",name,argv[i]);
/usr/src/crypto/openssl/apps/dgst.c:				siglen,tmp,argv[i],bmd,hmac_key,non_fips_allow);
/usr/src/crypto/openssl/apps/dgst.c:	  const char *file,BIO *bmd,const char *hmac_key,int non_fips_allow)
/usr/src/crypto/openssl/apps/dgst.c:	HMAC_CTX hmac_ctx;
/usr/src/crypto/openssl/apps/dgst.c:	if (hmac_key)
/usr/src/crypto/openssl/apps/dgst.c:		HMAC_CTX_init(&hmac_ctx);
/usr/src/crypto/openssl/apps/dgst.c:		HMAC_Init_ex(&hmac_ctx,hmac_key,strlen(hmac_key),md, NULL);
/usr/src/crypto/openssl/apps/dgst.c:		BIO_set_md_ctx(bmd,&hmac_ctx.md_ctx);
/usr/src/crypto/openssl/apps/dgst.c:	else if(hmac_key)
/usr/src/crypto/openssl/apps/dgst.c:		HMAC_Final(&hmac_ctx,buf,&len);
/usr/src/crypto/openssl/apps/dgst.c:		HMAC_CTX_cleanup(&hmac_ctx);
/usr/src/crypto/openssl/apps/dgst.c:	if (hmac_key)
/usr/src/crypto/openssl/crypto/pkcs12/p12_crt.c:	     STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter, int mac_iter,
/usr/src/crypto/openssl/crypto/pkcs12/p12_crt.c:	if (!mac_iter)
/usr/src/crypto/openssl/crypto/pkcs12/p12_crt.c:		mac_iter = 1;
/usr/src/crypto/openssl/crypto/pkcs12/p12_crt.c:	if ((mac_iter != -1) &&
/usr/src/crypto/openssl/crypto/pkcs12/p12_crt.c:		!PKCS12_set_mac(p12, pass, -1, NULL, 0, mac_iter, NULL))
/usr/src/crypto/openssl/fips/fips.c:static const char          FIPS_hmac_key[]="etaonrishdlcupfm";
/usr/src/crypto/openssl/fips/fips.c:    HMAC_Init(&c,FIPS_hmac_key,strlen(FIPS_hmac_key),EVP_sha1());
/usr/src/crypto/openssl/fips/fips_test_suite.c:static int FIPS_hmac_sha1_test()
/usr/src/crypto/openssl/fips/fips_test_suite.c:static int FIPS_hmac_sha224_test()
/usr/src/crypto/openssl/fips/fips_test_suite.c:static int FIPS_hmac_sha256_test()
/usr/src/crypto/openssl/fips/fips_test_suite.c:static int FIPS_hmac_sha384_test()
/usr/src/crypto/openssl/fips/fips_test_suite.c:static int FIPS_hmac_sha512_test()
/usr/src/crypto/openssl/fips/fips_test_suite.c:    test_msg("7d. HMAC-SHA-1 hash", FIPS_hmac_sha1_test());
/usr/src/crypto/openssl/fips/fips_test_suite.c:    test_msg("7e. HMAC-SHA-224 hash", FIPS_hmac_sha224_test());
/usr/src/crypto/openssl/fips/fips_test_suite.c:    test_msg("7f. HMAC-SHA-256 hash", FIPS_hmac_sha256_test());
/usr/src/crypto/openssl/fips/fips_test_suite.c:    test_msg("7g. HMAC-SHA-384 hash", FIPS_hmac_sha384_test());
/usr/src/crypto/openssl/fips/fips_test_suite.c:    test_msg("7h. HMAC-SHA-512 hash", FIPS_hmac_sha512_test());
/usr/src/crypto/openssl/fips/hmac/fips_hmactest.c:static int hmac_test(const EVP_MD *md, FILE *out, FILE *in);
/usr/src/crypto/openssl/fips/hmac/fips_hmactest.c:	if (!hmac_test(EVP_sha1(), out, in))
/usr/src/crypto/openssl/fips/hmac/fips_hmactest.c:int hmac_test(const EVP_MD *md, FILE *out, FILE *in)
/usr/src/crypto/openssl/fips/sha/fips_standalone_sha1.c:static void hmac_init(SHA_CTX *md_ctx,SHA_CTX *o_ctx,
/usr/src/crypto/openssl/fips/sha/fips_standalone_sha1.c:static void hmac_final(unsigned char *md,SHA_CTX *md_ctx,SHA_CTX *o_ctx)
/usr/src/crypto/openssl/fips/sha/fips_standalone_sha1.c:	hmac_init(&md_ctx,&o_ctx,key);
/usr/src/crypto/openssl/fips/sha/fips_standalone_sha1.c:	hmac_final(md,&md_ctx,&o_ctx);
/usr/src/crypto/openssl/ssl/d1_both.c:	unsigned int len, frag_off, mac_size, blocksize;
/usr/src/crypto/openssl/ssl/d1_both.c:		mac_size = EVP_MD_size(s->write_hash);
/usr/src/crypto/openssl/ssl/d1_both.c:		mac_size = 0;
/usr/src/crypto/openssl/ssl/d1_both.c:			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;
/usr/src/crypto/openssl/ssl/d1_both.c:				mac_size - blocksize;
/usr/src/crypto/openssl/ssl/d1_both.c: * ssl->s3->read_mac_secret		re-init
/usr/src/crypto/openssl/ssl/d1_enc.c:	int bs,i,j,k,mac_size=0;
/usr/src/crypto/openssl/ssl/d1_enc.c:			mac_size=EVP_MD_size(s->write_hash);
/usr/src/crypto/openssl/ssl/d1_enc.c:			if (mac_size < 0)
/usr/src/crypto/openssl/ssl/d1_enc.c:			mac_size=EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/d1_enc.c:			OPENSSL_assert(mac_size >= 0);
/usr/src/crypto/openssl/ssl/d1_enc.c:			return tls1_cbc_remove_padding(s, rec, bs, mac_size);
/usr/src/crypto/openssl/ssl/d1_pkt.c:	unsigned int mac_size, orig_len;
/usr/src/crypto/openssl/ssl/d1_pkt.c:		/* s->read_hash != NULL => mac_size != -1 */
/usr/src/crypto/openssl/ssl/d1_pkt.c:		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
/usr/src/crypto/openssl/ssl/d1_pkt.c:		mac_size=EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/d1_pkt.c:		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
/usr/src/crypto/openssl/ssl/d1_pkt.c:		if (orig_len < mac_size ||
/usr/src/crypto/openssl/ssl/d1_pkt.c:		     orig_len < mac_size+1))
/usr/src/crypto/openssl/ssl/d1_pkt.c:			mac = mac_tmp;
/usr/src/crypto/openssl/ssl/d1_pkt.c:			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
/usr/src/crypto/openssl/ssl/d1_pkt.c:			rr->length -= mac_size;
/usr/src/crypto/openssl/ssl/d1_pkt.c:			 * enough bytes for |mac_size| above. */
/usr/src/crypto/openssl/ssl/d1_pkt.c:			rr->length -= mac_size;
/usr/src/crypto/openssl/ssl/d1_pkt.c:		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
/usr/src/crypto/openssl/ssl/d1_pkt.c:		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)
/usr/src/crypto/openssl/ssl/d1_pkt.c:	int i,mac_size,clear=0;
/usr/src/crypto/openssl/ssl/d1_pkt.c:		mac_size=0;
/usr/src/crypto/openssl/ssl/d1_pkt.c:		mac_size=EVP_MD_size(s->write_hash);
/usr/src/crypto/openssl/ssl/d1_pkt.c:	if (mac_size != 0)
/usr/src/crypto/openssl/ssl/d1_pkt.c:		wr->length+=mac_size;
/usr/src/crypto/openssl/ssl/d1_srvr.c:			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
/usr/src/crypto/openssl/ssl/s2_enc.c:/* read/writes from s->s2->mac_data using length for encrypt and 
/usr/src/crypto/openssl/ssl/s2_enc.c:	EVP_Cipher(ds,s->s2->mac_data,s->s2->mac_data,l);
/usr/src/crypto/openssl/ssl/s2_pkt.c:	unsigned int mac_size;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			mac_size = 0;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			s->s2->mac_data=p;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			mac_size=EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/s2_pkt.c:			OPENSSL_assert(mac_size <= MAX_MAC_SIZE);
/usr/src/crypto/openssl/ssl/s2_pkt.c:			s->s2->mac_data=p;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			s->s2->ract_data= &p[mac_size];
/usr/src/crypto/openssl/ssl/s2_pkt.c:			if (s->s2->padding + mac_size > s->s2->rlength)
/usr/src/crypto/openssl/ssl/s2_pkt.c:			(s->s2->rlength >= mac_size))
/usr/src/crypto/openssl/ssl/s2_pkt.c:			s->s2->ract_data_length-=mac_size;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			if (	(CRYPTO_memcmp(mac,s->s2->mac_data,mac_size) != 0) ||
/usr/src/crypto/openssl/ssl/s2_pkt.c:	unsigned int j,k,olen,p,mac_size,bs;
/usr/src/crypto/openssl/ssl/s2_pkt.c:	/* set mac_size to mac size */
/usr/src/crypto/openssl/ssl/s2_pkt.c:		mac_size=0;
/usr/src/crypto/openssl/ssl/s2_pkt.c:		mac_size=EVP_MD_size(s->write_hash);
/usr/src/crypto/openssl/ssl/s2_pkt.c:		j=len+mac_size;
/usr/src/crypto/openssl/ssl/s2_pkt.c:			len=k-mac_size; 
/usr/src/crypto/openssl/ssl/s2_pkt.c:	/* mac_size is the number of MAC bytes
/usr/src/crypto/openssl/ssl/s2_pkt.c:	s->s2->mac_data= &(s->s2->wbuf[3]);
/usr/src/crypto/openssl/ssl/s2_pkt.c:	s->s2->wact_data= &(s->s2->wbuf[3+mac_size]);
/usr/src/crypto/openssl/ssl/s2_pkt.c:		ssl2_mac(s,s->s2->mac_data,1);
/usr/src/crypto/openssl/ssl/s2_pkt.c:		s->s2->wlength+=p+mac_size;
/usr/src/crypto/openssl/ssl/s2_pkt.c:		pp=s->s2->mac_data;
/usr/src/crypto/openssl/ssl/s2_pkt.c:		pp=s->s2->mac_data;
/usr/src/crypto/openssl/ssl/s3_both.c: * ssl->s3->read_mac_secret		re-init
/usr/src/crypto/openssl/ssl/s3_cbc.c:			    unsigned mac_size)
/usr/src/crypto/openssl/ssl/s3_cbc.c:	const unsigned overhead = 1 /* padding length byte */ + mac_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:			    unsigned mac_size)
/usr/src/crypto/openssl/ssl/s3_cbc.c:				  mac_size +
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned char rotated_mac_buf[EVP_MAX_MD_SIZE*2];
/usr/src/crypto/openssl/ssl/s3_cbc.c:	/* mac_end is the index of |rec->data| just after the end of the MAC. */
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned mac_end = rec->length;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned mac_start = mac_end - md_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	rotated_mac = (unsigned char*) (((intptr_t)(rotated_mac_buf + 64)) & ~63);
/usr/src/crypto/openssl/ssl/s3_cbc.c:	rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:			unsigned char mac_started = constant_time_ge(i, mac_start);
/usr/src/crypto/openssl/ssl/s3_cbc.c:			unsigned char mac_ended = constant_time_ge(i, mac_end);
/usr/src/crypto/openssl/ssl/s3_cbc.c:			rotated_mac[j] |= b & mac_started & ~mac_ended;
/usr/src/crypto/openssl/ssl/s3_cbc.c: *   data_plus_mac_size: the secret, reported length of the data and MAC
/usr/src/crypto/openssl/ssl/s3_cbc.c: *   data_plus_mac_plus_padding_size: the public length of the whole
/usr/src/crypto/openssl/ssl/s3_cbc.c: * functions, above, we know that data_plus_mac_size is large enough to contain
/usr/src/crypto/openssl/ssl/s3_cbc.c:	size_t data_plus_mac_size,
/usr/src/crypto/openssl/ssl/s3_cbc.c:	size_t data_plus_mac_plus_padding_size,
/usr/src/crypto/openssl/ssl/s3_cbc.c:	const unsigned char *mac_secret,
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned mac_secret_length,
/usr/src/crypto/openssl/ssl/s3_cbc.c:		 len, max_mac_bytes, num_blocks,
/usr/src/crypto/openssl/ssl/s3_cbc.c:		 num_starting_blocks, k, mac_end_offset, c, index_a, index_b;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	/* hmac_pad is the masked HMAC key. */
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];
/usr/src/crypto/openssl/ssl/s3_cbc.c:	unsigned char mac_out[EVP_MAX_MD_SIZE];
/usr/src/crypto/openssl/ssl/s3_cbc.c:	OPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);
/usr/src/crypto/openssl/ssl/s3_cbc.c:			mac_secret_length +
/usr/src/crypto/openssl/ssl/s3_cbc.c:	len = data_plus_mac_plus_padding_size + header_length;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including
/usr/src/crypto/openssl/ssl/s3_cbc.c:	max_mac_bytes = len - md_size - 1;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	num_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	/* mac_end_offset is the index just past the end of the data to be
/usr/src/crypto/openssl/ssl/s3_cbc.c:	mac_end_offset = data_plus_mac_size + header_length - md_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	c = mac_end_offset % md_block_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	index_a = mac_end_offset / md_block_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	index_b = (mac_end_offset + md_length_size) / md_block_size;
/usr/src/crypto/openssl/ssl/s3_cbc.c:	bits = 8*mac_end_offset;
/usr/src/crypto/openssl/ssl/s3_cbc.c:		memset(hmac_pad, 0, md_block_size);
/usr/src/crypto/openssl/ssl/s3_cbc.c:		OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));
/usr/src/crypto/openssl/ssl/s3_cbc.c:		memcpy(hmac_pad, mac_secret, mac_secret_length);
/usr/src/crypto/openssl/ssl/s3_cbc.c:			hmac_pad[i] ^= 0x36;
/usr/src/crypto/openssl/ssl/s3_cbc.c:		md_transform(md_state.c, hmac_pad);
/usr/src/crypto/openssl/ssl/s3_cbc.c:	memset(mac_out, 0, sizeof(mac_out));
/usr/src/crypto/openssl/ssl/s3_cbc.c:	 * constant time, to |mac_out|. */
/usr/src/crypto/openssl/ssl/s3_cbc.c:			else if (k < data_plus_mac_plus_padding_size + header_length)
/usr/src/crypto/openssl/ssl/s3_cbc.c:		/* If this is index_b, copy the hash value to |mac_out|. */
/usr/src/crypto/openssl/ssl/s3_cbc.c:			mac_out[j] |= block[j]&is_block_b;
/usr/src/crypto/openssl/ssl/s3_cbc.c:		/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */
/usr/src/crypto/openssl/ssl/s3_cbc.c:		memset(hmac_pad, 0x5c, sslv3_pad_length);
/usr/src/crypto/openssl/ssl/s3_cbc.c:		EVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);
/usr/src/crypto/openssl/ssl/s3_cbc.c:		EVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);
/usr/src/crypto/openssl/ssl/s3_cbc.c:		EVP_DigestUpdate(&md_ctx, mac_out, md_size);
/usr/src/crypto/openssl/ssl/s3_cbc.c:			hmac_pad[i] ^= 0x6a;
/usr/src/crypto/openssl/ssl/s3_cbc.c:		EVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);
/usr/src/crypto/openssl/ssl/s3_cbc.c:		EVP_DigestUpdate(&md_ctx, mac_out, md_size);
/usr/src/crypto/openssl/ssl/s3_enc.c:	unsigned char *p,*mac_secret;
/usr/src/crypto/openssl/ssl/s3_enc.c:		mac_secret= &(s->s3->read_mac_secret[0]);
/usr/src/crypto/openssl/ssl/s3_enc.c:		mac_secret= &(s->s3->write_mac_secret[0]);
/usr/src/crypto/openssl/ssl/s3_enc.c:	memcpy(mac_secret,ms,i);
/usr/src/crypto/openssl/ssl/s3_enc.c:	int bs,i,mac_size=0;
/usr/src/crypto/openssl/ssl/s3_enc.c:			mac_size = EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/s3_enc.c:			return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
/usr/src/crypto/openssl/ssl/s3_enc.c:	unsigned char *mac_sec,*seq;
/usr/src/crypto/openssl/ssl/s3_enc.c:		mac_sec= &(ssl->s3->write_mac_secret[0]);
/usr/src/crypto/openssl/ssl/s3_enc.c:		mac_sec= &(ssl->s3->read_mac_secret[0]);
/usr/src/crypto/openssl/ssl/s3_enc.c:		memcpy(header+j, mac_sec, md_size);
/usr/src/crypto/openssl/ssl/s3_enc.c:			mac_sec, md_size,
/usr/src/crypto/openssl/ssl/s3_enc.c:		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
/usr/src/crypto/openssl/ssl/s3_enc.c:		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
/usr/src/crypto/openssl/ssl/s3_lib.c:			memcpy(ctx->tlsext_tick_hmac_key, keys + 16, 16);
/usr/src/crypto/openssl/ssl/s3_lib.c:			memcpy(keys + 16, ctx->tlsext_tick_hmac_key, 16);
/usr/src/crypto/openssl/ssl/s3_pkt.c:	unsigned mac_size, orig_len;
/usr/src/crypto/openssl/ssl/s3_pkt.c:		/* s->read_hash != NULL => mac_size != -1 */
/usr/src/crypto/openssl/ssl/s3_pkt.c:		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
/usr/src/crypto/openssl/ssl/s3_pkt.c:		mac_size=EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/s3_pkt.c:		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
/usr/src/crypto/openssl/ssl/s3_pkt.c:		if (orig_len < mac_size ||
/usr/src/crypto/openssl/ssl/s3_pkt.c:		     orig_len < mac_size+1))
/usr/src/crypto/openssl/ssl/s3_pkt.c:			mac = mac_tmp;
/usr/src/crypto/openssl/ssl/s3_pkt.c:			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
/usr/src/crypto/openssl/ssl/s3_pkt.c:			rr->length -= mac_size;
/usr/src/crypto/openssl/ssl/s3_pkt.c:			 * enough bytes for |mac_size| above. */
/usr/src/crypto/openssl/ssl/s3_pkt.c:			rr->length -= mac_size;
/usr/src/crypto/openssl/ssl/s3_pkt.c:		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
/usr/src/crypto/openssl/ssl/s3_pkt.c:		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)
/usr/src/crypto/openssl/ssl/s3_pkt.c:	int i,mac_size,clear=0;
/usr/src/crypto/openssl/ssl/s3_pkt.c:		mac_size=0;
/usr/src/crypto/openssl/ssl/s3_pkt.c:		mac_size=EVP_MD_size(s->write_hash);
/usr/src/crypto/openssl/ssl/s3_pkt.c:	if (mac_size != 0)
/usr/src/crypto/openssl/ssl/s3_pkt.c:		wr->length+=mac_size;
/usr/src/crypto/openssl/ssl/s3_srvr.c:			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
/usr/src/crypto/openssl/ssl/ssl_lib.c:	0,	/* finish_mac_length */
/usr/src/crypto/openssl/ssl/ssl_lib.c:		|| (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
/usr/src/crypto/openssl/ssl/t1_enc.c:	unsigned char *p,*mac_secret;
/usr/src/crypto/openssl/ssl/t1_enc.c:		mac_secret= &(s->s3->read_mac_secret[0]);
/usr/src/crypto/openssl/ssl/t1_enc.c:		mac_secret= &(s->s3->write_mac_secret[0]);
/usr/src/crypto/openssl/ssl/t1_enc.c:	memcpy(mac_secret,ms,i);
/usr/src/crypto/openssl/ssl/t1_enc.c:	int bs,i,j,k,pad=0,ret,mac_size=0;
/usr/src/crypto/openssl/ssl/t1_enc.c:			mac_size = EVP_MD_size(s->read_hash);
/usr/src/crypto/openssl/ssl/t1_enc.c:			ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
/usr/src/crypto/openssl/ssl/t1_enc.c:	unsigned char *mac_sec,*seq;
/usr/src/crypto/openssl/ssl/t1_enc.c:		mac_sec= &(ssl->s3->write_mac_secret[0]);
/usr/src/crypto/openssl/ssl/t1_enc.c:		mac_sec= &(ssl->s3->read_mac_secret[0]);
/usr/src/crypto/openssl/ssl/t1_enc.c:	HMAC_Init_ex(&hmac,mac_sec,EVP_MD_size(hash),hash,NULL);
/usr/src/crypto/openssl/ssl/t1_enc.c:			ssl->s3->read_mac_secret,
/usr/src/crypto/openssl/ssl/t1_enc.c:{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }
/usr/src/crypto/openssl/ssl/t1_lib.c:		HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
/usr/src/lib/libc/posix1e/mac.c:mac_destroy_labels(void)
/usr/src/lib/libc/posix1e/mac.c:mac_destroy_internal(void)
/usr/src/lib/libc/posix1e/mac.c:	mac_destroy_labels();
/usr/src/lib/libc/posix1e/mac.c:mac_add_type(const char *name, const char *labels)
/usr/src/lib/libc/posix1e/mac.c:mac_init_internal(int ignore_errors)
/usr/src/lib/libc/posix1e/mac.c:			if (mac_add_type(name, labels) == -1) {
/usr/src/lib/libc/posix1e/mac.c:			if (mac_add_type(type, labels) == -1) {
/usr/src/lib/libc/posix1e/mac.c:		mac_destroy_internal();
/usr/src/lib/libc/posix1e/mac.c:mac_maybe_init_internal(void)
/usr/src/lib/libc/posix1e/mac.c:		return (mac_init_internal(1));
/usr/src/lib/libc/posix1e/mac.c:mac_reload(void)
/usr/src/lib/libc/posix1e/mac.c:		mac_destroy_internal();
/usr/src/lib/libc/posix1e/mac.c:	return (mac_init_internal(0));
/usr/src/lib/libc/posix1e/mac.c:mac_free(struct mac *mac)
/usr/src/lib/libc/posix1e/mac.c:mac_from_text(struct mac **mac, const char *text)
/usr/src/lib/libc/posix1e/mac.c:mac_to_text(struct mac *mac, char **text)
/usr/src/lib/libc/posix1e/mac.c:mac_prepare(struct mac **mac, const char *elements)
/usr/src/lib/libc/posix1e/mac.c:mac_prepare_type(struct mac **mac, const char *name)
/usr/src/lib/libc/posix1e/mac.c:	error = mac_maybe_init_internal();
/usr/src/lib/libc/posix1e/mac.c:			return (mac_prepare(mac, ld->ld_labels));
/usr/src/lib/libc/posix1e/mac.c:mac_prepare_ifnet_label(struct mac **mac)
/usr/src/lib/libc/posix1e/mac.c:	return (mac_prepare_type(mac, "ifnet"));
/usr/src/lib/libc/posix1e/mac.c:mac_prepare_file_label(struct mac **mac)
/usr/src/lib/libc/posix1e/mac.c:	return (mac_prepare_type(mac, "file"));
/usr/src/lib/libc/posix1e/mac.c:mac_prepare_packet_label(struct mac **mac)
/usr/src/lib/libc/posix1e/mac.c:	return (mac_prepare_type(mac, "packet"));
/usr/src/lib/libc/posix1e/mac.c:mac_prepare_process_label(struct mac **mac)
/usr/src/lib/libc/posix1e/mac.c:	return (mac_prepare_type(mac, "process"));
/usr/src/lib/libc/posix1e/mac.c:mac_is_present(const char *policyname)
/usr/src/lib/libc/posix1e/mac_exec.c:__FBSDID("$FreeBSD: stable/9/lib/libc/posix1e/mac_exec.c 176901 2008-03-07 15:25:56Z rwatson $");
/usr/src/lib/libc/posix1e/mac_exec.c:extern int __mac_execve(char *fname, char **argv, char **envv,
/usr/src/lib/libc/posix1e/mac_exec.c:    struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_exec.c:mac_execve(char *fname, char **argv, char **envv, struct mac *label)
/usr/src/lib/libc/posix1e/mac_exec.c:	return (__mac_execve(fname, argv, envv, label));
/usr/src/lib/libc/posix1e/mac_get.c:__FBSDID("$FreeBSD: stable/9/lib/libc/posix1e/mac_get.c 176901 2008-03-07 15:25:56Z rwatson $");
/usr/src/lib/libc/posix1e/mac_get.c:extern int __mac_get_fd(int fd, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_get.c:extern int __mac_get_file(const char *path_p, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_get.c:extern int __mac_get_link(const char *path_p, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_get.c:extern int __mac_get_pid(pid_t pid, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_get.c:extern int __mac_get_proc(struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_fd(int fd, struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:	return (__mac_get_fd(fd, label));
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_file(const char *path, struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:	return (__mac_get_file(path, label));
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_link(const char *path, struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:	return (__mac_get_link(path, label));
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_peer(int fd, struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_pid(pid_t pid, struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:	return (__mac_get_pid(pid, label));
/usr/src/lib/libc/posix1e/mac_get.c:mac_get_proc(struct mac *label)
/usr/src/lib/libc/posix1e/mac_get.c:	return (__mac_get_proc(label));
/usr/src/lib/libc/posix1e/mac_set.c:__FBSDID("$FreeBSD: stable/9/lib/libc/posix1e/mac_set.c 176901 2008-03-07 15:25:56Z rwatson $");
/usr/src/lib/libc/posix1e/mac_set.c:extern	int	__mac_set_fd(int fd, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_set.c:extern	int	__mac_set_file(const char *path_p, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_set.c:extern	int	__mac_set_link(const char *path_p, struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_set.c:extern	int	__mac_set_proc(struct mac *mac_p);
/usr/src/lib/libc/posix1e/mac_set.c:mac_set_fd(int fd, struct mac *label)
/usr/src/lib/libc/posix1e/mac_set.c:	return (__mac_set_fd(fd, label));
/usr/src/lib/libc/posix1e/mac_set.c:mac_set_file(const char *path, struct mac *label)
/usr/src/lib/libc/posix1e/mac_set.c:	return (__mac_set_file(path, label));
/usr/src/lib/libc/posix1e/mac_set.c:mac_set_link(const char *path, struct mac *label)
/usr/src/lib/libc/posix1e/mac_set.c:	return (__mac_set_link(path, label));
/usr/src/lib/libc/posix1e/mac_set.c:mac_set_proc(struct mac *label)
/usr/src/lib/libc/posix1e/mac_set.c:	return (__mac_set_proc(label));
/usr/src/lib/libcompat/4.3/rexec.c:	char mac_name[9];	/* macro name */
/usr/src/lib/libcompat/4.3/rexec.c:	char *mac_start;	/* start of macro in macbuf */
/usr/src/lib/libcompat/4.3/rexec.c:	char *mac_end;		/* end of macro in macbuf */
/usr/src/lib/libcompat/4.3/rexec.c:			tmp = macros[macnum].mac_name;
/usr/src/lib/libcompat/4.3/rexec.c:				macros[macnum].mac_start = macbuf;
/usr/src/lib/libcompat/4.3/rexec.c:				macros[macnum].mac_start = macros[macnum-1].mac_end + 1;
/usr/src/lib/libcompat/4.3/rexec.c:			tmp = macros[macnum].mac_start;
/usr/src/lib/libcompat/4.3/rexec.c:					   macros[macnum++].mac_end = tmp - 1;
/usr/src/lib/libugidfw/ugidfw.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/lib/libugidfw/ugidfw.c:bsde_rule_to_string(struct mac_bsdextended_rule *rule, char *buf, size_t buflen)
/usr/src/lib/libugidfw/ugidfw.c:    struct mac_bsdextended_subject *subject, size_t buflen, char *errstr)
/usr/src/lib/libugidfw/ugidfw.c:    struct mac_bsdextended_object *object, size_t buflen, char *errstr)
/usr/src/lib/libugidfw/ugidfw.c:bsde_parse_rule(int argc, char *argv[], struct mac_bsdextended_rule *rule,
/usr/src/lib/libugidfw/ugidfw.c:bsde_parse_rule_string(const char *string, struct mac_bsdextended_rule *rule,
/usr/src/lib/libugidfw/ugidfw.c:bsde_get_rule(int rulenum, struct mac_bsdextended_rule *rule, size_t errlen,
/usr/src/lib/libugidfw/ugidfw.c:	struct mac_bsdextended_rule rule;
/usr/src/lib/libugidfw/ugidfw.c:bsde_set_rule(int rulenum, struct mac_bsdextended_rule *rule, size_t buflen,
/usr/src/lib/libugidfw/ugidfw.c:bsde_add_rule(int *rulenum, struct mac_bsdextended_rule *rule, size_t buflen,
/usr/src/lib/libutil/login_class.c:    if ((flags & LOGIN_SETMAC) && mac_is_present(NULL) == 1) {
/usr/src/lib/libutil/login_class.c:	mac_t label;
/usr/src/lib/libutil/login_class.c:	    if (mac_from_text(&label, label_string) == -1) {
/usr/src/lib/libutil/login_class.c:		syslog(LOG_ERR, "mac_from_text('%s') for %s: %m",
/usr/src/lib/libutil/login_class.c:	    if (mac_set_proc(label) == -1)
/usr/src/lib/libutil/login_class.c:	    mac_free(label);
/usr/src/lib/libutil/login_class.c:		syslog(LOG_ERR, "mac_set_proc('%s') for %s: %s",
/usr/src/sbin/geom/class/eli/geom_eli.c:    struct hmac_ctx *ctxp, char *passbuf, size_t passbufsize)
/usr/src/sbin/geom/class/eli/geom_eli.c:				g_eli_crypto_hmac_update(ctxp, buf, done);
/usr/src/sbin/geom/class/eli/geom_eli.c:    struct hmac_ctx *ctxp)
/usr/src/sbin/geom/class/eli/geom_eli.c:		g_eli_crypto_hmac_update(ctxp, md->md_salt,
/usr/src/sbin/geom/class/eli/geom_eli.c:		g_eli_crypto_hmac_update(ctxp, passbuf, strlen(passbuf));
/usr/src/sbin/geom/class/eli/geom_eli.c:		g_eli_crypto_hmac_update(ctxp, dkey, sizeof(dkey));
/usr/src/sbin/geom/class/eli/geom_eli.c:	struct hmac_ctx ctx;
/usr/src/sbin/geom/class/eli/geom_eli.c:	g_eli_crypto_hmac_init(&ctx, NULL, 0);
/usr/src/sbin/geom/class/eli/geom_eli.c:	g_eli_crypto_hmac_final(&ctx, key, 0);
/usr/src/sbin/ifconfig/ifmac.c:	mac_t label;
/usr/src/sbin/ifconfig/ifmac.c:	if (mac_prepare_ifnet_label(&label) == -1)
/usr/src/sbin/ifconfig/ifmac.c:		goto mac_free;
/usr/src/sbin/ifconfig/ifmac.c:	if (mac_to_text(label, &label_text) == -1)
/usr/src/sbin/ifconfig/ifmac.c:		goto mac_free;
/usr/src/sbin/ifconfig/ifmac.c:mac_free:
/usr/src/sbin/ifconfig/ifmac.c:	mac_free(label);
/usr/src/sbin/ifconfig/ifmac.c:	mac_t label;
/usr/src/sbin/ifconfig/ifmac.c:	if (mac_from_text(&label, val) == -1) {
/usr/src/sbin/ifconfig/ifmac.c:	mac_free(label);
/usr/src/sbin/ifconfig/ifmac.c:static struct cmd mac_cmds[] = {
/usr/src/sbin/ifconfig/ifmac.c:mac_ctor(void)
/usr/src/sbin/ifconfig/ifmac.c:	for (i = 0; i < N(mac_cmds);  i++)
/usr/src/sbin/ifconfig/ifmac.c:		cmd_register(&mac_cmds[i]);
/usr/src/sbin/ipfw/ipfw2.c:get_mac_addr_mask(const char *p, uint8_t *addr, uint8_t *mask)
/usr/src/sbin/ipfw/ipfw2.c:	get_mac_addr_mask(av[0], mac->addr, mac->mask);	/* dst */
/usr/src/sbin/ipfw/ipfw2.c:	get_mac_addr_mask(av[1], &(mac->addr[ETHER_ADDR_LEN]),
/usr/src/sys/arm/at91/if_ate.c:ate_mac_hash(const uint8_t *buf)
/usr/src/sys/arm/at91/if_ate.c:		index = ate_mac_hash(LLADDR((struct sockaddr_dl *)
/usr/src/sys/arm/at91/if_macb.c:set_mac_filter(uint32_t *filter, uint8_t *mac)
/usr/src/sys/arm/at91/if_macb.c:		set_mac_filter(multicast_filter, 
/usr/src/sys/arm/econa/if_ece.c:static void	clear_mac_entries(struct ece_softc *ec, int include_this_mac);
/usr/src/sys/arm/econa/if_ece.c:static uint32_t read_mac_entry(struct ece_softc *ec,
/usr/src/sys/arm/econa/if_ece.c:	    uint8_t *mac_result,
/usr/src/sys/arm/econa/if_ece.c:	uint32_t mac_port_config;
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_0_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config |= (PORT_DISABLE);
/usr/src/sys/arm/econa/if_ece.c:	write_4(sc, MAC_PORT_0_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_1_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config |= (PORT_DISABLE);
/usr/src/sys/arm/econa/if_ece.c:	write_4(sc, MAC_PORT_1_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:read_mac_entry(struct ece_softc *ec,
/usr/src/sys/arm/econa/if_ece.c:    uint8_t *mac_result,
/usr/src/sys/arm/econa/if_ece.c:	if (mac_result)
/usr/src/sys/arm/econa/if_ece.c:		memcpy(mac_result, entry.mac_addr, ETHER_ADDR_LEN);
/usr/src/sys/arm/econa/if_ece.c:    const uint8_t *mac_addr)
/usr/src/sys/arm/econa/if_ece.c:	memcpy(entry.mac_addr, mac_addr, ETHER_ADDR_LEN);
/usr/src/sys/arm/econa/if_ece.c:remove_mac_entry(struct ece_softc *sc,
/usr/src/sys/arm/econa/if_ece.c:add_mac_entry(struct ece_softc *sc,
/usr/src/sys/arm/econa/if_ece.c:clear_mac_entries(struct ece_softc *ec, int include_this_mac)
/usr/src/sys/arm/econa/if_ece.c:	struct mac_list * temp;
/usr/src/sys/arm/econa/if_ece.c:	struct mac_list * mac_list_header;
/usr/src/sys/arm/econa/if_ece.c:	struct mac_list * current;
/usr/src/sys/arm/econa/if_ece.c:	mac_list_header = 0;
/usr/src/sys/arm/econa/if_ece.c:	table_end = read_mac_entry(ec, mac, 1);
/usr/src/sys/arm/econa/if_ece.c:			table_end = read_mac_entry(ec, mac, 0);
/usr/src/sys/arm/econa/if_ece.c:		temp = (struct mac_list*)malloc(sizeof(struct mac_list),
/usr/src/sys/arm/econa/if_ece.c:		memcpy(temp->mac_addr, mac, ETHER_ADDR_LEN);
/usr/src/sys/arm/econa/if_ece.c:		if (mac_list_header) {
/usr/src/sys/arm/econa/if_ece.c:			mac_list_header = temp;
/usr/src/sys/arm/econa/if_ece.c:		table_end = read_mac_entry(ec, mac, 0);
/usr/src/sys/arm/econa/if_ece.c:	current = mac_list_header;
/usr/src/sys/arm/econa/if_ece.c:		remove_mac_entry(ec, current->mac_addr);
/usr/src/sys/arm/econa/if_ece.c:	uint32_t mac_port_config;
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_0_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	if (!(mac_port_config & 0x1) || (mac_port_config & 0x2))
/usr/src/sys/arm/econa/if_ece.c:		write_4(sc, MAC_PORT_0_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:set_mac_address(struct ece_softc *sc, const char *mac, int mac_len)
/usr/src/sys/arm/econa/if_ece.c:	set_mac_address(sc, eaddr, ETHER_ADDR_LEN);
/usr/src/sys/arm/econa/if_ece.c:	uint32_t mac_port_config;
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_0_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config &= (~(PORT_DISABLE));
/usr/src/sys/arm/econa/if_ece.c:	write_4(sc, MAC_PORT_0_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:	uint32_t mac_port_config;
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_0_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config |= (PORT_DISABLE);
/usr/src/sys/arm/econa/if_ece.c:	write_4(sc, MAC_PORT_0_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config = read_4(sc, MAC_PORT_1_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:	mac_port_config |= (PORT_DISABLE);
/usr/src/sys/arm/econa/if_ece.c:	write_4(sc, MAC_PORT_1_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:	clear_mac_entries(sc, 1);
/usr/src/sys/arm/econa/if_ece.c:	uint32_t mac_port_config;
/usr/src/sys/arm/econa/if_ece.c:	clear_mac_entries(sc, 0);
/usr/src/sys/arm/econa/if_ece.c:		mac_port_config = read_4(sc, MAC_PORT_0_CONFIG);
/usr/src/sys/arm/econa/if_ece.c:		mac_port_config &= ~(DISABLE_BROADCAST_PACKET);
/usr/src/sys/arm/econa/if_ece.c:		mac_port_config &= ~(DISABLE_MULTICAST_PACKET);
/usr/src/sys/arm/econa/if_ece.c:		write_4(sc, MAC_PORT_0_CONFIG, mac_port_config);
/usr/src/sys/arm/econa/if_ece.c:		add_mac_entry(sc,
/usr/src/sys/arm/xscale/ixp425/if_npe.c:npe_mac_reset(struct npe_softc *sc)
/usr/src/sys/arm/xscale/ixp425/if_npe.c:	npe_mac_reset(sc);
/usr/src/sys/boot/arm/at91/libat91/emac_init.c: * $FreeBSD: stable/9/sys/boot/arm/at91/libat91/emac_init.c 172952 2007-10-25 07:05:38Z imp $
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#384",			/* 384 = __mac_get_proc */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#385",			/* 385 = __mac_set_proc */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#386",			/* 386 = __mac_get_fd */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#387",			/* 387 = __mac_get_file */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#388",			/* 388 = __mac_set_fd */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#389",			/* 389 = __mac_set_file */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#394",			/* 394 = mac_syscall */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#409",			/* 409 = __mac_get_pid */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#410",			/* 410 = __mac_get_link */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#411",			/* 411 = __mac_set_link */
/usr/src/sys/compat/freebsd32/freebsd32_syscalls.c:	"#415",			/* 415 = __mac_execve */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 384 = __mac_get_proc */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 385 = __mac_set_proc */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 386 = __mac_get_fd */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 387 = __mac_get_file */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 388 = __mac_set_fd */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 389 = __mac_set_file */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 394 = mac_syscall */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 409 = __mac_get_pid */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 410 = __mac_get_link */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 411 = __mac_set_link */
/usr/src/sys/compat/freebsd32/freebsd32_sysent.c:	{ 0, (sy_call_t *)nosys, AUE_NULL, NULL, 0, 0, 0, SY_THR_ABSENT },			/* 415 = __mac_execve */
/usr/src/sys/compat/linux/linux_file.c:#include <security/mac/mac_framework.h>
/usr/src/sys/compat/linux/linux_file.c:	if ((error = mac_vnode_check_readdir(td->td_ucred, vp)))
/usr/src/sys/compat/linux/linux_getcwd.c:#include <security/mac/mac_framework.h>
/usr/src/sys/compat/linux/linux_getcwd.c:	error = mac_vnode_check_lookup(td->td_ucred, lvp, &cn);
/usr/src/sys/compat/linux/linux_getcwd.c:	  mac_vnode_post_lookup(td->td_ucred, lvp, &cn, *uvpp);
/usr/src/sys/compat/linux/linux_getcwd.c:		error = mac_vnode_check_readdir(td->td_ucred, uvp);
/usr/src/sys/compat/linux/linux_misc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/compat/linux/linux_misc.c:	error = mac_vnode_check_open(td->td_ucred, vp, VREAD);
/usr/src/sys/compat/svr4/svr4_fcntl.c:#include <security/mac/mac_framework.h>
/usr/src/sys/compat/svr4/svr4_fcntl.c:	error = mac_vnode_check_revoke(td->td_ucred, vp);
/usr/src/sys/compat/svr4/svr4_misc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/compat/svr4/svr4_misc.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/compat/svr4/svr4_misc.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/compat/svr4/svr4_misc.c:	error = mac_vnode_check_chroot(td->td_ucred, vp);
/usr/src/sys/contrib/octeon-sdk/cvmx-app-init.c:        memcpy(sys_info_ptr->mac_addr_base, cvmx_bootinfo_ptr->mac_addr_base, 6);
/usr/src/sys/contrib/octeon-sdk/cvmx-app-init.c:        sys_info_ptr->mac_addr_count = cvmx_bootinfo_ptr->mac_addr_count;
/usr/src/sys/contrib/octeon-sdk/cvmx-csr-db.c:	{"cvmx_sli_mac_credit_cnt"     ,	CVMX_CSR_DB_TYPE_PEXP_NCB,	64,	6696,	7,	5044},
/usr/src/sys/contrib/octeon-sdk/cvmx-csr-db.c:	{"cvmx_sli_mac_credit_cnt"     ,	CVMX_CSR_DB_TYPE_PEXP_NCB,	64,	6712,	13,	5185},
/usr/src/sys/contrib/octeon-sdk/cvmx-csr-db.c:	{"cvmx_sli_mac_number"         ,	CVMX_CSR_DB_TYPE_PEXP,	64,	6713,	2,	5198},
/usr/src/sys/contrib/octeon-sdk/cvmx-csr-db.c:	{"cvmx_srio#_mac_buffers"      ,	CVMX_CSR_DB_TYPE_RSL,	64,	7303,	10,	5635},
/usr/src/sys/contrib/octeon-sdk/cvmx-csr-db.c:	{"cvmx_sriomaint#_mac_ctrl"    ,	CVMX_CSR_DB_TYPE_SRIOMAINT,	32,	7535,	5,	6067},
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c: *     cvmx_srio0_int_reg [label="SRIOX_INT_REG(0)|<bar_err>bar_err|<deny_wr>deny_wr|<sli_err>sli_err|<mce_rx>mce_rx|<log_erb>log_erb|<phy_erb>phy_erb|<omsg_err>omsg_err|<pko_err>pko_err|<rtry_err>rtry_err|<f_error>f_error|<mac_buf>mac_buf|<degrad>degrad|<fail>fail|<ttl_tout>ttl_tout"];
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c: *     cvmx_srio1_int_reg [label="SRIOX_INT_REG(1)|<bar_err>bar_err|<deny_wr>deny_wr|<sli_err>sli_err|<mce_rx>mce_rx|<log_erb>log_erb|<phy_erb>phy_erb|<omsg_err>omsg_err|<pko_err>pko_err|<rtry_err>rtry_err|<f_error>f_error|<mac_buf>mac_buf|<degrad>degrad|<fail>fail|<ttl_tout>ttl_tout"];
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c:    info.status_mask        = 1ull<<22 /* mac_buf */;
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c:    info.enable_mask        = 1ull<<22 /* mac_buf */;
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c:    info.status_mask        = 1ull<<22 /* mac_buf */;
/usr/src/sys/contrib/octeon-sdk/cvmx-error-init-cn63xx.c:    info.enable_mask        = 1ull<<22 /* mac_buf */;
/usr/src/sys/contrib/octeon-sdk/cvmx-helper-sgmii.c:        if (pcsx_miscx_ctl_reg.s.mac_phy)
/usr/src/sys/contrib/octeon-sdk/cvmx-helper-sgmii.c:        if (pcsx_miscx_ctl_reg.s.mac_phy)
/usr/src/sys/contrib/octeon-sdk/cvmx-sysinfo.c:            else if (strcmp(field, "mac_addr_base:") == 0)
/usr/src/sys/contrib/octeon-sdk/cvmx-sysinfo.c:                    system_info->mac_addr_base[i] = m[i];
/usr/src/sys/contrib/octeon-sdk/cvmx-sysinfo.c:            else if (strcmp(field, "mac_addr_count:") == 0)
/usr/src/sys/contrib/octeon-sdk/cvmx-sysinfo.c:                system_info->mac_addr_count = value;
/usr/src/sys/contrib/pf/net/pf.c:#include <security/mac/mac_framework.h>
/usr/src/sys/contrib/pf/net/pf.c:	mac_netinet_firewall_send(m);
/usr/src/sys/crypto/via/padlock_hash.c:#include <opencrypto/cryptosoft.h> /* for hmac_ipad_buffer and hmac_opad_buffer */
/usr/src/sys/crypto/via/padlock_hash.c:static struct auth_hash padlock_hmac_sha1 = {
/usr/src/sys/crypto/via/padlock_hash.c:static struct auth_hash padlock_hmac_sha256 = {
/usr/src/sys/crypto/via/padlock_hash.c:	axf->Update(ses->ses_ictx, hmac_ipad_buffer, axf->blocksize - klen);
/usr/src/sys/crypto/via/padlock_hash.c:	axf->Update(ses->ses_octx, hmac_opad_buffer, axf->blocksize - klen);
/usr/src/sys/crypto/via/padlock_hash.c:		ses->ses_axf = &auth_hash_hmac_md5;
/usr/src/sys/crypto/via/padlock_hash.c:			ses->ses_axf = &padlock_hmac_sha1;
/usr/src/sys/crypto/via/padlock_hash.c:			ses->ses_axf = &auth_hash_hmac_sha1;
/usr/src/sys/crypto/via/padlock_hash.c:		ses->ses_axf = &auth_hash_hmac_ripemd_160;
/usr/src/sys/crypto/via/padlock_hash.c:			ses->ses_axf = &padlock_hmac_sha256;
/usr/src/sys/crypto/via/padlock_hash.c:			ses->ses_axf = &auth_hash_hmac_sha2_256;
/usr/src/sys/crypto/via/padlock_hash.c:		ses->ses_axf = &auth_hash_hmac_sha2_384;
/usr/src/sys/crypto/via/padlock_hash.c:		ses->ses_axf = &auth_hash_hmac_sha2_512;
/usr/src/sys/dev/ae/if_ae.c:static void	ae_mac_config(ae_softc_t *sc);
/usr/src/sys/dev/ae/if_ae.c:		ae_mac_config(sc);
/usr/src/sys/dev/ae/if_ae.c:ae_mac_config(ae_softc_t *sc)
/usr/src/sys/dev/age/if_age.c:static void age_mac_config(struct age_softc *);
/usr/src/sys/dev/age/if_age.c:						age_mac_config(sc);
/usr/src/sys/dev/age/if_age.c:		age_mac_config(sc);
/usr/src/sys/dev/age/if_age.c:age_mac_config(struct age_softc *sc)
/usr/src/sys/dev/age/if_age.c:		age_mac_config(sc);
/usr/src/sys/dev/alc/if_alc.c:static void	alc_mac_config(struct alc_softc *);
/usr/src/sys/dev/alc/if_alc.c:		alc_mac_config(sc);
/usr/src/sys/dev/alc/if_alc.c:					alc_mac_config(sc);
/usr/src/sys/dev/alc/if_alc.c:	alc_mac_config(sc);
/usr/src/sys/dev/alc/if_alc.c:alc_mac_config(struct alc_softc *sc)
/usr/src/sys/dev/ale/if_ale.c:static void	ale_mac_config(struct ale_softc *);
/usr/src/sys/dev/ale/if_ale.c:		ale_mac_config(sc);
/usr/src/sys/dev/ale/if_ale.c:					ale_mac_config(sc);
/usr/src/sys/dev/ale/if_ale.c:	ale_mac_config(sc);
/usr/src/sys/dev/ale/if_ale.c:ale_mac_config(struct ale_softc *sc)
/usr/src/sys/dev/ath/ath_hal/ah.c:ath_hal_mac_name(struct ath_hal *ah)
/usr/src/sys/dev/ath/ath_hal/ah.c:ath_hal_mac_clks(struct ath_hal *ah, u_int usecs)
/usr/src/sys/dev/ath/ath_hal/ah.c:ath_hal_mac_usec(struct ath_hal *ah, u_int clks)
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	if (us > ath_hal_mac_usec(ah, 0x7ff)) {
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:		    ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	if (us < HAL_SLOT_TIME_9 || us > ath_hal_mac_usec(ah, 0xffff)) {
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:		OS_REG_WRITE(ah, AR_SLOT_TIME, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_ACK))) {
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:			AR_TIME_OUT_ACK, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_CTS))) {
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:			AR_TIME_OUT_CTS, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5210/ar5210_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	if (us > ath_hal_mac_usec(ah, 0xffff)) {
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:		OS_REG_WRITE(ah, AR_D_GBL_IFS_SIFS, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	if (us < HAL_SLOT_TIME_9 || us > ath_hal_mac_usec(ah, 0xffff)) {
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:		OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_ACK))) {
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:			AR_TIME_OUT_ACK, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_CTS))) {
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:			AR_TIME_OUT_CTS, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5211/ar5211_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_ani.c:#define CLOCK_RATE 44000	/* XXX use mac_usec or similar */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	if (us > ath_hal_mac_usec(ah, 0xffff)) {
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:		OS_REG_WRITE(ah, AR_D_GBL_IFS_SIFS, ath_hal_mac_clks(ah, us-2));
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	return ath_hal_mac_usec(ah, clks)+2;	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	if (us < HAL_SLOT_TIME_6 || us > ath_hal_mac_usec(ah, 0xffff)) {
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:		OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_ACK))) {
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:			AR_TIME_OUT_ACK, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	if (us > ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_CTS))) {
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:			AR_TIME_OUT_CTS, ath_hal_mac_clks(ah, us));
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */
/usr/src/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c:		clkRate = ath_hal_mac_clks(ah, 1);
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_ani.c:#define CLOCK_RATE 44000	/* XXX use mac_usec or similar */
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:} mac_dbg_regs_t;
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:} hal_mac_hangs_t;
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:} hal_mac_hang_check_t;
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:ar5416CompareDbgHang(struct ath_hal *ah, const mac_dbg_regs_t *regs,
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:    const hal_mac_hang_check_t *check)
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	static const hal_mac_hang_check_t hang_sig1 = {
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	static const hal_mac_hang_check_t hang_sig2 = {
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	mac_dbg_regs_t mac_dbg;
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	mac_dbg.dma_dbg_3 = OS_REG_READ(ah, AR_DMADBG_3);
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	mac_dbg.dma_dbg_4 = OS_REG_READ(ah, AR_DMADBG_4);
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	mac_dbg.dma_dbg_5 = OS_REG_READ(ah, AR_DMADBG_5);
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	mac_dbg.dma_dbg_6 = OS_REG_READ(ah, AR_DMADBG_6);
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:		if (mac_dbg.dma_dbg_3 != OS_REG_READ(ah, AR_DMADBG_3) ||
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:		    mac_dbg.dma_dbg_4 != OS_REG_READ(ah, AR_DMADBG_4) ||
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:		    mac_dbg.dma_dbg_5 != OS_REG_READ(ah, AR_DMADBG_5) ||
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:		    mac_dbg.dma_dbg_6 != OS_REG_READ(ah, AR_DMADBG_6))
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	if (ar5416CompareDbgHang(ah, &mac_dbg, &hang_sig1))
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	if (ar5416CompareDbgHang(ah, &mac_dbg, &hang_sig2))
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	    __func__, mac_dbg.dma_dbg_3, mac_dbg.dma_dbg_4, mac_dbg.dma_dbg_5,
/usr/src/sys/dev/ath/ath_hal/ar5416/ar5416_misc.c:	    mac_dbg.dma_dbg_6);
/usr/src/sys/dev/ath/if_ath.c:		ath_hal_mac_name(ah), ah->ah_macVersion, ah->ah_macRev,
/usr/src/sys/dev/bce/if_bce.c:static void bce_get_mac_addr		(struct bce_softc *);
/usr/src/sys/dev/bce/if_bce.c:static void bce_set_mac_addr		(struct bce_softc *);
/usr/src/sys/dev/bce/if_bce.c:	bce_get_mac_addr(sc);
/usr/src/sys/dev/bce/if_bce.c:bce_get_mac_addr(struct bce_softc *sc)
/usr/src/sys/dev/bce/if_bce.c:	u32 mac_lo = 0, mac_hi = 0;
/usr/src/sys/dev/bce/if_bce.c:	mac_hi = bce_shmem_rd(sc, BCE_PORT_HW_CFG_MAC_UPPER);
/usr/src/sys/dev/bce/if_bce.c:	mac_lo = bce_shmem_rd(sc, BCE_PORT_HW_CFG_MAC_LOWER);
/usr/src/sys/dev/bce/if_bce.c:	if ((mac_lo == 0) && (mac_hi == 0)) {
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[0] = (u_char)(mac_hi >> 8);
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[1] = (u_char)(mac_hi >> 0);
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[2] = (u_char)(mac_lo >> 24);
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[3] = (u_char)(mac_lo >> 16);
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[4] = (u_char)(mac_lo >> 8);
/usr/src/sys/dev/bce/if_bce.c:		sc->eaddr[5] = (u_char)(mac_lo >> 0);
/usr/src/sys/dev/bce/if_bce.c:bce_set_mac_addr(struct bce_softc *sc)
/usr/src/sys/dev/bce/if_bce.c:	u8 *mac_addr = sc->eaddr;
/usr/src/sys/dev/bce/if_bce.c:	val = (mac_addr[0] << 8) | mac_addr[1];
/usr/src/sys/dev/bce/if_bce.c:	val = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
/usr/src/sys/dev/bce/if_bce.c:	    (mac_addr[4] << 8) | mac_addr[5];
/usr/src/sys/dev/bce/if_bce.c:	u32 emac_mode_save, val;
/usr/src/sys/dev/bce/if_bce.c:	static const u32 emac_mode_mask = BCE_EMAC_MODE_PORT |
/usr/src/sys/dev/bce/if_bce.c:	emac_mode_save = REG_RD(sc, BCE_EMAC_MODE) & emac_mode_mask;
/usr/src/sys/dev/bce/if_bce.c:	val = (val & ~emac_mode_mask) | emac_mode_save;
/usr/src/sys/dev/bce/if_bce.c:	bce_set_mac_addr(sc);
/usr/src/sys/dev/bce/if_bce.c:	bce_set_mac_addr(sc);
/usr/src/sys/dev/bce/if_bce.c:	sc->stat_emac_tx_stat_dot3statsinternalmactransmiterrors =
/usr/src/sys/dev/bce/if_bce.c:	    stats->stat_emac_tx_stat_dot3statsinternalmactransmiterrors;
/usr/src/sys/dev/bce/if_bce.c:	    (u_long) sc->stat_emac_tx_stat_dot3statsinternalmactransmiterrors +
/usr/src/sys/dev/bce/if_bce.c:	    "stat_emac_tx_stat_dot3statsinternalmactransmiterrors",
/usr/src/sys/dev/bce/if_bce.c:	    CTLFLAG_RD, &sc->stat_emac_tx_stat_dot3statsinternalmactransmiterrors,
/usr/src/sys/dev/bce/if_bce.c:	    stat_emac_tx_stat_dot3statsinternalmactransmiterrors);
/usr/src/sys/dev/bce/if_bce.c:	BCE_PRINTF("0x%08X - (0x%06X) emac_status\n",
/usr/src/sys/dev/bge/if_bge.c:	uint32_t mac_mode, rx_mode, tx_mode;
/usr/src/sys/dev/bge/if_bge.c:	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) &
/usr/src/sys/dev/bge/if_bge.c:		mac_mode |= BGE_PORTMODE_GMII;
/usr/src/sys/dev/bge/if_bge.c:		mac_mode |= BGE_PORTMODE_MII;
/usr/src/sys/dev/bge/if_bge.c:		mac_mode |= BGE_MACMODE_HALF_DUPLEX;
/usr/src/sys/dev/bge/if_bge.c:	CSR_WRITE_4(sc, BGE_MAC_MODE, mac_mode);
/usr/src/sys/dev/bge/if_bge.c:	uint32_t cachesize, command, mac_mode, mac_mode_mask, reset, val;
/usr/src/sys/dev/bge/if_bge.c:	mac_mode_mask = BGE_MACMODE_HALF_DUPLEX | BGE_MACMODE_PORTMODE;
/usr/src/sys/dev/bge/if_bge.c:		mac_mode_mask |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;
/usr/src/sys/dev/bge/if_bge.c:	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) & mac_mode_mask;
/usr/src/sys/dev/bge/if_bge.c:	val = (val & ~mac_mode_mask) | mac_mode;
/usr/src/sys/dev/bge/if_bge.c:	struct bge_mac_stats *stats;
/usr/src/sys/dev/bge/if_bge.c:	stats = &sc->bge_mac_stats;
/usr/src/sys/dev/bge/if_bge.c:	struct bge_mac_stats *stats;
/usr/src/sys/dev/bge/if_bge.c:	stats = &sc->bge_mac_stats;
/usr/src/sys/dev/bge/if_bge.c:	uint32_t mac_addr;
/usr/src/sys/dev/bge/if_bge.c:	mac_addr = bge_readmem_ind(sc, BGE_SRAM_MAC_ADDR_HIGH_MB);
/usr/src/sys/dev/bge/if_bge.c:	if ((mac_addr >> 16) == 0x484b) {
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[0] = (uint8_t)(mac_addr >> 8);
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[1] = (uint8_t)mac_addr;
/usr/src/sys/dev/bge/if_bge.c:		mac_addr = bge_readmem_ind(sc, BGE_SRAM_MAC_ADDR_LOW_MB);
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[2] = (uint8_t)(mac_addr >> 24);
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[3] = (uint8_t)(mac_addr >> 16);
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[4] = (uint8_t)(mac_addr >> 8);
/usr/src/sys/dev/bge/if_bge.c:		ether_addr[5] = (uint8_t)mac_addr;
/usr/src/sys/dev/bge/if_bge.c:	int mac_offset = BGE_EE_MAC_OFFSET;
/usr/src/sys/dev/bge/if_bge.c:		mac_offset = BGE_EE_MAC_OFFSET_5906;
/usr/src/sys/dev/bge/if_bge.c:	return (bge_read_nvram(sc, ether_addr, mac_offset + 2,
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_test(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_get_property(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_set_retry_lim(struct bwi_mac *,
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_set_ackrates(struct bwi_mac *,
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_gpio_init(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_gpio_fini(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_opmode_init(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_hostflags_init(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_bss_param_init(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_fw_alloc(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_fw_free(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_fw_load(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_fw_init(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static int	bwi_mac_fw_load_iv(struct bwi_mac *, const struct firmware *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_setup_tpctl(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_adjust_tpctl(struct bwi_mac *, int, int);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_lock(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:static void	bwi_mac_unlock(struct bwi_mac *);
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_flags & BWI_MAC_F_BSWAP)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_lateattach(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev >= 5)
/usr/src/sys/dev/bwi/bwimac.c:		CSR_READ_4(mac->mac_sc, BWI_STATE_HI); /* dummy read */
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_reset(mac, 1);
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A)
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_reset(mac, 0);
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_reset(mac, 1);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_test(mac);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_get_property(mac);
/usr/src/sys/dev/bwi/bwimac.c:	CSR_WRITE_2(mac->mac_sc, BWI_BBP_ATTEN, BWI_BBP_ATTEN_MAGIC);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_regwin_disable(mac->mac_sc, &mac->mac_regwin, 0);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_setup_tpctl(mac);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_rf_clear_state(&mac->mac_rf);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_phy_clear_state(&mac->mac_phy);
/usr/src/sys/dev/bwi/bwimac.c:	if (!bwi_regwin_is_enabled(sc, &mac->mac_regwin))
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_reset(mac, 1);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_fw_alloc(mac);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_fw_load(mac);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_gpio_init(mac);
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_fw_init(mac);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_rf_set_ant_mode(mac, mac->mac_rf.rf_ant_mode);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_opmode_init(mac);
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 3) {
/usr/src/sys/dev/bwi/bwimac.c:	MOBJ_WRITE_2(mac, BWI_COMM_MOBJ, BWI_COMM_MOBJ_MACREV, mac->mac_rev);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_hostflags_init(mac);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_bss_param_init(mac);
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_flags & BWI_MAC_F_HAS_TXSTATS) {
/usr/src/sys/dev/bwi/bwimac.c:	mac->mac_flags |= BWI_MAC_F_INITED;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_reset(struct bwi_mac *mac, int link_phy)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	bwi_regwin_enable(sc, &mac->mac_regwin, flags);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_phy.phy_flags |= BWI_PHY_F_LINKED;
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_phy.phy_flags &= ~BWI_PHY_F_LINKED;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_set_tpctl_11bg(struct bwi_mac *mac, const struct bwi_tpctl *new_tpctl)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_tpctl *tpctl = &mac->mac_tpctl;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11G)
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_test(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_setup_tpctl(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_tpctl *tpctl = &mac->mac_tpctl;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_dummy_xmit(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A) {
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_init_tpctl_11bg(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_flags & BWI_MAC_F_TPCTL_INITED)
/usr/src/sys/dev/bwi/bwimac.c:		bcopy(&mac->mac_tpctl, &tpctl_orig, sizeof(tpctl_orig));
/usr/src/sys/dev/bwi/bwimac.c:		bcopy(&mac->mac_tpctl, &tpctl, sizeof(tpctl));
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_set_tpctl_11bg(mac, &tpctl);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_dummy_xmit(mac);
/usr/src/sys/dev/bwi/bwimac.c:	mac->mac_flags |= BWI_MAC_F_TPCTL_INITED;
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_flags |= BWI_MAC_F_TPCTL_ERROR;
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_set_tpctl_11bg(mac, &tpctl_orig);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_detach(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_fw_free(mac);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_fw_alloc(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_stub == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_stub = firmware_get(fwname);
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_stub == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_ucode == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:			  mac->mac_rev >= 5 ? 5 : mac->mac_rev);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_ucode = firmware_get(fwname);
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_ucode == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (!bwi_fwimage_is_valid(sc, mac->mac_ucode, BWI_FW_T_UCODE))
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_pcm == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:			  mac->mac_rev < 5 ? 4 : 5);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_pcm = firmware_get(fwname);
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_pcm == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (!bwi_fwimage_is_valid(sc, mac->mac_pcm, BWI_FW_T_PCM))
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_iv == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_rev == 2 || mac->mac_rev == 4) {
/usr/src/sys/dev/bwi/bwimac.c:		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
/usr/src/sys/dev/bwi/bwimac.c:				  mac->mac_rev);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_iv = firmware_get(fwname);
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_iv == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (!bwi_fwimage_is_valid(sc, mac->mac_iv, BWI_FW_T_IV))
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_iv_ext == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_rev == 2 || mac->mac_rev == 4 ||
/usr/src/sys/dev/bwi/bwimac.c:		    mac->mac_rev >= 11) {
/usr/src/sys/dev/bwi/bwimac.c:		} else if (mac->mac_rev >= 5 && mac->mac_rev <= 10) {
/usr/src/sys/dev/bwi/bwimac.c:				  mac->mac_rev);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_iv_ext = firmware_get(fwname);
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_iv_ext == NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		if (!bwi_fwimage_is_valid(sc, mac->mac_iv_ext, BWI_FW_T_IV))
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_fw_free(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_ucode != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		firmware_put(mac->mac_ucode, FIRMWARE_UNLOAD);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_ucode = NULL;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_pcm != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		firmware_put(mac->mac_pcm, FIRMWARE_UNLOAD);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_pcm = NULL;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_iv != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		firmware_put(mac->mac_iv, FIRMWARE_UNLOAD);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_iv = NULL;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_iv_ext != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		firmware_put(mac->mac_iv_ext, FIRMWARE_UNLOAD);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_iv_ext = NULL;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_stub != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		firmware_put(mac->mac_stub, FIRMWARE_UNLOAD);
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_stub = NULL;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_fw_load(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	     ((const uint8_t *)mac->mac_ucode->data + BWI_FWHDR_SZ);
/usr/src/sys/dev/bwi/bwimac.c:	fw_len = (mac->mac_ucode->datasize - BWI_FWHDR_SZ) / sizeof(uint32_t);
/usr/src/sys/dev/bwi/bwimac.c:	     ((const uint8_t *)mac->mac_pcm->data + BWI_FWHDR_SZ);
/usr/src/sys/dev/bwi/bwimac.c:	fw_len = (mac->mac_pcm->datasize - BWI_FWHDR_SZ) / sizeof(uint32_t);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_gpio_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_gpio_fini(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_fw_load_iv(struct bwi_mac *mac, const struct firmware *fw)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_fw_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct ifnet *ifp = mac->mac_sc->sc_ifp;
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_fw_load_iv(mac, mac->mac_iv);
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_iv_ext != NULL) {
/usr/src/sys/dev/bwi/bwimac.c:		error = bwi_mac_fw_load_iv(mac, mac->mac_iv_ext);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_opmode_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	uint32_t mac_status;
/usr/src/sys/dev/bwi/bwimac.c:	mac_status = CSR_READ_4(sc, BWI_MAC_STATUS);
/usr/src/sys/dev/bwi/bwimac.c:	mac_status &= ~(BWI_MAC_STATUS_OPMODE_HOSTAP |
/usr/src/sys/dev/bwi/bwimac.c:	mac_status |= BWI_MAC_STATUS_INFRA;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 5)
/usr/src/sys/dev/bwi/bwimac.c:		mac_status |= BWI_MAC_STATUS_PROMISC;
/usr/src/sys/dev/bwi/bwimac.c:		mac_status &= ~BWI_MAC_STATUS_INFRA;
/usr/src/sys/dev/bwi/bwimac.c:		mac_status |= BWI_MAC_STATUS_OPMODE_HOSTAP;
/usr/src/sys/dev/bwi/bwimac.c:		mac_status |= BWI_MAC_STATUS_PASS_CTL |
/usr/src/sys/dev/bwi/bwimac.c:		mac_status |= BWI_MAC_STATUS_PASS_CTL;
/usr/src/sys/dev/bwi/bwimac.c:		mac_status |= BWI_MAC_STATUS_PROMISC;
/usr/src/sys/dev/bwi/bwimac.c:	CSR_WRITE_4(sc, BWI_MAC_STATUS, mac_status);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_hostflags_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_bss_param_init(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_set_retry_lim(mac, &lim);
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_set_ackrates(mac, rt,
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_set_ackrates(mac, rt,
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_set_retry_lim(struct bwi_mac *mac, const struct bwi_retry_lim *lim)
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_set_ackrates(struct bwi_mac *mac, const struct ieee80211_rate_table *rt,
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_start(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	return bwi_mac_config_ps(mac);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_stop(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	error = bwi_mac_config_ps(mac);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_config_ps(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev >= 5) {
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_reset_hwkeys(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_shutdown(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_flags & BWI_MAC_F_HAS_TXSTATS)
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_gpio_fini(mac);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_regwin_disable(sc, &mac->mac_regwin, 0);
/usr/src/sys/dev/bwi/bwimac.c:	mac->mac_flags &= ~BWI_MAC_F_INITED;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_get_property(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_flags |= BWI_MAC_F_BSWAP;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_updateslot(struct bwi_mac *mac, int shslot)
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11B)
/usr/src/sys/dev/bwi/bwimac.c:	CSR_WRITE_2(mac->mac_sc, BWI_MAC_SLOTTIME,
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_attach(struct bwi_softc *sc, int id, uint8_t rev)
/usr/src/sys/dev/bwi/bwimac.c:	if (BWI_REGWIN_EXIST(&mac->mac_regwin)) {
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 5) {
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_flags |= BWI_MAC_F_HAS_TXSTATS;
/usr/src/sys/dev/bwi/bwimac.c:		mac->mac_flags |= BWI_MAC_F_PHYE_RESET;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_balance_atten(int *bbp_atten0, int *rf_atten0)
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_adjust_tpctl(struct bwi_mac *mac, int rf_atten_adj, int bbp_atten_adj)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	bcopy(&mac->mac_tpctl, &tpctl, sizeof(tpctl));
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_balance_atten(&bbp_atten, &rf_atten);
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_balance_atten(&bbp_atten, &rf_atten);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_lock(mac);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_set_tpctl_11bg(mac, &tpctl);
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_unlock(mac);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_calibrate_txpower(struct bwi_mac *mac, enum bwi_txpwrcb_type type)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_flags & BWI_MAC_F_TPCTL_ERROR) {
/usr/src/sys/dev/bwi/bwimac.c:		if (mac->mac_phy.phy_mode == IEEE80211_MODE_11B) {
/usr/src/sys/dev/bwi/bwimac.c:	bwi_mac_adjust_tpctl(mac, rf_atten_adj, bbp_atten_adj);
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_lock(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	KASSERT((mac->mac_flags & BWI_MAC_F_LOCKED) == 0,
/usr/src/sys/dev/bwi/bwimac.c:	    ("mac_flags 0x%x", mac->mac_flags));
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 3)
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_stop(mac);
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_config_ps(mac);
/usr/src/sys/dev/bwi/bwimac.c:	mac->mac_flags |= BWI_MAC_F_LOCKED;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_unlock(struct bwi_mac *mac)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	KASSERT(mac->mac_flags & BWI_MAC_F_LOCKED,
/usr/src/sys/dev/bwi/bwimac.c:	    ("mac_flags 0x%x", mac->mac_flags));
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 3)
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_start(mac);
/usr/src/sys/dev/bwi/bwimac.c:		bwi_mac_config_ps(mac);
/usr/src/sys/dev/bwi/bwimac.c:	mac->mac_flags &= ~BWI_MAC_F_LOCKED;
/usr/src/sys/dev/bwi/bwimac.c:bwi_mac_set_promisc(struct bwi_mac *mac, int promisc)
/usr/src/sys/dev/bwi/bwimac.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwimac.c:	if (mac->mac_rev < 5) /* Promisc is always on */
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:		CSR_FILT_SETBITS_2(mac->mac_sc, BWI_BBP_ATTEN, ~mask,
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	CSR_READ_4(mac->mac_sc, BWI_MAC_STATUS);
/usr/src/sys/dev/bwi/bwiphy.c:		bwi_mac_reset(mac, 0);
/usr/src/sys/dev/bwi/bwiphy.c:		bwi_mac_reset(mac, 1);
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwiphy.c:	const struct bwi_tpctl *tpctl = &mac->mac_tpctl;
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_init_tpctl_11bg(mac);
/usr/src/sys/dev/bwi/bwiphy.c:	if_printf(mac->mac_sc->sc_ifp,
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_set_tpctl_11bg(mac, NULL);
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_init_tpctl_11bg(mac);
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_set_tpctl_11bg(mac, NULL);
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_set_tpctl_11bg(mac, NULL);
/usr/src/sys/dev/bwi/bwiphy.c:		bwi_mac_init_tpctl_11bg(mac);
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwiphy.c:	bwi_mac_dummy_xmit(mac);
/usr/src/sys/dev/bwi/bwirf.c:	return &mac->mac_rf.rf_lo[n];
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:		if (mac->mac_rev >= 5)
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	mac->mac_rf.rf_curchan = chan;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	bwi_phy_set_bbp_atten(mac, mac->mac_tpctl.bbp_atten);
/usr/src/sys/dev/bwi/bwirf.c:	DPRINTF(mac->mac_sc, BWI_DBG_RF | BWI_DBG_INIT,
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_tpctl *tpctl = &mac->mac_tpctl;
/usr/src/sys/dev/bwi/bwirf.c:		bwi_mac_dummy_xmit(mac);
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct ifnet *ifp = mac->mac_sc->sc_ifp;
/usr/src/sys/dev/bwi/bwirf.c:			tp_ctrl2 = mac->mac_tpctl.tp_ctrl2;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	    (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) == 0)
/usr/src/sys/dev/bwi/bwirf.c:	if ((mac->mac_phy.phy_flags & BWI_PHY_F_LINKED) == 0 ||
/usr/src/sys/dev/bwi/bwirf.c:	    (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) == 0) {
/usr/src/sys/dev/bwi/bwirf.c:		thr1 = _nrssi_threshold(&mac->mac_rf, 0x11);
/usr/src/sys/dev/bwi/bwirf.c:		thr2 = _nrssi_threshold(&mac->mac_rf, 0xe);
/usr/src/sys/dev/bwi/bwirf.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11A) {
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/bwirf.c:		if (mac->mac_rev == 2)
/usr/src/sys/dev/bwi/bwirf.c:	if (mac->mac_rev < 5)
/usr/src/sys/dev/bwi/bwirf.c:	mac->mac_rf.rf_ant_mode = ant_mode;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	if (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
/usr/src/sys/dev/bwi/bwirf.c:		struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	if (mac->mac_phy.phy_mode != IEEE80211_MODE_11G)
/usr/src/sys/dev/bwi/bwirf.c:	DPRINTF(mac->mac_sc, BWI_DBG_RF | BWI_DBG_RX,
/usr/src/sys/dev/bwi/bwirf.c:	if (mac->mac_sc->sc_card_flags & BWI_CARD_F_SW_NRSSI) {
/usr/src/sys/dev/bwi/bwirf.c:		struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwi/bwirf.c:	struct bwi_rf *rf = &mac->mac_rf;
/usr/src/sys/dev/bwi/if_bwi.c:		error = bwi_regwin_switch(sc, &mac->mac_regwin, &old);
/usr/src/sys/dev/bwi/if_bwi.c:		error = bwi_mac_lateattach(mac);
/usr/src/sys/dev/bwi/if_bwi.c:	phy = &mac->mac_phy;
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_detach(&sc->sc_mac[i]);
/usr/src/sys/dev/bwi/if_bwi.c:			bwi_mac_attach(sc, i, rw_rev);
/usr/src/sys/dev/bwi/if_bwi.c:	if (!BWI_REGWIN_EXIST(&sc->sc_mac[0].mac_regwin)) {
/usr/src/sys/dev/bwi/if_bwi.c:	error = bwi_regwin_switch(sc, &sc->sc_mac[0].mac_regwin, NULL);
/usr/src/sys/dev/bwi/if_bwi.c:	KASSERT(sc->sc_cur_regwin == &mac->mac_regwin, ("not cur regwin"));
/usr/src/sys/dev/bwi/if_bwi.c:		uint32_t mac_mask;
/usr/src/sys/dev/bwi/if_bwi.c:		mac_mask = 1 << mac->mac_id;
/usr/src/sys/dev/bwi/if_bwi.c:		val |= mac_mask << 8;
/usr/src/sys/dev/bwi/if_bwi.c:	error = bwi_regwin_switch(sc, &mac->mac_regwin, NULL);
/usr/src/sys/dev/bwi/if_bwi.c:	error = bwi_mac_init(mac);
/usr/src/sys/dev/bwi/if_bwi.c:	bwi_mac_reset_hwkeys(mac);
/usr/src/sys/dev/bwi/if_bwi.c:	if ((mac->mac_flags & BWI_MAC_F_HAS_TXSTATS) == 0) {
/usr/src/sys/dev/bwi/if_bwi.c:	if (mac->mac_phy.phy_mode == IEEE80211_MODE_11G)
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_updateslot(mac, 1);
/usr/src/sys/dev/bwi/if_bwi.c:	error = bwi_mac_start(mac);
/usr/src/sys/dev/bwi/if_bwi.c:				bwi_mac_set_promisc(mac, promisc);
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_stop(mac);
/usr/src/sys/dev/bwi/if_bwi.c:		if ((mac->mac_flags & BWI_MAC_F_INITED) == 0)
/usr/src/sys/dev/bwi/if_bwi.c:		error = bwi_regwin_switch(sc, &mac->mac_regwin, &old_rw);
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_shutdown(mac);
/usr/src/sys/dev/bwi/if_bwi.c:		if (mac->mac_flags & BWI_MAC_F_PHYE_RESET) {
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_config_ps(mac);
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_calibrate_txpower(mac, BWI_TXPWR_INIT);
/usr/src/sys/dev/bwi/if_bwi.c:		if (sc->sc_mac[i].mac_flags & BWI_MAC_F_HAS_TXSTATS) {
/usr/src/sys/dev/bwi/if_bwi.c:	uint32_t mac_ctrl;
/usr/src/sys/dev/bwi/if_bwi.c:	phy_ctrl = __SHIFTIN(mac->mac_rf.rf_ant_mode,
/usr/src/sys/dev/bwi/if_bwi.c:	mac_ctrl = BWI_TXH_MAC_C_HWSEQ | BWI_TXH_MAC_C_FIRST_FRAG;
/usr/src/sys/dev/bwi/if_bwi.c:		mac_ctrl |= BWI_TXH_MAC_C_ACK;
/usr/src/sys/dev/bwi/if_bwi.c:		mac_ctrl |= BWI_TXH_MAC_C_FB_OFDM;
/usr/src/sys/dev/bwi/if_bwi.c:	hdr->txh_mac_ctrl = htole32(mac_ctrl);
/usr/src/sys/dev/bwi/if_bwi.c:	uint32_t mac_ctrl;
/usr/src/sys/dev/bwi/if_bwi.c:	mac_ctrl = BWI_TXH_MAC_C_HWSEQ | BWI_TXH_MAC_C_FIRST_FRAG;
/usr/src/sys/dev/bwi/if_bwi.c:		mac_ctrl |= BWI_TXH_MAC_C_ACK;
/usr/src/sys/dev/bwi/if_bwi.c:	phy_ctrl = __SHIFTIN(mac->mac_rf.rf_ant_mode,
/usr/src/sys/dev/bwi/if_bwi.c:		mac_ctrl |= BWI_TXH_MAC_C_FB_OFDM;
/usr/src/sys/dev/bwi/if_bwi.c:	hdr->txh_mac_ctrl = htole32(mac_ctrl);
/usr/src/sys/dev/bwi/if_bwi.c:		if (hdr->txh_mac_ctrl & htole32(BWI_TXH_MAC_C_ACK)) {
/usr/src/sys/dev/bwi/if_bwi.c:		bwi_mac_updateslot(mac, (ic->ic_flags & IEEE80211_F_SHSLOT));
/usr/src/sys/dev/bwi/if_bwi.c:	bwi_mac_calibrate_txpower(mac, sc->sc_txpwrcb_type);
/usr/src/sys/dev/bwn/if_bwn.c:static void	bwn_mac_suspend(struct bwn_mac *);
/usr/src/sys/dev/bwn/if_bwn.c:static void	bwn_mac_enable(struct bwn_mac *);
/usr/src/sys/dev/bwn/if_bwn.c:static void	bwn_mac_write_bssid(struct bwn_mac *);
/usr/src/sys/dev/bwn/if_bwn.c:static void	bwn_mac_setfilter(struct bwn_mac *, uint16_t,
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_sc = sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_status = BWN_MAC_STATUS_UNINIT;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_flags |= BWN_MAC_FLAG_BADFRAME_PREEMP;
/usr/src/sys/dev/bwn/if_bwn.c:	TASK_INIT(&mac->mac_hwreset, 0, bwn_hwreset, mac);
/usr/src/sys/dev/bwn/if_bwn.c:	TASK_INIT(&mac->mac_intrtask, 0, bwn_intrtask, mac);
/usr/src/sys/dev/bwn/if_bwn.c:	TASK_INIT(&mac->mac_txpower, 0, bwn_txpwr, mac);
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.analog, mac->mac_phy.type, mac->mac_phy.rev,
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.rf_manuf, mac->mac_phy.rf_ver,
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.rf_rev);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DMA)
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_method.dma.dmatype);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_intr_spec = bwn_res_spec_legacy;
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_intr_spec = bwn_res_spec_msi;
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_msi = 1;
/usr/src/sys/dev/bwn/if_bwn.c:	error = bus_alloc_resources(dev, mac->mac_intr_spec,
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_res_irq);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_msi == 0)
/usr/src/sys/dev/bwn/if_bwn.c:		error = bus_setup_intr(dev, mac->mac_res_irq[0],
/usr/src/sys/dev/bwn/if_bwn.c:		    &mac->mac_intrhand[0]);
/usr/src/sys/dev/bwn/if_bwn.c:			error = bus_setup_intr(dev, mac->mac_res_irq[i],
/usr/src/sys/dev/bwn/if_bwn.c:			    &mac->mac_intrhand[i]);
/usr/src/sys/dev/bwn/if_bwn.c:	TAILQ_INSERT_TAIL(&sc->sc_maclist, mac, mac_list);
/usr/src/sys/dev/bwn/if_bwn.c:	    bwn_is_valid_ether_addr(siba_sprom_get_mac_80211a(sc->sc_dev)) ?
/usr/src/sys/dev/bwn/if_bwn.c:	    siba_sprom_get_mac_80211a(sc->sc_dev) :
/usr/src/sys/dev/bwn/if_bwn.c:	    siba_sprom_get_mac_80211bg(sc->sc_dev));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.detach != NULL)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.detach(mac);
/usr/src/sys/dev/bwn/if_bwn.c:			ieee80211_draintask(ic, &mac->mac_hwreset);
/usr/src/sys/dev/bwn/if_bwn.c:			ieee80211_draintask(ic, &mac->mac_txpower);
/usr/src/sys/dev/bwn/if_bwn.c:	taskqueue_drain(sc->sc_tq, &mac->mac_intrtask);
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_intrhand[i] != NULL) {
/usr/src/sys/dev/bwn/if_bwn.c:			bus_teardown_intr(dev, mac->mac_res_irq[i],
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_intrhand[i]);
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_intrhand[i] = NULL;
/usr/src/sys/dev/bwn/if_bwn.c:	bus_release_resources(dev, mac->mac_intr_spec, mac->mac_res_irq);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_msi != 0)
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_status < BWN_MAC_STATUS_STARTED)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DMA) {
/usr/src/sys/dev/bwn/if_bwn.c:	error = (mac->mac_flags & BWN_MAC_FLAG_DMA) ?
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if ((mac->mac_flags & BWN_MAC_FLAG_WME) == 0)
/usr/src/sys/dev/bwn/if_bwn.c:		return (&mac->mac_method.pio.wme[WME_AC_BE]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (&mac->mac_method.pio.wme[WME_AC_BE]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (&mac->mac_method.pio.wme[WME_AC_BK]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (&mac->mac_method.pio.wme[WME_AC_VI]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (&mac->mac_method.pio.wme[WME_AC_VO]);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.type == BWN_PHYTYPE_A)
/usr/src/sys/dev/bwn/if_bwn.c:		else if (mac->mac_phy.type == BWN_PHYTYPE_G ||
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.type == BWN_PHYTYPE_N ||
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.type == BWN_PHYTYPE_LP)
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_phy.type));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type != BWN_PHYTYPE_LP &&
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.type != BWN_PHYTYPE_N) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type == BWN_PHYTYPE_G) {
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.attach = bwn_phy_g_attach;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.detach = bwn_phy_g_detach;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.prepare_hw = bwn_phy_g_prepare_hw;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.init_pre = bwn_phy_g_init_pre;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.init = bwn_phy_g_init;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.exit = bwn_phy_g_exit;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.phy_read = bwn_phy_g_read;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.phy_write = bwn_phy_g_write;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_read = bwn_phy_g_rf_read;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_write = bwn_phy_g_rf_write;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.use_hwpctl = bwn_phy_g_hwpctl;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_onoff = bwn_phy_g_rf_onoff;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.switch_analog = bwn_phy_switch_analog;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.switch_channel = bwn_phy_g_switch_channel;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.get_default_chan = bwn_phy_g_get_default_chan;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.set_antenna = bwn_phy_g_set_antenna;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.set_im = bwn_phy_g_im;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.recalc_txpwr = bwn_phy_g_recalc_txpwr;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.set_txpwr = bwn_phy_g_set_txpwr;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.task_15s = bwn_phy_g_task_15s;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.task_60s = bwn_phy_g_task_60s;
/usr/src/sys/dev/bwn/if_bwn.c:	} else if (mac->mac_phy.type == BWN_PHYTYPE_LP) {
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.init_pre = bwn_phy_lp_init_pre;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.init = bwn_phy_lp_init;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.phy_read = bwn_phy_lp_read;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.phy_write = bwn_phy_lp_write;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.phy_maskset = bwn_phy_lp_maskset;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_read = bwn_phy_lp_rf_read;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_write = bwn_phy_lp_rf_write;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.rf_onoff = bwn_phy_lp_rf_onoff;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.switch_analog = bwn_phy_lp_switch_analog;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.switch_channel = bwn_phy_lp_switch_channel;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.get_default_chan = bwn_phy_lp_get_default_chan;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.set_antenna = bwn_phy_lp_set_antenna;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.task_60s = bwn_phy_lp_task_60s;
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.type);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.gmode = have_bg;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.attach != NULL) {
/usr/src/sys/dev/bwn/if_bwn.c:		error = mac->mac_phy.attach(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.switch_analog(mac, 0);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.switch_analog != NULL)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.switch_analog(mac, 1);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type == BWN_PHYTYPE_N) {
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.supports_2ghz = have_bg;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.supports_5ghz = have_a;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_g *pg = &mac->mac_phy.phy_g;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_txpwr_loctl *lo = &mac->mac_phy.phy_g.pg_loctl;
/usr/src/sys/dev/bwn/if_bwn.c:	return (mac->mac_phy.rev >= 6);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_status < BWN_MAC_STATUS_STARTED) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac != NULL && mac->mac_status >= BWN_MAC_STATUS_INITED) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac != NULL && mac->mac_status >= BWN_MAC_STATUS_INITED) {
/usr/src/sys/dev/bwn/if_bwn.c:		bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:		bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac != NULL && mac->mac_status >= BWN_MAC_STATUS_INITED) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac != NULL && mac->mac_status >= BWN_MAC_STATUS_INITED) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:			if (!(mac->mac_flags & BWN_MAC_FLAG_RADIO_ON))
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status == BWN_MAC_STATUS_UNINIT) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status == BWN_MAC_STATUS_INITED)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status >= BWN_MAC_STATUS_INITED) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status >= BWN_MAC_STATUS_STARTED)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_status == BWN_MAC_STATUS_UNINIT,
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.gmode ? BWN_TGSLOW_SUPPORT_G : 0);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_flags &= ~BWN_MAC_FLAG_DFQVALID;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_flags |= BWN_MAC_FLAG_RADIO_ON;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.hwpctl = (bwn_hwpctl) ? 1 : 0;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_GETTIME(mac->mac_phy.nexttime);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.txerrors = BWN_TXERROR_MAX;
/usr/src/sys/dev/bwn/if_bwn.c:	bzero(&mac->mac_stats, sizeof(mac->mac_stats));
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_stats.link_noise = -95;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason_intr = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	bzero(mac->mac_reason, sizeof(mac->mac_reason));
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_intr_mask = BWN_INTR_MASKTEMPLATE;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_intr_mask &= ~BWN_INTR_PHY_TXERR;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_suspended = 1;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_task_state = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	memset(&mac->mac_noise, 0, sizeof(mac->mac_noise));
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.init_pre(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.prepare_hw) {
/usr/src/sys/dev/bwn/if_bwn.c:		error = mac->mac_phy.prepare_hw(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type == BWN_PHYTYPE_G) {
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rev == 1)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rf_ver == 0x2050) {
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rf_rev < 6)
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rf_rev == 6)
/usr/src/sys/dev/bwn/if_bwn.c:	    (mac->mac_phy.type == BWN_PHYTYPE_B) ? 0x1f : 0xf);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_status = BWN_MAC_STATUS_INITED;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_status == BWN_MAC_STATUS_UNINIT,
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_status == BWN_MAC_STATUS_INITED,
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_INTR_MASK, mac->mac_intr_mask);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_status = BWN_MAC_STATUS_STARTED;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_status <= BWN_MAC_STATUS_INITED,
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status != BWN_MAC_STATUS_INITED)
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_status = BWN_MAC_STATUS_UNINIT;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.switch_analog(mac, 0);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	switch (mac->mac_phy.type) {
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.type == BWN_PHYTYPE_A)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_pio *pio = &mac->mac_method.pio;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = dr->dr_mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = dr->dr_mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = dr->dr_mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	delay = (mac->mac_phy.type == BWN_PHYTYPE_A) ? 3700 : 1050;
/usr/src/sys/dev/bwn/if_bwn.c:	if ((mac->mac_phy.rf_ver == 0x2050) && (mac->mac_phy.rf_rev == 8))
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type != BWN_PHYTYPE_B && !mac->mac_phy.gmode)
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_write_bssid(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_setfilter(mac, BWN_MACFILTER_SELF, mac->mac_sc->sc_macaddr);
/usr/src/sys/dev/bwn/if_bwn.c:	for (i = 0; i < mac->mac_max_nr_keys; i++) {
/usr/src/sys/dev/bwn/if_bwn.c:		KASSERT(i >= 0 && i < mac->mac_max_nr_keys,
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_key[i].keyconf = NULL;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_max_nr_keys = (siba_get_revid(sc->sc_dev) >= 5) ? 58 : 20;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_max_nr_keys <= N(mac->mac_key),
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_ktp = bwn_shm_read_2(mac, BWN_SHARED, BWN_SHARED_KEY_TABLEP);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_ktp *= 2;
/usr/src/sys/dev/bwn/if_bwn.c:		BWN_WRITE_2(mac, BWN_RCMTA_COUNT, mac->mac_max_nr_keys - 8);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_fw *fw = &mac->mac_fw;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.chan = mac->mac_phy.get_default_chan(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_onoff(mac, 1);
/usr/src/sys/dev/bwn/if_bwn.c:	error = mac->mac_phy.init(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.get_default_chan(mac));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.exit)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.exit(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_onoff(mac, 0);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.hwpctl == 0 || mac->mac_phy.use_hwpctl == NULL)
/usr/src/sys/dev/bwn/if_bwn.c:	return (mac->mac_phy.use_hwpctl(mac));
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_BADFRAME_PREEMP)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_g *pg = &mac->mac_phy.phy_g;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_g *pg = &mac->mac_phy.phy_g;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.type == BWN_PHYTYPE_G,
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:		device_printf(mac->mac_sc->sc_dev, "out of memory\n");
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_txpwr_loctl *lo = &mac->mac_phy.phy_g.pg_loctl;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_g *pg = &mac->mac_phy.phy_g;
/usr/src/sys/dev/bwn/if_bwn.c:bwn_mac_suspend(struct bwn_mac *mac)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_suspended >= 0,
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_suspended == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_suspended++;
/usr/src/sys/dev/bwn/if_bwn.c:bwn_mac_enable(struct bwn_mac *mac)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_suspended--;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_suspended >= 0,
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_suspended == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rf_ver != 0x2050 || mac->mac_phy.rf_rev >= 6)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_fw *fw = &mac->mac_fw;
/usr/src/sys/dev/bwn/if_bwn.c:	switch (mac->mac_phy.type) {
/usr/src/sys/dev/bwn/if_bwn.c:	switch (mac->mac_phy.type) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	    (mac->mac_phy.type == BWN_PHYTYPE_LP) ? "lp_" : "", name);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_do_release_fw(&mac->mac_fw.ucode);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_do_release_fw(&mac->mac_fw.pcm);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_do_release_fw(&mac->mac_fw.initvals);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_do_release_fw(&mac->mac_fw.initvals_band);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	data = GETFWOFFSET(mac->mac_fw.ucode, sizeof(struct bwn_fwhdr));
/usr/src/sys/dev/bwn/if_bwn.c:	for (i = 0; i < GETFWSIZE(mac->mac_fw.ucode, sizeof(struct bwn_fwhdr));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_fw.pcm.fw) {
/usr/src/sys/dev/bwn/if_bwn.c:		data = GETFWOFFSET(mac->mac_fw.pcm, sizeof(struct bwn_fwhdr));
/usr/src/sys/dev/bwn/if_bwn.c:		for (i = 0; i < GETFWSIZE(mac->mac_fw.pcm,
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_fw.rev = bwn_shm_read_2(mac, BWN_SHARED, BWN_SHARED_UCODE_REV);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_fw.rev <= 0x128) {
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_fw.patch = bwn_shm_read_2(mac, BWN_SHARED,
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_fw.opensource = (date == 0xffff);
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_flags |= BWN_MAC_FLAG_WME;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_flags |= BWN_MAC_FLAG_HWCRYPTO;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_fw.opensource == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_fw.rev, mac->mac_fw.patch, date, time);
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_fw.no_pcmfile)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_fw.patch = time;
/usr/src/sys/dev/bwn/if_bwn.c:		if (!(fwcaps & BWN_FWCAPS_HWCRYPTO) || mac->mac_fw.no_pcmfile) {
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_flags &= ~BWN_MAC_FLAG_HWCRYPTO;
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_flags &= ~BWN_MAC_FLAG_WME;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_fw.opensource == 1,
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &(mac->mac_phy);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.chan = chan;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:bwn_mac_write_bssid(struct bwn_mac *mac)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	uint8_t mac_bssid[IEEE80211_ADDR_LEN * 2];
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_setfilter(mac, BWN_MACFILTER_BSSID, sc->sc_bssid);
/usr/src/sys/dev/bwn/if_bwn.c:	memcpy(mac_bssid, sc->sc_macaddr, IEEE80211_ADDR_LEN);
/usr/src/sys/dev/bwn/if_bwn.c:	memcpy(mac_bssid + IEEE80211_ADDR_LEN, sc->sc_bssid,
/usr/src/sys/dev/bwn/if_bwn.c:	for (i = 0; i < N(mac_bssid); i += sizeof(uint32_t)) {
/usr/src/sys/dev/bwn/if_bwn.c:		tmp = (uint32_t) (mac_bssid[i + 0]);
/usr/src/sys/dev/bwn/if_bwn.c:		tmp |= (uint32_t) (mac_bssid[i + 1]) << 8;
/usr/src/sys/dev/bwn/if_bwn.c:		tmp |= (uint32_t) (mac_bssid[i + 2]) << 16;
/usr/src/sys/dev/bwn/if_bwn.c:		tmp |= (uint32_t) (mac_bssid[i + 3]) << 24;
/usr/src/sys/dev/bwn/if_bwn.c:bwn_mac_setfilter(struct bwn_mac *mac, uint16_t offset,
/usr/src/sys/dev/bwn/if_bwn.c:    const uint8_t *key, size_t key_len, const uint8_t *mac_addr)
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(index < mac->mac_max_nr_keys,
/usr/src/sys/dev/bwn/if_bwn.c:		bwn_key_macwrite(mac, index, mac_addr);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_key[index].algorithm = algorithm;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	offset = mac->mac_ktp + (index * BWN_SEC_KEYSIZE);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_onoff(mac, 0);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.exit != NULL)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.exit(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if ((mac->mac_flags & BWN_MAC_FLAG_DMA) == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status < BWN_MAC_STATUS_STARTED)
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_status = BWN_MAC_STATUS_INITED;
/usr/src/sys/dev/bwn/if_bwn.c:	TAILQ_FOREACH(mac, &sc->sc_maclist, mac_list) {
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.supports_2ghz) {
/usr/src/sys/dev/bwn/if_bwn.c:		    mac->mac_phy.supports_5ghz) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (up_dev == sc->sc_curmac && sc->sc_curmac->mac_phy.gmode == gmode)
/usr/src/sys/dev/bwn/if_bwn.c:	status = down_dev->mac_status;
/usr/src/sys/dev/bwn/if_bwn.c:	up_dev->mac_phy.gmode = gmode;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(up_dev->mac_status == status, ("%s: fail", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_onoff(mac, 1);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_on = 1;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_onoff(mac, 0);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.rf_on = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:		pretbtt = (mac->mac_phy.type == BWN_PHYTYPE_A) ? 120 : 250;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status < BWN_MAC_STATUS_STARTED ||
/usr/src/sys/dev/bwn/if_bwn.c:	reason &= mac->mac_intr_mask;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason[0] = BWN_READ_4(mac, BWN_DMA0_REASON) & 0x0001dc00;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason[1] = BWN_READ_4(mac, BWN_DMA1_REASON) & 0x0000dc00;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason[2] = BWN_READ_4(mac, BWN_DMA2_REASON) & 0x0000dc00;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason[3] = BWN_READ_4(mac, BWN_DMA3_REASON) & 0x0001dc00;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason[4] = BWN_READ_4(mac, BWN_DMA4_REASON) & 0x0000dc00;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_DMA0_REASON, mac->mac_reason[0]);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_DMA1_REASON, mac->mac_reason[1]);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_DMA2_REASON, mac->mac_reason[2]);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_DMA3_REASON, mac->mac_reason[3]);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_DMA4_REASON, mac->mac_reason[4]);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_reason_intr = reason;
/usr/src/sys/dev/bwn/if_bwn.c:	taskqueue_enqueue_fast(sc->sc_tq, &mac->mac_intrtask);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status < BWN_MAC_STATUS_STARTED ||
/usr/src/sys/dev/bwn/if_bwn.c:	for (i = 0; i < N(mac->mac_reason); i++)
/usr/src/sys/dev/bwn/if_bwn.c:		merged |= mac->mac_reason[i];
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_MAC_TXERR)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_PHY_TXERR) {
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.txerrors--;
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.txerrors == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_phy.txerrors = BWN_TXERROR_MAX;
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[0], mac->mac_reason[1],
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[2], mac->mac_reason[3],
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[4], mac->mac_reason[5]);
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[0], mac->mac_reason[1],
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[2], mac->mac_reason[3],
/usr/src/sys/dev/bwn/if_bwn.c:			    mac->mac_reason[4], mac->mac_reason[5]);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_UCODE_DEBUG)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_TBTT_INDI)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_ATIM_END)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_BEACON)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_PMQ)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_NOISESAMPLE_OK)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DMA) {
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_reason[0] & BWN_DMAINTR_RX_DONE) {
/usr/src/sys/dev/bwn/if_bwn.c:			bwn_dma_rx(mac->mac_method.dma.rx);
/usr/src/sys/dev/bwn/if_bwn.c:		rx = bwn_pio_rx(&mac->mac_method.pio.rx);
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(!(mac->mac_reason[1] & BWN_DMAINTR_RX_DONE), ("%s", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(!(mac->mac_reason[2] & BWN_DMAINTR_RX_DONE), ("%s", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(!(mac->mac_reason[3] & BWN_DMAINTR_RX_DONE), ("%s", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(!(mac->mac_reason[4] & BWN_DMAINTR_RX_DONE), ("%s", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(!(mac->mac_reason[5] & BWN_DMAINTR_RX_DONE), ("%s", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_reason_intr & BWN_INTR_TX_OK) {
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_WRITE_4(mac, BWN_INTR_MASK, mac->mac_intr_mask);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status < BWN_MAC_STATUS_INITED)
/usr/src/sys/dev/bwn/if_bwn.c:	ieee80211_runtask(ic, &mac->mac_hwreset);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_fw.opensource == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_flags |= BWN_MAC_FLAG_DFQVALID;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DFQVALID) {
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_flags &= ~BWN_MAC_FLAG_DFQVALID;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_intr_mask &= ~BWN_INTR_BEACON;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_intr_mask |= BWN_INTR_BEACON;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_g *pg = &mac->mac_phy.phy_g;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type != BWN_PHYTYPE_G)
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_noise.noi_running, ("%s: fail", __func__));
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_noise.noi_nsamples < 8,
/usr/src/sys/dev/bwn/if_bwn.c:	i = mac->mac_noise.noi_nsamples;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_samples[i][0] = pg->pg_nrssi_lt[noise[0]];
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_samples[i][1] = pg->pg_nrssi_lt[noise[1]];
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_samples[i][2] = pg->pg_nrssi_lt[noise[2]];
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_samples[i][3] = pg->pg_nrssi_lt[noise[3]];
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_nsamples++;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_noise.noi_nsamples == 8) {
/usr/src/sys/dev/bwn/if_bwn.c:				average += mac->mac_noise.noi_samples[i][j];
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_stats.link_noise = average;
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_noise.noi_running = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status < BWN_MAC_STATUS_STARTED)
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	prev_status = mac->mac_status;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(dr->dr_mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(dr->dr_mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	macstat = le32toh(rxhdr->mac_status);
/usr/src/sys/dev/bwn/if_bwn.c:		if (!(mac->mac_sc->sc_filters & BWN_MACCTL_PASS_BADFCS)) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_stats *stats = &mac->mac_stats;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DMA) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	macstat = le32toh(rxhdr.mac_status);
/usr/src/sys/dev/bwn/if_bwn.c:		if (!(mac->mac_sc->sc_filters & BWN_MACCTL_PASS_BADFCS)) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	static int rx_mac_dec_rpt = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	macstat = le32toh(rxhdr->mac_status);
/usr/src/sys/dev/bwn/if_bwn.c:	if (macstat & BWN_RX_MAC_DEC && rx_mac_dec_rpt++ < 50)
/usr/src/sys/dev/bwn/if_bwn.c:		if (!(mac->mac_sc->sc_filters & BWN_MACCTL_PASS_BADPLCP))
/usr/src/sys/dev/bwn/if_bwn.c:	noise = mac->mac_stats.link_noise;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:		ieee80211_runtask(ic, &mac->mac_txpower);
/usr/src/sys/dev/bwn/if_bwn.c:	const struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.gmode)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type != BWN_PHYTYPE_G)
/usr/src/sys/dev/bwn/if_bwn.c:	if ((mac->mac_flags & BWN_MAC_FLAG_WME) == 0)
/usr/src/sys/dev/bwn/if_bwn.c:		return (mac->mac_method.dma.wme[WME_AC_BE]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (mac->mac_method.dma.wme[WME_AC_VO]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (mac->mac_method.dma.wme[WME_AC_VI]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (mac->mac_method.dma.wme[WME_AC_BE]);
/usr/src/sys/dev/bwn/if_bwn.c:		return (mac->mac_method.dma.wme[WME_AC_BK]);
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(dr->dr_mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_txpwr_loctl *lo = &mac->mac_phy.phy_g.pg_loctl;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_pio *pio = &mac->mac_method.pio;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac && mac->mac_status >= BWN_MAC_STATUS_STARTED &&
/usr/src/sys/dev/bwn/if_bwn.c:	    mac->mac_phy.set_txpwr != NULL)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.set_txpwr(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_fw.opensource) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.task_15s)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.task_15s(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_phy.txerrors = BWN_TXERROR_MAX;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.type != BWN_PHYTYPE_G || mac->mac_noise.noi_running)
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_running = 1;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_noise.noi_nsamples = 0;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.task_60s)
/usr/src/sys/dev/bwn/if_bwn.c:		mac->mac_phy.task_60s(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_status != BWN_MAC_STATUS_STARTED)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_task_state % 4 == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_task_state % 2 == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_task_state++;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	tsf += le16toh(rxhdr->mac_time);
/usr/src/sys/dev/bwn/if_bwn.c:	if (low_mactime_now < le16toh(rxhdr->mac_time))
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(siba_get_revid(mac->mac_sc->sc_dev) >= 3,
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	mac->mac_flags |= BWN_MAC_FLAG_DMA;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_dma *dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	BWN_ASSERT_LOCKED(mac->mac_sc);
/usr/src/sys/dev/bwn/if_bwn.c:	if ((mac->mac_flags & BWN_MAC_FLAG_DMA) == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	dma = &mac->mac_method.dma;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_DMA)
/usr/src/sys/dev/bwn/if_bwn.c:	pio = &mac->mac_method.pio;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_status >= BWN_MAC_STATUS_STARTED,
/usr/src/sys/dev/bwn/if_bwn.c:	    ("%s: invalid MAC status %d", __func__, mac->mac_status));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rf_rev >= 3 || mac->mac_phy.type == BWN_PHYTYPE_LP) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_flags & BWN_MAC_FLAG_RADIO_ON)
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_flags |= BWN_MAC_FLAG_RADIO_ON;
/usr/src/sys/dev/bwn/if_bwn.c:			mac->mac_flags &= ~BWN_MAC_FLAG_RADIO_ON;
/usr/src/sys/dev/bwn/if_bwn.c:		if (cur != mac->mac_phy.rf_on) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rf_ver == 0x2062)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2 && reg != 0x4001)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:		    (mac->mac_phy.rev >= 2) ? 0xf7f7 : 0xffe7);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy *phy = &mac->mac_phy;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_suspend(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 0 && mode != BWN_PHYLP_TXPCTL_OFF)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2 && fc == 1) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	} else if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	bwn_mac_enable(mac);
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2) {
/usr/src/sys/dev/bwn/if_bwn.c:		if ((mac->mac_phy.rev == 1) && (plp->plp_rccap))
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.rev < 2, ("%s:%d: fail", __func__, __LINE__));
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rev < 2)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	    (mac->mac_phy.rev < 2) ? BWN_TAB_4(10, 0x140) :
/usr/src/sys/dev/bwn/if_bwn.c:	    (mac->mac_phy.rev < 2) ? BWN_TAB_4(10, 0x140) :
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:		    (mac->mac_phy.rev >= 2) ? BWN_TAB_4(7, txpwridx + 448) :
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:		if (mac->mac_phy.rev == 0)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 1 &&
/usr/src/sys/dev/bwn/if_bwn.c:	    ((mac->mac_phy.rev == 0) &&
/usr/src/sys/dev/bwn/if_bwn.c:	} else if (mac->mac_phy.rev == 1 ||
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 1 &&
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 1) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev > 0)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 1)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_phy_lp *plp = &mac->mac_phy.phy_lp;
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.rev < 2, ("%s:%d: fail", __func__, __LINE__));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.rev < 2, ("%s:%d: fail", __func__, __LINE__));
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev != 0 && mac->mac_phy.rev != 1) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev == 0) {
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev < 2)
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 2)
/usr/src/sys/dev/bwn/if_bwn.c:	struct bwn_softc *sc = mac->mac_sc;
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.rev >= 2, ("%s:%d: fail", __func__, __LINE__));
/usr/src/sys/dev/bwn/if_bwn.c:	if (mac->mac_phy.rev >= 3) {
/usr/src/sys/dev/bwn/if_bwn.c:	KASSERT(mac->mac_phy.rev < 2, ("%s:%d: fail", __func__, __LINE__));
/usr/src/sys/dev/bwn/if_bwn.c:	stats = &mac->mac_stats;
/usr/src/sys/dev/bxe/bxe_link.c: * b[6]status_serdes0_mac_crs; b[7]status_serdes0_autoneg_complete;
/usr/src/sys/dev/bxe/bxe_link.c: * b[25]status_xgxs0_rx_sigdet; b[26]status_xgxs0_mac_crs
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base;
/usr/src/sys/dev/bxe/bxe_link.c:	emac_base = (params->port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR(sc, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245f8000);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR(sc, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245d000f);
/usr/src/sys/dev/bxe/bxe_link.c:bxe_emac_init(struct link_params *params, struct link_vars *vars)
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base, val;
/usr/src/sys/dev/bxe/bxe_link.c:	emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:	val = REG_RD(sc, emac_base + EMAC_REG_EMAC_MODE);
/usr/src/sys/dev/bxe/bxe_link.c:		val = REG_RD(sc, emac_base + EMAC_REG_EMAC_MODE);
/usr/src/sys/dev/bxe/bxe_link.c:	val = ((params->mac_addr[0] << 8) | params->mac_addr[1]);
/usr/src/sys/dev/bxe/bxe_link.c:	val = ((params->mac_addr[2] << 24) | (params->mac_addr[3] << 16) |
/usr/src/sys/dev/bxe/bxe_link.c:	    (params->mac_addr[4] << 8) | params->mac_addr[5]);
/usr/src/sys/dev/bxe/bxe_link.c:bxe_emac_enable(struct link_params *params, struct link_vars *vars, uint8_t lb)
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base, ser_lane, val;
/usr/src/sys/dev/bxe/bxe_link.c:	emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bits_en(sc, emac_base + EMAC_REG_EMAC_RX_MODE, EMAC_RX_MODE_RESET);
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bits_en(sc, emac_base + EMAC_REG_EMAC_TX_MODE, EMAC_TX_MODE_RESET);
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bits_dis(sc, emac_base + EMAC_REG_EMAC_RX_MODE,
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_bits_en(sc, emac_base + EMAC_REG_EMAC_RX_MODE,
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bits_dis(sc, emac_base + EMAC_REG_EMAC_TX_MODE,
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_bits_en(sc, emac_base + EMAC_REG_EMAC_TX_MODE,
/usr/src/sys/dev/bxe/bxe_link.c:	val = REG_RD(sc, emac_base + EMAC_REG_EMAC_RX_MODE);
/usr/src/sys/dev/bxe/bxe_link.c:	val = REG_RD(sc, emac_base + EMAC_REG_EMAC_MODE);
/usr/src/sys/dev/bxe/bxe_link.c:	vars->mac_type = MAC_TYPE_EMAC;
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t bmac_addr, wb_data[2], val;
/usr/src/sys/dev/bxe/bxe_link.c:	bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_BMAC_XGXS_CONTROL, wb_data,
/usr/src/sys/dev/bxe/bxe_link.c:	wb_data[0] = ((params->mac_addr[2] << 24) |
/usr/src/sys/dev/bxe/bxe_link.c:	    (params->mac_addr[3] << 16) | (params->mac_addr[4] << 8) |
/usr/src/sys/dev/bxe/bxe_link.c:	    params->mac_addr[5]);
/usr/src/sys/dev/bxe/bxe_link.c:	wb_data[1] = ((params->mac_addr[0] << 8) | params->mac_addr[1]);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_TX_SOURCE_ADDR, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_TX_CONTROL, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_RX_MAX_SIZE, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_RX_CONTROL, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_TX_MAX_SIZE,
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_CNT_MAX_SIZE, wb_data, 2);
/usr/src/sys/dev/bxe/bxe_link.c:	REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_RX_LLFC_MSG_FLDS, wb_data,
/usr/src/sys/dev/bxe/bxe_link.c:bxe_bmac_enable(struct link_params *params, struct link_vars *vars,
/usr/src/sys/dev/bxe/bxe_link.c:	vars->mac_type = MAC_TYPE_BMAC;
/usr/src/sys/dev/bxe/bxe_link.c:			vars->mac_type = MAC_TYPE_BMAC;
/usr/src/sys/dev/bxe/bxe_link.c:			vars->mac_type = MAC_TYPE_EMAC;
/usr/src/sys/dev/bxe/bxe_link.c:		vars->mac_type = MAC_TYPE_NONE;
/usr/src/sys/dev/bxe/bxe_link.c:bxe_bmac_rx_disable(struct bxe_softc *sc, uint32_t chip_id, uint8_t port)
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t bmac_addr, wb_data[2];
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t nig_bmac_enable;
/usr/src/sys/dev/bxe/bxe_link.c:	bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :
/usr/src/sys/dev/bxe/bxe_link.c:	nig_bmac_enable = REG_RD(sc, NIG_REG_BMAC0_REGS_OUT_EN + port * 4);
/usr/src/sys/dev/bxe/bxe_link.c:	    (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port) && nig_bmac_enable) {
/usr/src/sys/dev/bxe/bxe_link.c:		REG_RD_DMAE(sc, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL,
/usr/src/sys/dev/bxe/bxe_link.c:		REG_WR_DMAE(sc, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL,
/usr/src/sys/dev/bxe/bxe_link.c:bxe_get_emac_base(struct bxe_softc *sc, uint32_t ext_phy_type, uint8_t port)
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base;
/usr/src/sys/dev/bxe/bxe_link.c:			emac_base = GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:			emac_base = GRCBASE_EMAC1;
/usr/src/sys/dev/bxe/bxe_link.c:		emac_base = (port) ? GRCBASE_EMAC0 : GRCBASE_EMAC1;
/usr/src/sys/dev/bxe/bxe_link.c:		emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:	return (emac_base);
/usr/src/sys/dev/bxe/bxe_link.c:	mdio_ctrl = bxe_get_emac_base(sc, ext_phy_type, port);
/usr/src/sys/dev/bxe/bxe_link.c:	mdio_ctrl = bxe_get_emac_base(sc, ext_phy_type, port);
/usr/src/sys/dev/bxe/bxe_link.c:		vars->mac_type = MAC_TYPE_NONE;
/usr/src/sys/dev/bxe/bxe_link.c:bxe_emac_program(struct link_params *params, uint32_t line_speed,
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base;
/usr/src/sys/dev/bxe/bxe_link.c:	emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:		reg_val = REG_RD(sc, emac_base + EMAC_REG_EMAC_LED);
/usr/src/sys/dev/bxe/bxe_link.c:		REG_WR(sc, emac_base + EMAC_REG_EMAC_LED, reg_val);
/usr/src/sys/dev/bxe/bxe_link.c:		reg_val = REG_RD(sc, emac_base + EMAC_REG_EMAC_LED);
/usr/src/sys/dev/bxe/bxe_link.c:		REG_WR(sc, emac_base + EMAC_REG_EMAC_LED, reg_val);
/usr/src/sys/dev/bxe/bxe_link.c:		reg_val = REG_RD(sc, emac_base + EMAC_REG_EMAC_LED);
/usr/src/sys/dev/bxe/bxe_link.c:		REG_WR(sc, emac_base + EMAC_REG_EMAC_LED, reg_val);
/usr/src/sys/dev/bxe/bxe_link.c:		reg_val = REG_RD(sc, emac_base + EMAC_REG_EMAC_LED);
/usr/src/sys/dev/bxe/bxe_link.c:		REG_WR(sc, emac_base + EMAC_REG_EMAC_LED, reg_val);
/usr/src/sys/dev/bxe/bxe_link.c:			reg_val = REG_RD(sc, emac_base + EMAC_REG_EMAC_LED);
/usr/src/sys/dev/bxe/bxe_link.c:			REG_WR(sc, emac_base + EMAC_REG_EMAC_LED, reg_val);
/usr/src/sys/dev/bxe/bxe_link.c:	uint32_t emac_base, ext_phy_type, tmp;
/usr/src/sys/dev/bxe/bxe_link.c:	emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
/usr/src/sys/dev/bxe/bxe_link.c:	vars->mac_type = MAC_TYPE_NONE;
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_emac_init(params, vars);
/usr/src/sys/dev/bxe/bxe_link.c:		vars->mac_type = MAC_TYPE_BMAC;
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_bmac_enable(params, vars, 1);
/usr/src/sys/dev/bxe/bxe_link.c:		vars->mac_type = MAC_TYPE_EMAC;
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_emac_enable(params, vars, 1);
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_emac_program(params, vars->line_speed, vars->duplex);
/usr/src/sys/dev/bxe/bxe_link.c:		vars->mac_type = MAC_TYPE_BMAC;
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_bmac_enable(params, vars, 0);
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bmac_rx_disable(sc, params->chip_id, port);
/usr/src/sys/dev/bxe/bxe_link.c:	vars->mac_type = MAC_TYPE_NONE;
/usr/src/sys/dev/bxe/bxe_link.c:	bxe_bmac_rx_disable(sc, params->chip_id, params->port);
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_bmac_enable(params, vars, 0);
/usr/src/sys/dev/bxe/bxe_link.c:		rc = bxe_emac_program(params, vars->line_speed, vars->duplex);
/usr/src/sys/dev/bxe/bxe_link.c:		bxe_emac_enable(params, vars, 0);
/usr/src/sys/dev/bxe/if_bxe.c:static void bxe_stats_bmac_update(struct bxe_softc *);
/usr/src/sys/dev/bxe/if_bxe.c:static void bxe_stats_emac_update(struct bxe_softc *);
/usr/src/sys/dev/bxe/if_bxe.c:static void bxe_set_mac_addr_e1(struct bxe_softc *, int);
/usr/src/sys/dev/bxe/if_bxe.c:static void bxe_set_mac_addr_e1h(struct bxe_softc *, int);
/usr/src/sys/dev/bxe/if_bxe.c:	ether_ifattach(ifp, sc->link_params.mac_addr);
/usr/src/sys/dev/bxe/if_bxe.c:	uint32_t mac_hi, mac_lo, val;
/usr/src/sys/dev/bxe/if_bxe.c:		mac_hi = SHMEM_RD(sc, mf_cfg.func_mf_config[func].mac_upper);
/usr/src/sys/dev/bxe/if_bxe.c:		mac_lo = SHMEM_RD(sc, mf_cfg.func_mf_config[func].mac_lower);
/usr/src/sys/dev/bxe/if_bxe.c:		if ((mac_lo == 0) && (mac_hi == 0)) {
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[0] = (u_char)(mac_hi >> 8);
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[1] = (u_char)(mac_hi);
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[2] = (u_char)(mac_lo >> 24);
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[3] = (u_char)(mac_lo >> 16);
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[4] = (u_char)(mac_lo >> 8);
/usr/src/sys/dev/bxe/if_bxe.c:			sc->link_params.mac_addr[5] = (u_char)(mac_lo);
/usr/src/sys/dev/bxe/if_bxe.c:	uint32_t val, mac_hi, mac_lo;
/usr/src/sys/dev/bxe/if_bxe.c:	mac_hi = SHMEM_RD(sc, dev_info.port_hw_config[port].mac_upper);
/usr/src/sys/dev/bxe/if_bxe.c:	mac_lo = SHMEM_RD(sc, dev_info.port_hw_config[port].mac_lower);
/usr/src/sys/dev/bxe/if_bxe.c:	if (mac_lo == 0 && mac_hi == 0) {
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[0] = (u_char)(mac_hi >> 8);
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[1] = (u_char)(mac_hi);
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[2] = (u_char)(mac_lo >> 24);
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[3] = (u_char)(mac_lo >> 16);
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[4] = (u_char)(mac_lo >> 8);
/usr/src/sys/dev/bxe/if_bxe.c:		sc->link_params.mac_addr[5] = (u_char)(mac_lo);
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_cmd *config;
/usr/src/sys/dev/bxe/if_bxe.c:	uint32_t emac_base, val;
/usr/src/sys/dev/bxe/if_bxe.c:	uint8_t entry, *mac_addr;
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_set_mac_addr_e1(sc, 0);
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_set_mac_addr_e1h(sc, 0);
/usr/src/sys/dev/bxe/if_bxe.c:		emac_base = BP_PORT(sc) ?  GRCBASE_EMAC0 : GRCBASE_EMAC1;
/usr/src/sys/dev/bxe/if_bxe.c:		mac_addr = sc->link_params.mac_addr;
/usr/src/sys/dev/bxe/if_bxe.c:		val = (mac_addr[0] << 8) | mac_addr[1];
/usr/src/sys/dev/bxe/if_bxe.c:		val = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
/usr/src/sys/dev/bxe/if_bxe.c:		    (mac_addr[4] << 8) | mac_addr[5];
/usr/src/sys/dev/bxe/if_bxe.c:	bcopy(IF_LLADDR(sc->bxe_ifp), sc->link_params.mac_addr, ETHER_ADDR_LEN);
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_set_mac_addr_e1(sc, 1);
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_set_mac_addr_e1h(sc, 1);
/usr/src/sys/dev/bxe/if_bxe.c:		if (sc->link_vars.mac_type == MAC_TYPE_BMAC) {
/usr/src/sys/dev/bxe/if_bxe.c:			memset(&(pstats->mac_stx[0]), 0,
/usr/src/sys/dev/bxe/if_bxe.c:			    sizeof(struct mac_stx));
/usr/src/sys/dev/bxe/if_bxe.c:	sc->spq_prod_bd->data.mac_config_addr.hi = htole32(data_hi);
/usr/src/sys/dev/bxe/if_bxe.c:	sc->spq_prod_bd->data.mac_config_addr.lo = htole32(data_lo);
/usr/src/sys/dev/bxe/if_bxe.c:	DIFF_64(diff.hi, new->s##_hi, pstats->mac_stx[0].t##_hi,\
/usr/src/sys/dev/bxe/if_bxe.c:	    diff.lo, new->s##_lo, pstats->mac_stx[0].t##_lo);	\
/usr/src/sys/dev/bxe/if_bxe.c:	pstats->mac_stx[0].t##_hi = new->s##_hi;		\
/usr/src/sys/dev/bxe/if_bxe.c:	pstats->mac_stx[0].t##_lo = new->s##_lo;		\
/usr/src/sys/dev/bxe/if_bxe.c:	ADD_64(pstats->mac_stx[1].t##_hi, diff.hi,		\
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].t##_lo, diff.lo);		\
/usr/src/sys/dev/bxe/if_bxe.c:	ADD_EXTEND_64(pstats->mac_stx[1].s##_hi,		\
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].s##_lo, new->s);			\
/usr/src/sys/dev/bxe/if_bxe.c:	    &(sc->port.old_nig_stats.egress_mac_pkt0_lo), 2);
/usr/src/sys/dev/bxe/if_bxe.c:	    &(sc->port.old_nig_stats.egress_mac_pkt1_lo), 2);
/usr/src/sys/dev/bxe/if_bxe.c:	uint32_t mac_addr, opcode, *stats_comp;
/usr/src/sys/dev/bxe/if_bxe.c:	if (sc->link_vars.mac_type == MAC_TYPE_BMAC) {
/usr/src/sys/dev/bxe/if_bxe.c:		mac_addr = (port ? NIG_REG_INGRESS_BMAC1_MEM :
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->src_addr_lo = (mac_addr +
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_lo = U64_LO(BXE_SP_MAPPING(sc, mac_stats));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_hi = U64_HI(BXE_SP_MAPPING(sc, mac_stats));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->src_addr_lo = (mac_addr +
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_lo = U64_LO(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct bmac_stats, rx_stat_gr64_lo));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_hi = U64_HI(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct bmac_stats, rx_stat_gr64_lo));
/usr/src/sys/dev/bxe/if_bxe.c:	} else if (sc->link_vars.mac_type == MAC_TYPE_EMAC) {
/usr/src/sys/dev/bxe/if_bxe.c:		mac_addr = (port ? GRCBASE_EMAC1 : GRCBASE_EMAC0);
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->src_addr_lo = (mac_addr + EMAC_REG_EMAC_RX_STAT_AC) >> 2;
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_lo = U64_LO(BXE_SP_MAPPING(sc, mac_stats));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_hi = U64_HI(BXE_SP_MAPPING(sc, mac_stats));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->src_addr_lo = (mac_addr +
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_lo = U64_LO(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct emac_stats, rx_stat_falsecarriererrors));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_hi = U64_HI(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct emac_stats, rx_stat_falsecarriererrors));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->src_addr_lo = (mac_addr + EMAC_REG_EMAC_TX_STAT_AC) >> 2;
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_lo = U64_LO(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct emac_stats, tx_stat_ifhcoutoctets));
/usr/src/sys/dev/bxe/if_bxe.c:		dmae->dst_addr_hi = U64_HI(BXE_SP_MAPPING(sc, mac_stats) +
/usr/src/sys/dev/bxe/if_bxe.c:		    offsetof(struct emac_stats, tx_stat_ifhcoutoctets));
/usr/src/sys/dev/bxe/if_bxe.c:	    offsetof(struct nig_stats, egress_mac_pkt0_lo));
/usr/src/sys/dev/bxe/if_bxe.c:	    offsetof(struct nig_stats, egress_mac_pkt0_lo));
/usr/src/sys/dev/bxe/if_bxe.c:	    offsetof(struct nig_stats, egress_mac_pkt1_lo));
/usr/src/sys/dev/bxe/if_bxe.c:	    offsetof(struct nig_stats, egress_mac_pkt1_lo));
/usr/src/sys/dev/bxe/if_bxe.c:bxe_stats_bmac_update(struct bxe_softc *sc)
/usr/src/sys/dev/bxe/if_bxe.c:	struct bmac_stats *new;
/usr/src/sys/dev/bxe/if_bxe.c:	new = BXE_SP(sc, mac_stats.bmac_stats);
/usr/src/sys/dev/bxe/if_bxe.c:	    rx_stat_bmac_xpf);
/usr/src/sys/dev/bxe/if_bxe.c:	    tx_stat_bmac_2047);
/usr/src/sys/dev/bxe/if_bxe.c:	    tx_stat_bmac_4095);
/usr/src/sys/dev/bxe/if_bxe.c:	    tx_stat_bmac_9216);
/usr/src/sys/dev/bxe/if_bxe.c:	    tx_stat_bmac_16383);
/usr/src/sys/dev/bxe/if_bxe.c:	    tx_stat_bmac_ufl);
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_bmac_xpf_hi;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_bmac_xpf_lo;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxoffsent_hi;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxoffsent_lo;
/usr/src/sys/dev/bxe/if_bxe.c:bxe_stats_emac_update(struct bxe_softc *sc)
/usr/src/sys/dev/bxe/if_bxe.c:	struct emac_stats *new;
/usr/src/sys/dev/bxe/if_bxe.c:	new = BXE_SP(sc, mac_stats.emac_stats);
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_xonpauseframesreceived_hi;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_xonpauseframesreceived_lo;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_xoffpauseframesreceived_hi,
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].rx_stat_xoffpauseframesreceived_lo);
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxonsent_hi;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxonsent_lo;
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxoffsent_hi,
/usr/src/sys/dev/bxe/if_bxe.c:	    pstats->mac_stx[1].tx_stat_outxoffsent_lo);
/usr/src/sys/dev/bxe/if_bxe.c:	if (sc->link_vars.mac_type == MAC_TYPE_BMAC)
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_stats_bmac_update(sc);
/usr/src/sys/dev/bxe/if_bxe.c:	else if (sc->link_vars.mac_type == MAC_TYPE_EMAC)
/usr/src/sys/dev/bxe/if_bxe.c:		bxe_stats_emac_update(sc);
/usr/src/sys/dev/bxe/if_bxe.c:	UPDATE_STAT64_NIG(egress_mac_pkt0,
/usr/src/sys/dev/bxe/if_bxe.c:	UPDATE_STAT64_NIG(egress_mac_pkt1, etherstatspktsover1522octets);
/usr/src/sys/dev/bxe/if_bxe.c:	memcpy(&(estats->rx_stat_ifhcinbadoctets_hi), &(pstats->mac_stx[1]),
/usr/src/sys/dev/bxe/if_bxe.c:	    sizeof(struct mac_stx));
/usr/src/sys/dev/bxe/if_bxe.c:		estats->mac_filter_discard =
/usr/src/sys/dev/bxe/if_bxe.c:		    le32toh(tport->mac_filter_discard);
/usr/src/sys/dev/bxe/if_bxe.c:		estats->mac_discard = le32toh(tport->mac_discard);
/usr/src/sys/dev/bxe/if_bxe.c:	    (u_long) estats->mac_discard +
/usr/src/sys/dev/bxe/if_bxe.c:	uint8_t mac_type;
/usr/src/sys/dev/bxe/if_bxe.c:	mac_type = UNICAST_ADDRESS;
/usr/src/sys/dev/bxe/if_bxe.c:		mac_type = BROADCAST_ADDRESS;
/usr/src/sys/dev/bxe/if_bxe.c:		mac_type = MULTICAST_ADDRESS;
/usr/src/sys/dev/bxe/if_bxe.c:		(mac_type << ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT);
/usr/src/sys/dev/bxe/if_bxe.c:	sc->set_mac_pending = 0;
/usr/src/sys/dev/bxe/if_bxe.c:	struct tstorm_eth_mac_filter_config tstorm_mac_filter = {0};
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.ucast_drop_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.mcast_drop_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.bcast_drop_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.bcast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.mcast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.bcast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.ucast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.mcast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:		tstorm_mac_filter.bcast_accept_all = mask;
/usr/src/sys/dev/bxe/if_bxe.c:	for (i = 0; i < sizeof(struct tstorm_eth_mac_filter_config) / 4; i++)
/usr/src/sys/dev/bxe/if_bxe.c:		    ((uint32_t *) &tstorm_mac_filter)[i]);
/usr/src/sys/dev/bxe/if_bxe.c:bxe_set_mac_addr_e1(struct bxe_softc *sc, int set)
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_cmd *config;
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_entry *config_table;
/usr/src/sys/dev/bxe/if_bxe.c:	config = BXE_SP(sc, mac_config);
/usr/src/sys/dev/bxe/if_bxe.c:	eaddr = sc->link_params.mac_addr;
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.msb_mac_addr = eaddr[0] << 8 | eaddr[1];
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.middle_mac_addr = eaddr[2] << 8 | eaddr[3];
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.lsb_mac_addr = eaddr[4] << 8 | eaddr[5];
/usr/src/sys/dev/bxe/if_bxe.c:	   config_table->cam_entry.msb_mac_addr,
/usr/src/sys/dev/bxe/if_bxe.c:	   config_table->cam_entry.middle_mac_addr,
/usr/src/sys/dev/bxe/if_bxe.c:	   config_table->cam_entry.lsb_mac_addr);
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.msb_mac_addr = 0xffff;
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.middle_mac_addr = 0xffff;
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->cam_entry.lsb_mac_addr = 0xffff;
/usr/src/sys/dev/bxe/if_bxe.c:	    U64_HI(BXE_SP_MAPPING(sc, mac_config)),
/usr/src/sys/dev/bxe/if_bxe.c:	    U64_LO(BXE_SP_MAPPING(sc, mac_config)), 0);
/usr/src/sys/dev/bxe/if_bxe.c:bxe_set_mac_addr_e1h(struct bxe_softc *sc, int set)
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_cmd_e1h *config;
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_entry_e1h *config_table;
/usr/src/sys/dev/bxe/if_bxe.c:	config = (struct mac_configuration_cmd_e1h *)BXE_SP(sc, mac_config);
/usr/src/sys/dev/bxe/if_bxe.c:		goto bxe_set_mac_addr_e1h_exit;
/usr/src/sys/dev/bxe/if_bxe.c:	eaddr = sc->link_params.mac_addr;
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->msb_mac_addr = eaddr[0] << 8 | eaddr[1];
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->middle_mac_addr = eaddr[2] << 8 | eaddr[3];
/usr/src/sys/dev/bxe/if_bxe.c:	config_table->lsb_mac_addr = eaddr[4] << 8 | eaddr[5];
/usr/src/sys/dev/bxe/if_bxe.c:	    config_table->msb_mac_addr, config_table->middle_mac_addr,
/usr/src/sys/dev/bxe/if_bxe.c:	    config_table->lsb_mac_addr, sc->e1hov, BP_L_ID(sc));
/usr/src/sys/dev/bxe/if_bxe.c:	    U64_HI(BXE_SP_MAPPING(sc, mac_config)),
/usr/src/sys/dev/bxe/if_bxe.c:	    U64_LO(BXE_SP_MAPPING(sc, mac_config)), 0);
/usr/src/sys/dev/bxe/if_bxe.c:bxe_set_mac_addr_e1h_exit:
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_cmd *config;
/usr/src/sys/dev/bxe/if_bxe.c:	struct mac_configuration_entry *config_table;
/usr/src/sys/dev/bxe/if_bxe.c:				config_table->cam_entry.msb_mac_addr =
/usr/src/sys/dev/bxe/if_bxe.c:				config_table->cam_entry.middle_mac_addr =
/usr/src/sys/dev/bxe/if_bxe.c:				config_table->cam_entry.lsb_mac_addr =
/usr/src/sys/dev/bxe/if_bxe.c:				    config_table->cam_entry.msb_mac_addr,
/usr/src/sys/dev/bxe/if_bxe.c:				    config_table->cam_entry.middle_mac_addr,
/usr/src/sys/dev/bxe/if_bxe.c:				    config_table->cam_entry.lsb_mac_addr);
/usr/src/sys/dev/bxe/if_bxe.c:	switch (sc->link_vars.mac_type) {
/usr/src/sys/dev/bxe/if_bxe.c:	printf(" - (link_vars->mac_type)\n");
/usr/src/sys/dev/cas/if_cas.c:	sc->sc_mac_rxcfg = v;
/usr/src/sys/dev/cas/if_cas.c:	rxcfg = sc->sc_mac_rxcfg;
/usr/src/sys/dev/cas/if_cas.c:	sc->sc_mac_rxcfg = rxcfg;
/usr/src/sys/dev/cas/if_cas.c:	v = sc->sc_mac_rxcfg & ~(CAS_MAC_RX_CONF_HFILTER |
/usr/src/sys/dev/cas/if_cas.c:	sc->sc_mac_rxcfg = v;
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_src:  0x%08X\n", cshd->cshd_mac_src);
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_dst:  0x%08X\n", cshd->cshd_mac_dst);
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_dlen: 0x%08X\n", cshd->cshd_mac_dlen);
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_tlen: 0x%08X\n", cshd->cshd_mac_total_dlen);
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_iv_i: 0x%08X\n", cshd->cshd_mac_iv_in);
/usr/src/sys/dev/cesa/cesa.c:	device_printf(dev, "\t\tm_iv_o: 0x%08X\n", cshd->cshd_mac_iv_out);
/usr/src/sys/dev/cesa/cesa.c:	csd->csd_cshd->cshd_mac_dst = CESA_SA_DATA(csd_hash);
/usr/src/sys/dev/cesa/cesa.c:	csd->csd_cshd->cshd_mac_iv_in = CESA_SA_DATA(csd_hiv_in);
/usr/src/sys/dev/cesa/cesa.c:	csd->csd_cshd->cshd_mac_iv_out = CESA_SA_DATA(csd_hiv_out);
/usr/src/sys/dev/cesa/cesa.c:	csd->csd_cshd->cshd_mac_src = 0;
/usr/src/sys/dev/cesa/cesa.c:	csd->csd_cshd->cshd_mac_dlen = 0;
/usr/src/sys/dev/cesa/cesa.c:				csd->csd_cshd->cshd_mac_total_dlen = tmlen;
/usr/src/sys/dev/cesa/cesa.c:					csd->csd_cshd->cshd_mac_src =
/usr/src/sys/dev/cesa/cesa.c:					csd->csd_cshd->cshd_mac_dlen =
/usr/src/sys/dev/cesa/cesa.c:				mlen -= csd->csd_cshd->cshd_mac_dlen;
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:	t3_mac_disable_exact_filters(mac);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:	t3_mac_enable_exact_filters(mac);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		t3_mac_set_speed_duplex_fc(mac, speed, duplex, fc);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		t3_mac_enable(mac, MAC_DIRECTION_TX | MAC_DIRECTION_RX);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:			t3_mac_disable(mac, MAC_DIRECTION_RX);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:			t3_mac_set_speed_duplex_fc(mac, lc->speed, lc->duplex,
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		t3_mac_set_speed_duplex_fc(mac, -1, -1, fc);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:static int mac_intr_handler(adapter_t *adap, unsigned int idx)
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		mac_intr_handler(adapter, 0);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		mac_intr_handler(adapter, 1);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		t3_mac_init(&adap2pinfo(adapter, 0)->mac);
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:void mac_prep(struct cmac *mac, adapter_t *adapter, int index)
/usr/src/sys/dev/cxgb/common/cxgb_t3_hw.c:		mac_prep(&p->mac, adapter, j);
/usr/src/sys/dev/cxgb/common/cxgb_vsc7323.c:const struct mac_stats *t3_vsc7323_update_stats(struct cmac *mac)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_init - initialize a MAC
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_init(struct cmac *mac)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:	static struct addr_val_pair mac_reset_avp[] = {
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:	t3_write_regs(adap, mac_reset_avp, ARRAY_SIZE(mac_reset_avp), oft);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:static int t3_mac_reset(struct cmac *mac, int portspeed)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:		t3_mac_init(mac);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_set_address - set one of the station's unicast MAC addresses
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_set_address(struct cmac *mac, unsigned int idx, u8 addr[6])
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_set_num_ucast - set the number of unicast addresses needed
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_set_num_ucast(struct cmac *mac, unsigned char n)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:void t3_mac_disable_exact_filters(struct cmac *mac)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:void t3_mac_enable_exact_filters(struct cmac *mac)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_set_rx_mode - set the Rx mode and address filters
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_set_rx_mode(struct cmac *mac, struct t3_rx_mode *rm)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_set_mtu - set the MAC MTU
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_set_mtu(struct cmac *mac, unsigned int mtu)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:		t3_mac_disable_exact_filters(mac);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:			t3_mac_enable_exact_filters(mac);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:		t3_mac_enable_exact_filters(mac);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_set_speed_duplex_fc - set MAC speed, duplex and flow control
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex, int fc)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:				t3_mac_reset(mac, val);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_enable - enable the MAC in the given directions
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_enable(struct cmac *mac, int which)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:	struct mac_stats *s = &mac->stats;
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_disable - disable the MAC in the given directions
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3_mac_disable(struct cmac *mac, int which)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:int t3b2_mac_watchdog_task(struct cmac *mac)
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:	struct mac_stats *s = &mac->stats;
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:		t3_mac_reset(mac, -1);
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c: *	t3_mac_update_stats - accumulate MAC statistics
/usr/src/sys/dev/cxgb/common/cxgb_xgmac.c:const struct mac_stats *t3_mac_update_stats(struct cmac *mac)
/usr/src/sys/dev/cxgb/cxgb_main.c:static void cxgb_update_mac_settings(struct port_info *p);
/usr/src/sys/dev/cxgb/cxgb_main.c:	u32 mac_hit:1;
/usr/src/sys/dev/cxgb/cxgb_main.c:	u32 mac_idx:4;
/usr/src/sys/dev/cxgb/cxgb_main.c:	u32 mac_vld:1;
/usr/src/sys/dev/cxgb/cxgb_main.c:     int duplex, int fc, int mac_was_reset)
/usr/src/sys/dev/cxgb/cxgb_main.c:	if (mac_was_reset) {
/usr/src/sys/dev/cxgb/cxgb_main.c:		cxgb_update_mac_settings(pi);
/usr/src/sys/dev/cxgb/cxgb_main.c:cxgb_update_mac_settings(struct port_info *p)
/usr/src/sys/dev/cxgb/cxgb_main.c:	t3_mac_set_mtu(mac, mtu);
/usr/src/sys/dev/cxgb/cxgb_main.c:	t3_mac_set_address(mac, 0, p->hw_addr);
/usr/src/sys/dev/cxgb/cxgb_main.c:	t3_mac_set_rx_mode(mac, &rm);
/usr/src/sys/dev/cxgb/cxgb_main.c:		t3_mac_init(mac);
/usr/src/sys/dev/cxgb/cxgb_main.c:	cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:	t3_mac_enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);
/usr/src/sys/dev/cxgb/cxgb_main.c:	t3_mac_disable(&pi->mac, MAC_DIRECTION_RX);
/usr/src/sys/dev/cxgb/cxgb_main.c:			cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:					cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:			cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:				cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:				cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:		status = t3b2_mac_watchdog_task(&p->mac);
/usr/src/sys/dev/cxgb/cxgb_main.c:			cxgb_update_mac_settings(p);
/usr/src/sys/dev/cxgb/cxgb_main.c:			t3_mac_enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);
/usr/src/sys/dev/cxgb/cxgb_main.c:		struct mac_stats *mstats = &mac->stats;
/usr/src/sys/dev/cxgb/cxgb_main.c:		t3_mac_update_stats(mac);
/usr/src/sys/dev/cxgb/cxgb_main.c:		    mstats->tx_mac_internal_errs +
/usr/src/sys/dev/cxgb/cxgb_main.c:		    mstats->rx_mac_internal_errs +
/usr/src/sys/dev/cxgb/cxgb_main.c:		t3_mac_update_stats(&pi->mac);
/usr/src/sys/dev/cxgb/cxgb_main.c:		    (f->mac_addr_idx != 0xffff && f->mac_addr_idx > 15) ||
/usr/src/sys/dev/cxgb/cxgb_main.c:		p->mac_hit = f->mac_hit;
/usr/src/sys/dev/cxgb/cxgb_main.c:		p->mac_vld = f->mac_addr_idx != 0xffff;
/usr/src/sys/dev/cxgb/cxgb_main.c:		p->mac_idx = f->mac_addr_idx;
/usr/src/sys/dev/cxgb/cxgb_main.c:			f->mac_hit = p->mac_hit;
/usr/src/sys/dev/cxgb/cxgb_main.c:			f->mac_addr_idx = p->mac_vld ? p->mac_idx : 0xffff;
/usr/src/sys/dev/cxgb/cxgb_main.c:	oreq->opt1 = htonl(V_MAC_MATCH_VALID(f->mac_vld) |
/usr/src/sys/dev/cxgb/cxgb_main.c:			 V_MAC_MATCH(f->mac_idx | (f->mac_hit << 4)));
/usr/src/sys/dev/cxgb/cxgb_sge.c:	t3_mac_update_stats(&p->mac);
/usr/src/sys/dev/cxgb/cxgb_sge.c:		struct mac_stats *mstats = &pi->mac.stats;
/usr/src/sys/dev/cxgb/cxgb_sge.c:		poid = SYSCTL_ADD_NODE(ctx, poidlist, OID_AUTO, "mac_stats",
/usr/src/sys/dev/cxgb/cxgb_sge.c:		 * requested counter from hardware, but t3_mac_update_stats()
/usr/src/sys/dev/cxgb/cxgb_sge.c:    (CTLTYPE_U64 | CTLFLAG_RD), pi, offsetof(struct mac_stats, a), \
/usr/src/sys/dev/cxgb/cxgb_sge.c:		CXGB_SYSCTL_ADD_QUAD(tx_mac_internal_errs);
/usr/src/sys/dev/cxgb/cxgb_sge.c:		CXGB_SYSCTL_ADD_QUAD(rx_mac_internal_errs);
/usr/src/sys/dev/cxgbe/common/t4_hw.c:static void xgmac_intr_handler(struct adapter *adap, int port)
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		xgmac_intr_handler(adapter, 0);
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		xgmac_intr_handler(adapter, 1);
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		xgmac_intr_handler(adapter, 2);
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		xgmac_intr_handler(adapter, 3);
/usr/src/sys/dev/cxgbe/common/t4_hw.c: *	hash_mac_addr - return the hash value of a MAC address
/usr/src/sys/dev/cxgbe/common/t4_hw.c:static int hash_mac_addr(const u8 *addr)
/usr/src/sys/dev/cxgbe/common/t4_hw.c: *	t4_alloc_mac_filt - allocates exact-match filters for MAC addresses
/usr/src/sys/dev/cxgbe/common/t4_hw.c:int t4_alloc_mac_filt(struct adapter *adap, unsigned int mbox,
/usr/src/sys/dev/cxgbe/common/t4_hw.c:	struct fw_vi_mac_cmd c;
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		size_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		struct fw_vi_mac_exact *p;
/usr/src/sys/dev/cxgbe/common/t4_hw.c:				*hash |= (1ULL << hash_mac_addr(addr[offset+i]));
/usr/src/sys/dev/cxgbe/common/t4_hw.c:	struct fw_vi_mac_cmd c;
/usr/src/sys/dev/cxgbe/common/t4_hw.c:	struct fw_vi_mac_exact *p = c.u.exact;
/usr/src/sys/dev/cxgbe/common/t4_hw.c:	unsigned int max_mac_addr = is_t4(adap) ?
/usr/src/sys/dev/cxgbe/common/t4_hw.c:		if (ret >= max_mac_addr)
/usr/src/sys/dev/cxgbe/common/t4_hw.c:	struct fw_vi_mac_cmd c;
/usr/src/sys/dev/cxgbe/t4_main.c:static int update_mac_settings(struct port_info *, int);
/usr/src/sys/dev/cxgbe/t4_main.c:				rc = update_mac_settings(pi, XGMAC_MTU);
/usr/src/sys/dev/cxgbe/t4_main.c:					rc = update_mac_settings(pi,
/usr/src/sys/dev/cxgbe/t4_main.c:			rc = update_mac_settings(pi, XGMAC_MCADDRS);
/usr/src/sys/dev/cxgbe/t4_main.c:				rc = update_mac_settings(pi, XGMAC_VLANEX);
/usr/src/sys/dev/cxgbe/t4_main.c:update_mac_settings(struct port_info *pi, int flags)
/usr/src/sys/dev/cxgbe/t4_main.c:				rc = t4_alloc_mac_filt(sc, sc->mbox, pi->viid,
/usr/src/sys/dev/cxgbe/t4_main.c:			rc = t4_alloc_mac_filt(sc, sc->mbox, pi->viid,
/usr/src/sys/dev/cxgbe/t4_main.c:	rc = update_mac_settings(pi, XGMAC_ALL);
/usr/src/sys/dev/cxgbe/t4_main.c:	fwr->smac_sel = 0;
/usr/src/sys/dev/dc/if_dc.c:	int error, mac_offset, n, phy, rid, tmp;
/usr/src/sys/dev/dc/if_dc.c:		dc_read_eeprom(sc, (caddr_t)&mac_offset,
/usr/src/sys/dev/dc/if_dc.c:		dc_read_eeprom(sc, (caddr_t)&eaddr, (mac_offset / 2), 3, 0);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static s32  e1000_init_mac_params_80003es2lan(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static s32  e1000_read_mac_addr_80003es2lan(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c: *  e1000_init_mac_params_80003es2lan - Init ESB2 MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static s32 e1000_init_mac_params_80003es2lan(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	DEBUGFUNC("e1000_init_mac_params_80003es2lan");
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_80003es2lan;
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	hw->mac.ops.init_params = e1000_init_mac_params_80003es2lan;
/usr/src/sys/dev/e1000/e1000_80003es2lan.c: *  e1000_acquire_mac_csr_80003es2lan - Acquire right to access Kumeran register
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static s32 e1000_acquire_mac_csr_80003es2lan(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	DEBUGFUNC("e1000_acquire_mac_csr_80003es2lan");
/usr/src/sys/dev/e1000/e1000_80003es2lan.c: *  e1000_release_mac_csr_80003es2lan - Release right to access Kumeran Register
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static void e1000_release_mac_csr_80003es2lan(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	DEBUGFUNC("e1000_release_mac_csr_80003es2lan");
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	ret_val = e1000_acquire_mac_csr_80003es2lan(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	e1000_release_mac_csr_80003es2lan(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	ret_val = e1000_acquire_mac_csr_80003es2lan(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	e1000_release_mac_csr_80003es2lan(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c: *  e1000_read_mac_addr_80003es2lan - Read device MAC address
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:static s32 e1000_read_mac_addr_80003es2lan(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	DEBUGFUNC("e1000_read_mac_addr_80003es2lan");
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_80003es2lan.c:	ret_val = e1000_read_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82540.c:static s32  e1000_init_mac_params_82540(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82540.c:static s32  e1000_read_mac_addr_82540(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82540.c: * e1000_init_mac_params_82540 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82540.c:static s32 e1000_init_mac_params_82540(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82540.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82540.c:	DEBUGFUNC("e1000_init_mac_params_82540");
/usr/src/sys/dev/e1000/e1000_82540.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82540;
/usr/src/sys/dev/e1000/e1000_82540.c:	hw->mac.ops.init_params = e1000_init_mac_params_82540;
/usr/src/sys/dev/e1000/e1000_82540.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82540.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82540.c: *  e1000_read_mac_addr_82540 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82540.c:s32 e1000_read_mac_addr_82540(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82540.c:	DEBUGFUNC("e1000_read_mac_addr");
/usr/src/sys/dev/e1000/e1000_82541.c:static s32  e1000_init_mac_params_82541(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82541.c:static s32  e1000_read_mac_addr_82541(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82541.c: *  e1000_init_mac_params_82541 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82541.c:static s32 e1000_init_mac_params_82541(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82541.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82541.c:	DEBUGFUNC("e1000_init_mac_params_82541");
/usr/src/sys/dev/e1000/e1000_82541.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82541;
/usr/src/sys/dev/e1000/e1000_82541.c:	hw->mac.ops.init_params = e1000_init_mac_params_82541;
/usr/src/sys/dev/e1000/e1000_82541.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82541.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82541.c: *  e1000_read_mac_addr_82541 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82541.c:static s32 e1000_read_mac_addr_82541(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82541.c:	DEBUGFUNC("e1000_read_mac_addr");
/usr/src/sys/dev/e1000/e1000_82542.c:static s32  e1000_init_mac_params_82542(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82542.c:static s32  e1000_read_mac_addr_82542(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82542.c: *  e1000_init_mac_params_82542 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82542.c:static s32 e1000_init_mac_params_82542(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82542.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82542.c:	DEBUGFUNC("e1000_init_mac_params_82542");
/usr/src/sys/dev/e1000/e1000_82542.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82542;
/usr/src/sys/dev/e1000/e1000_82542.c:	hw->mac.ops.init_params = e1000_init_mac_params_82542;
/usr/src/sys/dev/e1000/e1000_82542.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82542.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82542.c: *  e1000_read_mac_addr_82542 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82542.c:static s32 e1000_read_mac_addr_82542(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82542.c:	DEBUGFUNC("e1000_read_mac_addr");
/usr/src/sys/dev/e1000/e1000_82543.c:static s32  e1000_init_mac_params_82543(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82543.c:static s32  e1000_config_mac_to_phy_82543(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82543.c:static s32  e1000_read_mac_addr_82543(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82543.c: *  e1000_init_mac_params_82543 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82543.c:static s32 e1000_init_mac_params_82543(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82543.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82543.c:	DEBUGFUNC("e1000_init_mac_params_82543");
/usr/src/sys/dev/e1000/e1000_82543.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82543;
/usr/src/sys/dev/e1000/e1000_82543.c:	hw->mac.ops.init_params = e1000_init_mac_params_82543;
/usr/src/sys/dev/e1000/e1000_82543.c: *  @mac_addr: The Ethernet destination address of the frame in question
/usr/src/sys/dev/e1000/e1000_82543.c:                                  u8 *mac_addr, u32 max_frame_size)
/usr/src/sys/dev/e1000/e1000_82543.c:	if ((mac_addr[0] == 0xff) && (mac_addr[1] == 0xff))
/usr/src/sys/dev/e1000/e1000_82543.c:	else if (*mac_addr & 0x01)
/usr/src/sys/dev/e1000/e1000_82543.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82543.c:			ret_val = e1000_config_mac_to_phy_82543(hw);
/usr/src/sys/dev/e1000/e1000_82543.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82543.c:		ret_val = e1000_config_mac_to_phy_82543(hw);
/usr/src/sys/dev/e1000/e1000_82543.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82543.c: *  e1000_config_mac_to_phy_82543 - Configure MAC to PHY settings
/usr/src/sys/dev/e1000/e1000_82543.c:static s32 e1000_config_mac_to_phy_82543(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82543.c:	DEBUGFUNC("e1000_config_mac_to_phy_82543");
/usr/src/sys/dev/e1000/e1000_82543.c: *  e1000_read_mac_addr_82543 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82543.c:s32 e1000_read_mac_addr_82543(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82543.c:	DEBUGFUNC("e1000_read_mac_addr");
/usr/src/sys/dev/e1000/e1000_82571.c:static s32  e1000_read_mac_addr_82571(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82571.c: *  e1000_init_mac_params_82571 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82571.c:static s32 e1000_init_mac_params_82571(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82571.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82571.c:	DEBUGFUNC("e1000_init_mac_params_82571");
/usr/src/sys/dev/e1000/e1000_82571.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82571;
/usr/src/sys/dev/e1000/e1000_82571.c:	hw->mac.ops.init_params = e1000_init_mac_params_82571;
/usr/src/sys/dev/e1000/e1000_82571.c:		ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82571.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82571.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82571.c: *  e1000_read_mac_addr_82571 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82571.c:static s32 e1000_read_mac_addr_82571(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82571.c:	DEBUGFUNC("e1000_read_mac_addr_82571");
/usr/src/sys/dev/e1000/e1000_82571.c:		ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82571.c:	return e1000_read_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82571.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82575.c:static s32  e1000_init_mac_params_82575(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82575.c:static s32  e1000_read_mac_addr_82575(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_82575.c: *  e1000_init_mac_params_82575 - Init MAC func ptrs.
/usr/src/sys/dev/e1000/e1000_82575.c:static s32 e1000_init_mac_params_82575(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82575.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82575.c:	DEBUGFUNC("e1000_init_mac_params_82575");
/usr/src/sys/dev/e1000/e1000_82575.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_82575;
/usr/src/sys/dev/e1000/e1000_82575.c:	hw->mac.ops.init_params = e1000_init_mac_params_82575;
/usr/src/sys/dev/e1000/e1000_82575.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82575.c:	ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82575.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_82575.c:		e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_82575.c: *  e1000_read_mac_addr_82575 - Read device MAC address
/usr/src/sys/dev/e1000/e1000_82575.c:static s32 e1000_read_mac_addr_82575(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_82575.c:	DEBUGFUNC("e1000_read_mac_addr_82575");
/usr/src/sys/dev/e1000/e1000_82575.c:	ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82575.c:	ret_val = e1000_read_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_82575.c:	ret_val = e1000_check_alt_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_api.c: *  e1000_init_mac_params - Initialize MAC function pointers
/usr/src/sys/dev/e1000/e1000_api.c:s32 e1000_init_mac_params(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_api.c:		DEBUGOUT("mac.init_mac_params was NULL\n");
/usr/src/sys/dev/e1000/e1000_api.c: *  e1000_set_mac_type - Sets MAC type
/usr/src/sys/dev/e1000/e1000_api.c:s32 e1000_set_mac_type(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_api.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_api.c:	DEBUGFUNC("e1000_set_mac_type");
/usr/src/sys/dev/e1000/e1000_api.c:	ret_val = e1000_set_mac_type(hw);
/usr/src/sys/dev/e1000/e1000_api.c:	e1000_init_mac_ops_generic(hw);
/usr/src/sys/dev/e1000/e1000_api.c:		ret_val = e1000_init_mac_params(hw);
/usr/src/sys/dev/e1000/e1000_api.c: *  e1000_force_mac_fc - Force MAC flow control
/usr/src/sys/dev/e1000/e1000_api.c:s32 e1000_force_mac_fc(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_api.c:	return e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_api.c: *  e1000_read_mac_addr - Reads MAC address
/usr/src/sys/dev/e1000/e1000_api.c:s32 e1000_read_mac_addr(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_api.c:	if (hw->mac.ops.read_mac_addr)
/usr/src/sys/dev/e1000/e1000_api.c:		return hw->mac.ops.read_mac_addr(hw);
/usr/src/sys/dev/e1000/e1000_api.c:	return e1000_read_mac_addr_generic(hw);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	u32 mac_reg, fwsm = E1000_READ_REG(hw, E1000_FWSM);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:				mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:				mac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:				E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM3);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_FEXTNVM3, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_reg &= ~E1000_CTRL_EXT_FORCE_SMBUS;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_CTRL);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg |= E1000_CTRL_LANPHYPC_OVERRIDE;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~E1000_CTRL_LANPHYPC_VALUE;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_CTRL, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~E1000_CTRL_LANPHYPC_OVERRIDE;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_CTRL, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c: *  e1000_init_mac_params_ich8lan - Initialize MAC function pointers
/usr/src/sys/dev/e1000/e1000_ich8lan.c:static s32 e1000_init_mac_params_ich8lan(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	DEBUGFUNC("e1000_init_mac_params_ich8lan");
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	hw->mac.ops.init_params = e1000_init_mac_params_ich8lan;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	u32 mac_reg;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		if (mac_reg & E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	if (!(mac_reg & E1000_FEXTNVM_SW_CONFIG_ICH8M))
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	mac_reg = E1000_READ_REG(hw, E1000_PHY_CTRL);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		if (mac_reg & E1000_PHY_CTRL_GBE_DISABLE)
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		if (mac_reg & E1000_PHY_CTRL_D0A_LPLU)
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		if (mac_reg & (E1000_PHY_CTRL_GBE_DISABLE |
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		if (mac_reg & (E1000_PHY_CTRL_D0A_LPLU |
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	u32 mac_reg;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_RAL(i));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:					   (u16)(mac_reg & 0xFFFF));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:					   (u16)((mac_reg >> 16) & 0xFFFF));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_RAH(i));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:					   (u16)(mac_reg & 0xFFFF));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:					   (u16)((mac_reg & E1000_RAH_AV)
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	u32 mac_reg;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			u8 mac_addr[ETH_ADDR_LEN] = {0};
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[0] = (addr_low & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[1] = ((addr_low >> 8) & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[2] = ((addr_low >> 16) & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[3] = ((addr_low >> 24) & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[4] = (addr_high & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_addr[5] = ((addr_high >> 8) & 0xFF);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:					e1000_calc_rx_da_crc(mac_addr));
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_FFLT_DBG);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~(1 << 14);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg |= (7 << 15);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_FFLT_DBG, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_RCTL);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg |= E1000_RCTL_SECRC;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_RCTL, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_FFLT_DBG);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~(0xF << 14);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_FFLT_DBG, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_RCTL);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~E1000_RCTL_SECRC;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_RCTL, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	u32 mac_reg;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM4);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		mac_reg &= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_8USEC;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:			mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_16USEC;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:		E1000_WRITE_REG(hw, E1000_FEXTNVM4, mac_reg);
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_ich8lan.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c: *  e1000_init_mac_ops_generic - Initialize MAC function pointers
/usr/src/sys/dev/e1000/e1000_mac.c:void e1000_init_mac_ops_generic(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	DEBUGFUNC("e1000_init_mac_ops_generic");
/usr/src/sys/dev/e1000/e1000_mac.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_generic;
/usr/src/sys/dev/e1000/e1000_mac.c:	mac->ops.clear_hw_cntrs = e1000_null_mac_generic;
/usr/src/sys/dev/e1000/e1000_mac.c:	mac->ops.clear_vfta = e1000_null_mac_generic;
/usr/src/sys/dev/e1000/e1000_mac.c: *  e1000_null_mac_generic - No-op function, return void
/usr/src/sys/dev/e1000/e1000_mac.c:void e1000_null_mac_generic(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_mac.c:	DEBUGFUNC("e1000_null_mac_generic");
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	u8 mac_addr[ETH_ADDR_LEN] = {0};
/usr/src/sys/dev/e1000/e1000_mac.c:		hw->mac.ops.rar_set(hw, mac_addr, i);
/usr/src/sys/dev/e1000/e1000_mac.c: *  e1000_check_alt_mac_addr_generic - Check for alternate MAC addr
/usr/src/sys/dev/e1000/e1000_mac.c:s32 e1000_check_alt_mac_addr_generic(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_mac.c:	u16 offset, nvm_alt_mac_addr_offset, nvm_data;
/usr/src/sys/dev/e1000/e1000_mac.c:	u8 alt_mac_addr[ETH_ADDR_LEN];
/usr/src/sys/dev/e1000/e1000_mac.c:	DEBUGFUNC("e1000_check_alt_mac_addr_generic");
/usr/src/sys/dev/e1000/e1000_mac.c:				   &nvm_alt_mac_addr_offset);
/usr/src/sys/dev/e1000/e1000_mac.c:	if ((nvm_alt_mac_addr_offset == 0xFFFF) ||
/usr/src/sys/dev/e1000/e1000_mac.c:	    (nvm_alt_mac_addr_offset == 0x0000))
/usr/src/sys/dev/e1000/e1000_mac.c:		nvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN1;
/usr/src/sys/dev/e1000/e1000_mac.c:		nvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN2;
/usr/src/sys/dev/e1000/e1000_mac.c:		nvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN3;
/usr/src/sys/dev/e1000/e1000_mac.c:		offset = nvm_alt_mac_addr_offset + (i >> 1);
/usr/src/sys/dev/e1000/e1000_mac.c:		alt_mac_addr[i] = (u8)(nvm_data & 0xFF);
/usr/src/sys/dev/e1000/e1000_mac.c:		alt_mac_addr[i + 1] = (u8)(nvm_data >> 8);
/usr/src/sys/dev/e1000/e1000_mac.c:	if (alt_mac_addr[0] & 0x01) {
/usr/src/sys/dev/e1000/e1000_mac.c:	hw->mac.ops.rar_set(hw, alt_mac_addr, 0);
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c: *  base on the flow control settings in e1000_mac_info.
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c: *  e1000_force_mac_fc_generic - Force the MAC's flow control settings
/usr/src/sys/dev/e1000/e1000_mac.c:s32 e1000_force_mac_fc_generic(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_mac.c:	DEBUGFUNC("e1000_force_mac_fc_generic");
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:			ret_val = e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_mac.c:			ret_val = e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_mac.c:		ret_val = e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_mac.c:		ret_val = e1000_force_mac_fc_generic(hw);
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_mac.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_nvm.c: *  e1000_read_mac_addr_generic - Read device MAC address
/usr/src/sys/dev/e1000/e1000_nvm.c:s32 e1000_read_mac_addr_generic(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_phy.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_vf.c:static s32 e1000_init_mac_params_vf(struct e1000_hw *hw);
/usr/src/sys/dev/e1000/e1000_vf.c:static s32 e1000_read_mac_addr_vf(struct e1000_hw *);
/usr/src/sys/dev/e1000/e1000_vf.c: *  e1000_init_mac_params_vf - Inits MAC params
/usr/src/sys/dev/e1000/e1000_vf.c:static s32 e1000_init_mac_params_vf(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_vf.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/e1000_vf.c:	DEBUGFUNC("e1000_init_mac_params_vf");
/usr/src/sys/dev/e1000/e1000_vf.c:	mac->ops.read_mac_addr = e1000_read_mac_addr_vf;
/usr/src/sys/dev/e1000/e1000_vf.c:	hw->mac.ops.init_params = e1000_init_mac_params_vf;
/usr/src/sys/dev/e1000/e1000_vf.c:		e1000_read_mac_addr_vf(hw);
/usr/src/sys/dev/e1000/e1000_vf.c: *  e1000_read_mac_addr_vf - Read device MAC address
/usr/src/sys/dev/e1000/e1000_vf.c:static s32 e1000_read_mac_addr_vf(struct e1000_hw *hw)
/usr/src/sys/dev/e1000/e1000_vf.c:	struct e1000_mac_info *mac = &hw->mac;
/usr/src/sys/dev/e1000/if_em.c:	if (e1000_read_mac_addr(hw) < 0) {
/usr/src/sys/dev/e1000/if_em.c:	if (e1000_set_mac_type(&adapter->hw)) {
/usr/src/sys/dev/e1000/if_em.c:	stat_node = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "mac_stats", 
/usr/src/sys/dev/e1000/if_em.c:        e1000_force_mac_fc(&adapter->hw);
/usr/src/sys/dev/e1000/if_igb.c:	if (e1000_read_mac_addr(&adapter->hw) < 0) {
/usr/src/sys/dev/e1000/if_igb.c:	e1000_set_mac_type(&adapter->hw);
/usr/src/sys/dev/e1000/if_igb.c:	stat_node = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "mac_stats", 
/usr/src/sys/dev/e1000/if_igb.c:	e1000_force_mac_fc(&adapter->hw);
/usr/src/sys/dev/e1000/if_lem.c:	if (e1000_read_mac_addr(&adapter->hw) < 0) {
/usr/src/sys/dev/e1000/if_lem.c:	if (e1000_set_mac_type(&adapter->hw)) {
/usr/src/sys/dev/e1000/if_lem.c:	stat_node = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "mac_stats", 
/usr/src/sys/dev/et/if_et.c:	uint32_t rxmac_ctrl, pktfilt;
/usr/src/sys/dev/et/if_et.c:	rxmac_ctrl = CSR_READ_4(sc, ET_RXMAC_CTRL);
/usr/src/sys/dev/et/if_et.c:		rxmac_ctrl |= ET_RXMAC_CTRL_NO_PKTFILT;
/usr/src/sys/dev/et/if_et.c:	rxmac_ctrl &= ~ET_RXMAC_CTRL_NO_PKTFILT;
/usr/src/sys/dev/et/if_et.c:	CSR_WRITE_4(sc, ET_RXMAC_CTRL, rxmac_ctrl);
/usr/src/sys/dev/gem/if_gem.c:	sc->sc_mac_rxcfg = v;
/usr/src/sys/dev/gem/if_gem.c:	rxcfg = sc->sc_mac_rxcfg;
/usr/src/sys/dev/gem/if_gem.c:	sc->sc_mac_rxcfg = rxcfg;
/usr/src/sys/dev/gem/if_gem.c:	v = sc->sc_mac_rxcfg & ~GEM_MAC_RX_HASH_FILTER;
/usr/src/sys/dev/gem/if_gem.c:	sc->sc_mac_rxcfg = v;
/usr/src/sys/dev/glxsb/glxsb_hash.c:#include <opencrypto/cryptosoft.h> /* for hmac_ipad_buffer and hmac_opad_buffer */
/usr/src/sys/dev/glxsb/glxsb_hash.c:	axf->Update(ses->ses_ictx, hmac_ipad_buffer, axf->blocksize - klen);
/usr/src/sys/dev/glxsb/glxsb_hash.c:	axf->Update(ses->ses_octx, hmac_opad_buffer, axf->blocksize - klen);
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_md5;
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_sha1;
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_ripemd_160;
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_sha2_256;
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_sha2_384;
/usr/src/sys/dev/glxsb/glxsb_hash.c:		ses->ses_axf = &auth_hash_hmac_sha2_512;
/usr/src/sys/dev/hifn/hifn7751.c:	hifn_mac_command_t *mac_cmd;
/usr/src/sys/dev/hifn/hifn7751.c:		mac_cmd = (hifn_mac_command_t *)buf_pos;
/usr/src/sys/dev/hifn/hifn7751.c:		mac_cmd->source_count = htole16(dlen & 0xffff);
/usr/src/sys/dev/hifn/hifn7751.c:		mac_cmd->masks = htole16(cmd->mac_masks |
/usr/src/sys/dev/hifn/hifn7751.c:		mac_cmd->header_skip = htole16(cmd->maccrd->crd_skip);
/usr/src/sys/dev/hifn/hifn7751.c:		mac_cmd->reserved = 0;
/usr/src/sys/dev/hifn/hifn7751.c:		buf_pos += sizeof(hifn_mac_command_t);
/usr/src/sys/dev/hifn/hifn7751.c:	if (using_mac && cmd->mac_masks & HIFN_MAC_CMD_NEW_KEY) {
/usr/src/sys/dev/hifn/hifn7751.c:			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
/usr/src/sys/dev/hifn/hifn7751.c:			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
/usr/src/sys/dev/hifn/hifn7751.c:			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
/usr/src/sys/dev/hifn/hifn7751.c:			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
/usr/src/sys/dev/hifn/hifn7751.c:			cmd->mac_masks |= HIFN_MAC_CMD_NEW_KEY;
/usr/src/sys/dev/hme/if_hme.c:static int	hme_mac_bitflip(struct hme_softc *, u_int32_t, u_int32_t,
/usr/src/sys/dev/hme/if_hme.c:hme_mac_bitflip(struct hme_softc *sc, u_int32_t reg, u_int32_t val,
/usr/src/sys/dev/hme/if_hme.c:	if (!hme_mac_bitflip(sc, HME_MACI_TXCFG, txcfg,
/usr/src/sys/dev/hme/if_hme.c:	if (!hme_mac_bitflip(sc, HME_MACI_RXCFG, rxcfg,
/usr/src/sys/dev/hme/if_hme.c:		if (!hme_mac_bitflip(sc, HME_MACI_TXCFG, txcfg, 0,
/usr/src/sys/dev/hme/if_hme.c:		if (!hme_mac_bitflip(sc, HME_MACI_RXCFG, rxcfg, 0,
/usr/src/sys/dev/hme/if_hme.c:	if (!hme_mac_bitflip(sc, HME_MACI_RXCFG, macc,
/usr/src/sys/dev/hme/if_hme.c:	if (!hme_mac_bitflip(sc, HME_MACI_RXCFG, macc,
/usr/src/sys/dev/hme/if_hme.c:	if (!hme_mac_bitflip(sc, HME_MACI_RXCFG, macc, 0,
/usr/src/sys/dev/hme/if_hme_sbus.c:	struct	resource	*hsc_mac_res;
/usr/src/sys/dev/hme/if_hme_sbus.c:	hsc->hsc_mac_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY,
/usr/src/sys/dev/hme/if_hme_sbus.c:	if (hsc->hsc_mac_res == NULL) {
/usr/src/sys/dev/hme/if_hme_sbus.c:	sc->sc_mact = rman_get_bustag(hsc->hsc_mac_res);
/usr/src/sys/dev/hme/if_hme_sbus.c:	sc->sc_mach = rman_get_bushandle(hsc->hsc_mac_res);
/usr/src/sys/dev/hme/if_hme_sbus.c:			goto fail_mac_res;
/usr/src/sys/dev/hme/if_hme_sbus.c:		if (start < rman_get_start(hsc->hsc_mac_res) ||
/usr/src/sys/dev/hme/if_hme_sbus.c:		    start + count - 1 > rman_get_end(hsc->hsc_mac_res)) {
/usr/src/sys/dev/hme/if_hme_sbus.c:			goto fail_mac_res;
/usr/src/sys/dev/hme/if_hme_sbus.c:		    start - rman_get_start(hsc->hsc_mac_res), count,
/usr/src/sys/dev/hme/if_hme_sbus.c:fail_mac_res:
/usr/src/sys/dev/hme/if_hme_sbus.c:	    rman_get_rid(hsc->hsc_mac_res), hsc->hsc_mac_res);
/usr/src/sys/dev/hme/if_hme_sbus.c:	    rman_get_rid(hsc->hsc_mac_res), hsc->hsc_mac_res);
/usr/src/sys/dev/iicbus/ad7417.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/dev/iicbus/ad7417.c:	struct	pmac_therm therm;
/usr/src/sys/dev/iicbus/ad7417.c:			    (int (*)(struct pmac_therm *))(ad7417_diode_read);
/usr/src/sys/dev/iicbus/ad7417.c:			    (int (*)(struct pmac_therm *))(ad7417_sensor_read);
/usr/src/sys/dev/iicbus/ad7417.c:		pmac_thermal_sensor_register(&sc->sc_sensors[j].therm);
/usr/src/sys/dev/iicbus/ds1775.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/dev/iicbus/ds1775.c:	struct pmac_therm	sc_sensor;
/usr/src/sys/dev/iicbus/ds1775.c:	    (int (*)(struct pmac_therm *sc))(ds1775_sensor_read);
/usr/src/sys/dev/iicbus/ds1775.c:	pmac_thermal_sensor_register(&sc->sc_sensor);
/usr/src/sys/dev/iicbus/max6690.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/dev/iicbus/max6690.c:	struct pmac_therm therm;
/usr/src/sys/dev/iicbus/max6690.c:		    (int (*)(struct pmac_therm *))(max6690_sensor_read);
/usr/src/sys/dev/iicbus/max6690.c:	/* Register with powermac_thermal */
/usr/src/sys/dev/iicbus/max6690.c:		pmac_thermal_sensor_register(&sc->sc_sensors[i].therm);
/usr/src/sys/dev/ixgb/if_ixgb.c:	bcopy(IF_LLADDR(ifp), adapter->hw.curr_mac_addr,
/usr/src/sys/dev/ixgb/if_ixgb.c:		adapter->hw.mac_type = ixgb_82597;
/usr/src/sys/dev/ixgb/if_ixgb.c:	ether_ifattach(ifp, adapter->hw.curr_mac_addr);
/usr/src/sys/dev/ixgb/ixgb_ee.c: * mac_addr - Ethernet Address if EEPROM contents are valid, 0 otherwise
/usr/src/sys/dev/ixgb/ixgb_ee.c:ixgb_get_ee_mac_addr(struct ixgb_hw *hw,
/usr/src/sys/dev/ixgb/ixgb_ee.c:                        uint8_t *mac_addr)
/usr/src/sys/dev/ixgb/ixgb_ee.c:    DEBUGFUNC("ixgb_get_ee_mac_addr");
/usr/src/sys/dev/ixgb/ixgb_ee.c:            mac_addr[i] = ee_map->mac_addr[i];
/usr/src/sys/dev/ixgb/ixgb_ee.c:            DEBUGOUT2("mac(%d) = %.2X\n", i, mac_addr[i]);
/usr/src/sys/dev/ixgb/ixgb_hw.c:uint32_t ixgb_mac_reset (struct ixgb_hw* hw);
/usr/src/sys/dev/ixgb/ixgb_hw.c:uint32_t ixgb_mac_reset (struct ixgb_hw* hw)
/usr/src/sys/dev/ixgb/ixgb_hw.c:    ctrl_reg = ixgb_mac_reset(hw);
/usr/src/sys/dev/ixgb/ixgb_hw.c:    ctrl_reg = ixgb_mac_reset(hw);
/usr/src/sys/dev/ixgb/ixgb_hw.c:    if (!mac_addr_valid(hw->curr_mac_addr)) {
/usr/src/sys/dev/ixgb/ixgb_hw.c:    if (!mac_addr_valid(hw->curr_mac_addr)) {
/usr/src/sys/dev/ixgb/ixgb_hw.c:           ixgb_get_ee_mac_addr(hw, hw->curr_mac_addr);
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[0],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[1],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[2]);
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[3],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[4],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                            hw->curr_mac_addr[5]);
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[0],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[1],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[2]);
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[3],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[4],
/usr/src/sys/dev/ixgb/ixgb_hw.c:                                        hw->curr_mac_addr[5]);
/usr/src/sys/dev/ixgb/ixgb_hw.c:            ixgb_rar_set(hw, hw->curr_mac_addr, 0);
/usr/src/sys/dev/ixgb/ixgb_hw.c: * mac_addr - pointer to MAC address.
/usr/src/sys/dev/ixgb/ixgb_hw.c:mac_addr_valid(uint8_t *mac_addr)
/usr/src/sys/dev/ixgb/ixgb_hw.c:    DEBUGFUNC("mac_addr_valid");
/usr/src/sys/dev/ixgb/ixgb_hw.c:    if (IS_MULTICAST(mac_addr)) {
/usr/src/sys/dev/ixgb/ixgb_hw.c:    else if (IS_BROADCAST(mac_addr)) {
/usr/src/sys/dev/ixgb/ixgb_hw.c:    else if (mac_addr[0] == 0 &&
/usr/src/sys/dev/ixgb/ixgb_hw.c:             mac_addr[1] == 0 &&
/usr/src/sys/dev/ixgb/ixgb_hw.c:             mac_addr[2] == 0 &&
/usr/src/sys/dev/ixgb/ixgb_hw.c:             mac_addr[3] == 0 &&
/usr/src/sys/dev/ixgb/ixgb_hw.c:             mac_addr[4] == 0 &&
/usr/src/sys/dev/ixgb/ixgb_hw.c:             mac_addr[5] == 0) {
/usr/src/sys/dev/ixgbe/ixgbe.c:extern void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type != ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82599EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type == ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type == ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:        if (adapter->hw.mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (adapter->hw.mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if ((hw->mac.type == ixgbe_mac_X540) &&
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82599EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:		ixgbe_stop_mac_link_on_d3_82599(hw);
/usr/src/sys/dev/ixgbe/ixgbe.c:	ixgbe_set_mac_type(hw);
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (adapter->hw.mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (adapter->hw.mac.type != ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (adapter->hw.mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:		case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	struct ixgbe_mac_info	*mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	stat_node = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "mac_stats", 
/usr/src/sys/dev/ixgbe/ixgbe.c:	if ((adapter->advertise == 2) && (hw->mac.type != ixgbe_mac_X540)) {
/usr/src/sys/dev/ixgbe/ixgbe.c:	if (hw->mac.type != ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	mac->ops.check_link = &ixgbe_check_mac_link_82598;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	mac->ops.setup_link = &ixgbe_setup_mac_link_82598;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c: *  ixgbe_start_mac_link_82598 - Configures MAC link settings
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	DEBUGFUNC("ixgbe_start_mac_link_82598");
/usr/src/sys/dev/ixgbe/ixgbe_82598.c: *  ixgbe_check_mac_link_82598 - Get link/speed status
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	DEBUGFUNC("ixgbe_check_mac_link_82598");
/usr/src/sys/dev/ixgbe/ixgbe_82598.c: *  ixgbe_setup_mac_link_82598 - Set MAC link speed
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	DEBUGFUNC("ixgbe_setup_mac_link_82598");
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:		status = ixgbe_start_mac_link_82598(hw,
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	ixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:			goto mac_reset_top;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:mac_reset_top:
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:		goto mac_reset_top;
/usr/src/sys/dev/ixgbe/ixgbe_82598.c:	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_init_mac_link_ops_82599");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		mac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:			mac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:			mac->ops.setup_link = &ixgbe_setup_mac_link_82599;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	ixgbe_init_mac_link_ops_82599(hw);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		ixgbe_init_mac_link_ops_82599(hw);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.get_san_mac_addr = &ixgbe_get_san_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.set_san_mac_addr = &ixgbe_set_san_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.set_vmdq_san_mac = &ixgbe_set_vmdq_san_mac_generic;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.insert_mac_addr = &ixgbe_insert_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.set_mac_anti_spoofing = &ixgbe_set_mac_anti_spoofing;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	mac->ops.check_link = &ixgbe_check_mac_link_generic;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	ixgbe_init_mac_link_ops_82599(hw);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c: *  ixgbe_stop_mac_link_on_d3_82599 - Disables link on D3
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_stop_mac_link_on_d3_82599");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c: *  ixgbe_start_mac_link_82599 - Setup MAC link settings
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_start_mac_link_82599");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_setup_mac_link_multispeed_fiber");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_multispeed_fiber(hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_setup_mac_link_smartspeed");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw, speed,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	status = ixgbe_setup_mac_link_82599(hw, speed,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	status = ixgbe_setup_mac_link_82599(hw, speed,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_82599 - Set MAC link speed
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	DEBUGFUNC("ixgbe_setup_mac_link_82599");
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	ixgbe_start_mac_link_82599(hw, autoneg_wait_to_complete);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:mac_reset_top:
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		goto mac_reset_top;
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	hw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
/usr/src/sys/dev/ixgbe/ixgbe_82599.c:		hw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	ixgbe_set_mac_type(hw);
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	case ixgbe_mac_82599_vf:
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	case ixgbe_mac_X540_vf:
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  ixgbe_set_mac_type - Sets MAC type
/usr/src/sys/dev/ixgbe/ixgbe_api.c:s32 ixgbe_set_mac_type(struct ixgbe_hw *hw)
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	DEBUGFUNC("ixgbe_set_mac_type\n");
/usr/src/sys/dev/ixgbe/ixgbe_api.c:		hw->mac.type = ixgbe_mac_82598EB;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:		hw->mac.type = ixgbe_mac_82599EB;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:		hw->mac.type = ixgbe_mac_82599_vf;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:		hw->mac.type = ixgbe_mac_X540_vf;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:		hw->mac.type = ixgbe_mac_X540;
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	DEBUGOUT2("ixgbe_set_mac_type found mac: %d, returns: %d\n",
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  ixgbe_get_mac_addr - Get MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  @mac_addr: Adapter MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c:s32 ixgbe_get_mac_addr(struct ixgbe_hw *hw, u8 *mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_mac_addr,
/usr/src/sys/dev/ixgbe/ixgbe_api.c:			       (hw, mac_addr), IXGBE_NOT_IMPLEMENTED);
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  ixgbe_get_san_mac_addr - Get SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  @san_mac_addr: SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c:s32 ixgbe_get_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_san_mac_addr,
/usr/src/sys/dev/ixgbe/ixgbe_api.c:			       (hw, san_mac_addr), IXGBE_NOT_IMPLEMENTED);
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  ixgbe_set_san_mac_addr - Write a SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  @san_mac_addr: SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_api.c:s32 ixgbe_set_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_san_mac_addr,
/usr/src/sys/dev/ixgbe/ixgbe_api.c:			       (hw, san_mac_addr), IXGBE_NOT_IMPLEMENTED);
/usr/src/sys/dev/ixgbe/ixgbe_api.c: *  ixgbe_insert_mac_addr - Find a RAR for this mac address
/usr/src/sys/dev/ixgbe/ixgbe_api.c:s32 ixgbe_insert_mac_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
/usr/src/sys/dev/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.insert_mac_addr,
/usr/src/sys/dev/ixgbe/ixgbe_common.c:static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_common.c:					 u16 *san_mac_offset);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	mac->ops.get_mac_addr = &ixgbe_get_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	mac->ops.insert_mac_addr = NULL;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	mac->ops.dmac_config = NULL;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	mac->ops.dmac_update_tcs = NULL;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	mac->ops.dmac_config_tcs = NULL;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type != ixgbe_mac_X540) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		if ((hw->mac.type == ixgbe_mac_82599EB) &&
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		if (hw->mac.type == ixgbe_mac_82599EB)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type >= ixgbe_mac_82599EB) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		if (hw->mac.type >= ixgbe_mac_82599EB) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type >= ixgbe_mac_82599EB)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		if (hw->mac.type >= ixgbe_mac_82599EB) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_X540) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_get_mac_addr_generic - Generic get MAC address
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  @mac_addr: Adapter MAC address
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_get_mac_addr_generic");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		mac_addr[i] = (u8)(rar_low >> (i*8));
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		mac_addr[i+4] = (u8)(rar_high >> (i*8));
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_validate_mac_addr - Validate MAC address
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  @mac_addr: pointer to MAC address.
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_validate_mac_addr(u8 *mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_validate_mac_addr");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (IXGBE_IS_MULTICAST(mac_addr)) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	} else if (IXGBE_IS_BROADCAST(mac_addr)) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	} else if (mac_addr[0] == 0 && mac_addr[1] == 0 && mac_addr[2] == 0 &&
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		   mac_addr[3] == 0 && mac_addr[4] == 0 && mac_addr[5] == 0) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (ixgbe_validate_mac_addr(hw->mac.addr) ==
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		hw->mac.ops.get_mac_addr(hw, hw->mac.addr);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82599EB) {
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		if ((hw->mac.type == ixgbe_mac_82599EB) &&
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if ((hw->mac.type == ixgbe_mac_82599EB) &&
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82599EB)
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  @san_mac_offset: SAN MAC address offset
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  get and set mac_addr routines.
/usr/src/sys/dev/ixgbe/ixgbe_common.c:static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_common.c:					 u16 *san_mac_offset)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_get_san_mac_addr_offset");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:				      san_mac_offset);
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  @san_mac_addr: SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	u16 san_mac_data, san_mac_offset;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_get_san_mac_addr_generic");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	ret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		goto san_mac_addr_out;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	(hw->bus.func) ? (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT1_OFFSET) :
/usr/src/sys/dev/ixgbe/ixgbe_common.c:			 (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT0_OFFSET);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		ret_val = hw->eeprom.ops.read(hw, san_mac_offset,
/usr/src/sys/dev/ixgbe/ixgbe_common.c:					      &san_mac_data);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:				      san_mac_offset);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:			goto san_mac_addr_out;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_addr[i * 2] = (u8)(san_mac_data);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_addr[i * 2 + 1] = (u8)(san_mac_data >> 8);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_offset++;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:san_mac_addr_out:
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_addr[i] = 0xFF;
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_set_san_mac_addr_generic - Write the SAN MAC address to the EEPROM
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  @san_mac_addr: SAN MAC address
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	u16 san_mac_data, san_mac_offset;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_set_san_mac_addr_generic");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	ret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	(hw->bus.func) ? (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT1_OFFSET) :
/usr/src/sys/dev/ixgbe/ixgbe_common.c:			 (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT0_OFFSET);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_data = (u16)((u16)(san_mac_addr[i * 2 + 1]) << 8);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_data |= (u16)(san_mac_addr[i * 2]);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		hw->eeprom.ops.write(hw, san_mac_offset, san_mac_data);
/usr/src/sys/dev/ixgbe/ixgbe_common.c:		san_mac_offset++;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_insert_mac_addr_generic - Find a RAR for this mac address
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_insert_mac_addr_generic");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	 * Either find the mac_id in rar or find the first empty space.
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  MPSAR table needs to be updated for SAN_MAC RAR [hw->mac.san_mac_rar_index]
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	u32 rar = hw->mac.san_mac_rar_index;
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_check_mac_link_generic - Determine link and speed status
/usr/src/sys/dev/ixgbe/ixgbe_common.c:s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	DEBUGFUNC("ixgbe_check_mac_link_generic");
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	u16 alt_san_mac_blk_offset;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->eeprom.ops.read(hw, offset, &alt_san_mac_blk_offset))
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if ((alt_san_mac_blk_offset == 0) ||
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	    (alt_san_mac_blk_offset == 0xFFFF))
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET;
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET;
/usr/src/sys/dev/ixgbe/ixgbe_common.c: *  ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing
/usr/src/sys/dev/ixgbe/ixgbe_common.c:void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int pf)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:			    && (hw->mac.type == ixgbe_mac_82598EB))
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82598EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_dcb.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_dcb_82599.c:	if (hw->mac.type == ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe_mbx.c:	case ixgbe_mac_82599EB:
/usr/src/sys/dev/ixgbe/ixgbe_mbx.c:	case ixgbe_mac_X540:
/usr/src/sys/dev/ixgbe/ixgbe_mbx.c:	if (hw->mac.type != ixgbe_mac_82599EB &&
/usr/src/sys/dev/ixgbe/ixgbe_mbx.c:	    hw->mac.type != ixgbe_mac_X540)
/usr/src/sys/dev/ixgbe/ixgbe_phy.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe_phy.c:		} else if (hw->mac.type == ixgbe_mac_82599EB) {
/usr/src/sys/dev/ixgbe/ixgbe_phy.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:	hw->mac.ops.get_mac_addr = ixgbe_get_mac_addr_vf;
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:	hw->mac.ops.setup_link = ixgbe_setup_mac_link_vf;
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:	hw->mac.ops.check_link = ixgbe_check_mac_link_vf;
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:	hw->mac.ops.get_mac_addr(hw, hw->mac.addr);
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:		ixgbe_get_mac_addr_vf(hw, hw->mac.addr);
/usr/src/sys/dev/ixgbe/ixgbe_vf.c: *  ixgbe_get_mac_addr_vf - Read device MAC address
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:s32 ixgbe_get_mac_addr_vf(struct ixgbe_hw *hw, u8 *mac_addr)
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:		mac_addr[i] = hw->mac.perm_addr[i];
/usr/src/sys/dev/ixgbe/ixgbe_vf.c: *  ixgbe_setup_mac_link_vf - Setup MAC link settings
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:s32 ixgbe_setup_mac_link_vf(struct ixgbe_hw *hw, ixgbe_link_speed speed,
/usr/src/sys/dev/ixgbe/ixgbe_vf.c: *  ixgbe_check_mac_link_vf - Get link/speed status
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:s32 ixgbe_check_mac_link_vf(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
/usr/src/sys/dev/ixgbe/ixgbe_vf.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	struct ixgbe_mac_info *mac = &hw->mac;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.get_san_mac_addr = &ixgbe_get_san_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.set_san_mac_addr = &ixgbe_set_san_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.set_vmdq_san_mac = &ixgbe_set_vmdq_san_mac_generic;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.insert_mac_addr = &ixgbe_insert_mac_addr_generic;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.set_mac_anti_spoofing = &ixgbe_set_mac_anti_spoofing;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.setup_link = &ixgbe_setup_mac_link_X540;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	mac->ops.check_link = &ixgbe_check_mac_link_generic;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c: *  ixgbe_setup_mac_link_X540 - Sets the auto advertised capabilities
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw,
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	DEBUGFUNC("ixgbe_setup_mac_link_X540");
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:mac_reset_top:
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:		goto mac_reset_top;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	hw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:		hw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;
/usr/src/sys/dev/ixgbe/ixgbe_x540.c:	if (hw->mac.type == ixgbe_mac_X540 && hw->revision_id == 0) {
/usr/src/sys/dev/ixgbe/ixv.c:	if (adapter->hw.mac.type == ixgbe_mac_82599_vf) {
/usr/src/sys/dev/jme/if_jme.c:static void jme_mac_config(struct jme_softc *);
/usr/src/sys/dev/jme/if_jme.c:					jme_mac_config(sc);
/usr/src/sys/dev/jme/if_jme.c:	jme_mac_config(sc);
/usr/src/sys/dev/jme/if_jme.c:jme_mac_config(struct jme_softc *sc)
/usr/src/sys/dev/jme/if_jme.c:		jme_mac_config(sc);
/usr/src/sys/dev/mge/if_mge.c:static void mge_get_mac_address(struct mge_softc *sc, uint8_t *addr);
/usr/src/sys/dev/mge/if_mge.c:static void mge_set_mac_address(struct mge_softc *sc);
/usr/src/sys/dev/mge/if_mge.c:mge_get_mac_address(struct mge_softc *sc, uint8_t *addr)
/usr/src/sys/dev/mge/if_mge.c:	uint32_t mac_l, mac_h;
/usr/src/sys/dev/mge/if_mge.c:	mac_l = MGE_READ(sc, MGE_MAC_ADDR_L);
/usr/src/sys/dev/mge/if_mge.c:	mac_h = MGE_READ(sc, MGE_MAC_ADDR_H);
/usr/src/sys/dev/mge/if_mge.c:	addr[0] = (mac_h & 0xff000000) >> 24;
/usr/src/sys/dev/mge/if_mge.c:	addr[1] = (mac_h & 0x00ff0000) >> 16;
/usr/src/sys/dev/mge/if_mge.c:	addr[2] = (mac_h & 0x0000ff00) >> 8;
/usr/src/sys/dev/mge/if_mge.c:	addr[3] = (mac_h & 0x000000ff);
/usr/src/sys/dev/mge/if_mge.c:	addr[4] = (mac_l & 0x0000ff00) >> 8;
/usr/src/sys/dev/mge/if_mge.c:	addr[5] = (mac_l & 0x000000ff);
/usr/src/sys/dev/mge/if_mge.c:mge_set_mac_address(struct mge_softc *sc)
/usr/src/sys/dev/mge/if_mge.c:	uint32_t mac_l, mac_h;
/usr/src/sys/dev/mge/if_mge.c:	mac_l = (if_mac[4] << 8) | (if_mac[5]);
/usr/src/sys/dev/mge/if_mge.c:	mac_h = (if_mac[0] << 24)| (if_mac[1] << 16) |
/usr/src/sys/dev/mge/if_mge.c:	MGE_WRITE(sc, MGE_MAC_ADDR_L, mac_l);
/usr/src/sys/dev/mge/if_mge.c:	MGE_WRITE(sc, MGE_MAC_ADDR_H, mac_h);
/usr/src/sys/dev/mge/if_mge.c:		mge_set_mac_address(sc);
/usr/src/sys/dev/mge/if_mge.c:	mge_get_mac_address(sc, hwaddr);
/usr/src/sys/dev/mge/if_mge.c:	mge_set_mac_address(sc);
/usr/src/sys/dev/mwl/mwlhal.c:static int mwl_hal_setmac_locked(struct mwl_hal_vap *,
/usr/src/sys/dev/mwl/mwlhal.c:			mwl_hal_setmac_locked(vap, mac);
/usr/src/sys/dev/mwl/mwlhal.c:mwl_hal_setmac_locked(struct mwl_hal_vap *vap,
/usr/src/sys/dev/mwl/mwlhal.c:	retval = mwl_hal_setmac_locked(vap, addr);
/usr/src/sys/dev/mxge/if_mxge.c:				sc->mac_addr[i] = strtoul(ptr, &endptr, 16);
/usr/src/sys/dev/mxge/if_mxge.c:mxge_update_mac_address(mxge_softc_t *sc)
/usr/src/sys/dev/mxge/if_mxge.c:	uint8_t *addr = sc->mac_addr;
/usr/src/sys/dev/mxge/if_mxge.c:	status = mxge_update_mac_address(sc);
/usr/src/sys/dev/mxge/if_mxge.c:	bcopy(IF_LLADDR(sc->ifp), sc->mac_addr, ETHER_ADDR_LEN);
/usr/src/sys/dev/mxge/if_mxge.c:	ether_ifattach(ifp, sc->mac_addr);
/usr/src/sys/dev/nfe/if_nfe.c:static void nfe_mac_config(struct nfe_softc *, struct mii_data *);
/usr/src/sys/dev/nfe/if_nfe.c:	nfe_mac_config(sc, mii);
/usr/src/sys/dev/nfe/if_nfe.c:nfe_mac_config(struct nfe_softc *sc, struct mii_data *mii)
/usr/src/sys/dev/nfe/if_nfe.c:					nfe_mac_config(sc, mii);
/usr/src/sys/dev/nfe/if_nfe.c:	nfe_mac_config(sc, mii);
/usr/src/sys/dev/nve/if_nve.c:	sc->hwapi->pfnGetNodeAddress(sc->hwapi->pADCX, sc->original_mac_addr);
/usr/src/sys/dev/nve/if_nve.c:		eaddr[i] = sc->original_mac_addr[5 - i];
/usr/src/sys/dev/nve/if_nve.c:	if (sc->original_mac_addr)
/usr/src/sys/dev/nve/if_nve.c:		    sc->original_mac_addr);
/usr/src/sys/dev/nxge/if_nxge.c:	dconfig->mac.rmac_bcast_en     = XGE_DEFAULT_MAC_RMAC_BCAST_EN;
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_tmac_util_period", tmac_util_period,
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_rmac_util_period", rmac_util_period,
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_rmac_pause_gen_en", rmac_pause_gen_en,
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_rmac_pause_rcv_en", rmac_pause_rcv_en,
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_rmac_pause_time", rmac_pause_time,
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_mc_pause_threshold_q0q3",
/usr/src/sys/dev/nxge/if_nxge.c:	XGE_GET_PARAM_MAC("hw.xge.mac_mc_pause_threshold_q4q7",
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rts_mac_en < XGE_HAL_MIN_RING_RTS_MAC_EN) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rts_mac_en > XGE_HAL_MAX_RING_RTS_MAC_EN)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rts_mac_en < XGE_HAL_MIN_RING_RTS_PORT_EN) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rts_mac_en > XGE_HAL_MAX_RING_RTS_PORT_EN)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c: * __hal_mac_config_check - Check mac configuration
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:__hal_mac_config_check (xge_hal_mac_config_t *new_config)
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->tmac_util_period < XGE_HAL_MIN_TMAC_UTIL_PERIOD) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->tmac_util_period > XGE_HAL_MAX_TMAC_UTIL_PERIOD)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rmac_util_period < XGE_HAL_MIN_RMAC_UTIL_PERIOD) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rmac_util_period > XGE_HAL_MAX_RMAC_UTIL_PERIOD)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rmac_bcast_en < XGE_HAL_MIN_RMAC_BCAST_EN) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rmac_bcast_en > XGE_HAL_MAX_RMAC_BCAST_EN)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rmac_pause_gen_en < XGE_HAL_MIN_RMAC_PAUSE_GEN_EN) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rmac_pause_gen_en>XGE_HAL_MAX_RMAC_PAUSE_GEN_EN)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rmac_pause_rcv_en < XGE_HAL_MIN_RMAC_PAUSE_RCV_EN) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rmac_pause_rcv_en>XGE_HAL_MAX_RMAC_PAUSE_RCV_EN)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((new_config->rmac_pause_time < XGE_HAL_MIN_RMAC_HIGH_PTIME) ||
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	    (new_config->rmac_pause_time > XGE_HAL_MAX_RMAC_HIGH_PTIME)) {
/usr/src/sys/dev/nxge/xgehal/xgehal-config.c:	if ((status = __hal_mac_config_check(&new_config->mac)) !=
/usr/src/sys/dev/nxge/xgehal/xgehal-device-fp.c:	    hldev->stats.sw_dev_info_stats.txmac_intr_cnt++;
/usr/src/sys/dev/nxge/xgehal/xgehal-device-fp.c:	    hldev->stats.sw_dev_info_stats.rxmac_intr_cnt++;
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    XGE_HAL_RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    (u32)(val64 >> 32), &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	xge_debug_device(XGE_TRACE, "mac_cfg 0x"XGE_OS_LLXFMT": broadcast %s",
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    hldev->config.mac.rmac_bcast_en ? "enabled" : "disabled");
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	         XGE_HAL_RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        (u32)(val64 >> 32), &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	xge_debug_device(XGE_TRACE, "mac_cfg 0x"XGE_OS_LLXFMT": broadcast %s",
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    hldev->config.mac.rmac_bcast_en ? "enabled" : "disabled");
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * __hal_device_rmac_padding_configure
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:__hal_device_rmac_padding_configure(xge_hal_device_t *hldev)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        XGE_HAL_RMAC_CFG_KEY(0x4C0D), &bar0->rmac_cfg_key);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        (u32)(val64 >> 32), (char*)&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	      "mac_cfg 0x"XGE_OS_LLXFMT": frame padding configured",
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * (mac_control.mc_pause_threshold_q0q3 or q4q7)/256
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                            &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (hldev->config.mac.rmac_pause_gen_en)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (hldev->config.mac.rmac_pause_rcv_en)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	val64 |= XGE_HAL_RMAC_PAUSE_HG_PTIME(hldev->config.mac.rmac_pause_time);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	             &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	             XGE_HAL_ALL_INTRS_DIS, &bar0->mac_int_mask);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	             XGE_HAL_ALL_INTRS_DIS, &bar0->mac_rmac_err_mask);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	             XGE_HAL_ALL_INTRS_DIS, &bar0->mac_int_mask);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	             XGE_HAL_ALL_INTRS_DIS, &bar0->mac_rmac_err_mask);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * __hal_device_mac_link_util_set
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:__hal_device_mac_link_util_set(xge_hal_device_t *hldev)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        hldev->config.mac.tmac_util_period) |
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        hldev->config.mac.rmac_util_period);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                     &bar0->mac_link_util);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * __hal_device_rts_mac_configure - Configure RTS steering based on
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:__hal_device_rts_mac_configure(xge_hal_device_t *hldev)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (!hldev->config.rts_mac_en) {
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * xge__hal_device_rts_mac_enable
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:xge_hal_device_rts_mac_enable(xge_hal_device_h devh, int index, macaddr_t macaddr)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c: * xge__hal_device_rts_mac_disable
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:xge_hal_device_rts_mac_disable(xge_hal_device_h devh, int index)
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	               &bar0->mac_int_mask);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (hldev->config.mac.rmac_bcast_en) {
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	__hal_device_mac_link_util_set(hldev);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	__hal_device_mac_link_util_set(hldev);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	status = __hal_device_rts_mac_configure(hldev);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    xge_debug_device(XGE_ERR, "__hal_device_rts_mac_configure Failed ");
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	__hal_device_rmac_padding_configure(hldev);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                    &bar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                   err_reg, &bar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &isrbar0->mac_int_status);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &isrbar0->mac_tmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            val64, &isrbar0->mac_tmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	hldev->stats.sw_dev_info_stats.mac_tmac_err_cnt++;
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &isrbar0->mac_int_status);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &isrbar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            val64, &isrbar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	hldev->stats.sw_dev_info_stats.mac_rmac_err_cnt++;
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        &bar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                       val64, &bar0->mac_rmac_err_reg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	      &bar0->rmac_addr_data0_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	      &bar0->rmac_addr_data1_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                &bar0->rmac_addr_cmd_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    &bar0->rmac_addr_cmd_mem, 0,
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	           &bar0->rmac_addr_data0_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	           &bar0->rmac_addr_data1_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                &bar0->rmac_addr_cmd_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    &bar0->rmac_addr_cmd_mem, 0,
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                                &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	               &bar0->rmac_cfg_key);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                  &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        "mac_cfg 0x"XGE_OS_LLXFMT": promisc enabled",
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                    &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	               &bar0->rmac_cfg_key);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                  &bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	        "mac_cfg 0x"XGE_OS_LLXFMT": promisc disabled",
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                            &bar0->rmac_addr_data0_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                            &bar0->rmac_addr_data1_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                     &bar0->rmac_addr_cmd_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	           &bar0->rmac_addr_cmd_mem, 0,
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                     &bar0->rmac_addr_cmd_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (__hal_device_register_poll(hldev, &bar0->rmac_addr_cmd_mem, 0,
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                            &bar0->rmac_addr_data0_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &bar0->rmac_addr_data0_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &bar0->rmac_addr_data1_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	                     &bar0->rmac_addr_cmd_mem);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	if (__hal_device_register_poll(hldev, &bar0->rmac_addr_cmd_mem, 0,
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	    hldev->config.rts_mac_en = 0;
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            &bar0->rts_mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-device.c:	            val64, &bar0->rts_mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-driver.c:	xge_assert(xge_offsetof(xge_hal_pci_bar0_t, mac_cfg) ==
/usr/src/sys/dev/nxge/xgehal/xgehal-driver.c:	xge_assert(xge_offsetof(xge_hal_pci_bar0_t, rmac_addr_cmd_mem) ==
/usr/src/sys/dev/nxge/xgehal/xgehal-driver.c:	xge_assert(xge_offsetof(xge_hal_pci_bar0_t, mac_link_util) ==
/usr/src/sys/dev/nxge/xgehal/xgehal-driver.c:	xge_assert(xge_offsetof(xge_hal_pci_bar0_t, mac_tmac_err_reg) ==
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	        &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	        (u32)(val64 >> 32), (char*)&bar0->mac_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	            &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	                &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmt.c:	             val64, &bar0->rmac_pause_cfg);
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_tmac_read - Read TMAC hardware statistics.
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:xge_hal_status_e xge_hal_aux_stats_tmac_read(xge_hal_device_h devh, int bufsize,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_data_octets", hw.tmac_data_octets, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_frms", hw.tmac_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_drop_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.tmac_drop_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_bcst_frms", hw.tmac_bcst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_mcst_frms", hw.tmac_mcst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_pause_ctrl_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.tmac_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_ucst_frms", hw.tmac_ucst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_ttl_octets", hw.tmac_ttl_octets, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_any_err_frms", hw.tmac_any_err_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_nucst_frms", hw.tmac_nucst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_ttl_less_fb_octets", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.tmac_ttl_less_fb_octets, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_vld_ip_octets", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.tmac_vld_ip_octets, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_drop_ip", hw.tmac_drop_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_vld_ip", hw.tmac_vld_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_rst_tcp", hw.tmac_rst_tcp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_icmp", hw.tmac_icmp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_tcp", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.tmac_tcp, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_udp", hw.tmac_udp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_rmac_read - Read RMAC hardware statistics.
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_pci_read(), xge_hal_aux_stats_tmac_read(),
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:xge_hal_status_e xge_hal_aux_stats_rmac_read(xge_hal_device_h devh, int bufsize,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_data_octets", hw.rmac_data_octets, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_vld_frms", hw.rmac_vld_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_fcs_err_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_fcs_err_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("mac_drop_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_drop_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_vld_bcst_frms", hw.rmac_vld_bcst_frms,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_vld_mcst_frms", hw.rmac_vld_mcst_frms,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_out_rng_len_err_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_out_rng_len_err_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_in_rng_len_err_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_in_rng_len_err_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_long_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_long_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_pause_ctrl_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_unsup_ctrl_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_unsup_ctrl_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_accepted_ucst_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_accepted_ucst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_octets", hw.rmac_ttl_octets, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_discarded_frms", hw.rmac_discarded_frms,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_accepted_nucst_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_accepted_nucst_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_drop_events", hw.rmac_drop_events, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_less_fb_octets", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_less_fb_octets, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_usized_frms", hw.rmac_usized_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frag_frms", hw.rmac_frag_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_osized_frms", hw.rmac_osized_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_jabber_frms", hw.rmac_jabber_frms, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_64_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_64_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_65_127_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_65_127_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_128_255_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_128_255_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_256_511_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_256_511_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_512_1023_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_512_1023_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ttl_1024_1518_frms", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ttl_1024_1518_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ip", hw.rmac_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_ip_octets", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_ip_octets, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_drop_ip", hw.rmac_drop_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_hdr_err_ip", hw.rmac_hdr_err_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_icmp", hw.rmac_icmp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_tcp", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_tcp, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_err_drp_udp", hw.rmac_err_drp_udp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_udp", hw.rmac_udp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_xgmii_err_sym", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_xgmii_err_sym, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q0", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q0, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q1", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q1, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q2", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q2, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q3", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q3, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q4", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q4, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q5", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q5, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q6", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q6, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_frms_q7", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_frms_q7, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q3", hw.rmac_full_q3, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q2", hw.rmac_full_q2, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q1", hw.rmac_full_q1, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q0", hw.rmac_full_q0, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q7", hw.rmac_full_q7, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q6", hw.rmac_full_q6, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q5", hw.rmac_full_q5, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_full_q4", hw.rmac_full_q4, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_pause_cnt", hw.rmac_pause_cnt, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_xgmii_data_err_cnt", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_xgmii_data_err_cnt, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_xgmii_ctrl_err_cnt", (unsigned long long)
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            hw.rmac_xgmii_ctrl_err_cnt, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_err_tcp", hw.rmac_err_tcp, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_accepted_ip", hw.rmac_accepted_ip, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_tmac_read(), xge_hal_aux_stats_rmac_read(),
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_frms_oflow", hw.tmac_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_data_octets_oflow", hw.tmac_data_octets_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_mcst_frms_oflow", hw.tmac_mcst_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_bcst_frms_oflow", hw.tmac_bcst_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_ttl_octets_oflow", hw.tmac_ttl_octets_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_ucst_frms_oflow", hw.tmac_ucst_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_nucst_frms_oflow", hw.tmac_nucst_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_any_err_frms_oflow", hw.tmac_any_err_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_vlan_frms", (unsigned long long)hw.tmac_vlan_frms,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_vld_ip_oflow", hw.tmac_vld_ip_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_drop_ip_oflow", hw.tmac_drop_ip_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_icmp_oflow", hw.tmac_icmp_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_rst_tcp_oflow", hw.tmac_rst_tcp_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("tmac_udp_oflow", hw.tmac_udp_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_vld_frms_oflow", hw.rmac_vld_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_data_octets_oflow", hw.rmac_data_octets_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_vld_mcst_frms_oflow", hw.rmac_vld_mcst_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_vld_bcst_frms_oflow", hw.rmac_vld_bcst_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ttl_octets_oflow", hw.rmac_ttl_octets_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_accepted_ucst_frms_oflow",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.rmac_accepted_ucst_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_accepted_nucst_frms_oflow",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.rmac_accepted_nucst_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_discarded_frms_oflow",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        hw.rmac_discarded_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_drop_events_oflow", hw.rmac_drop_events_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_usized_frms_oflow", hw.rmac_usized_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_osized_frms_oflow", hw.rmac_osized_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_frag_frms_oflow", hw.rmac_frag_frms_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_jabber_frms_oflow", hw.rmac_jabber_frms_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ip_oflow", hw.rmac_ip_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_drop_ip_oflow", hw.rmac_drop_ip_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_icmp_oflow", hw.rmac_icmp_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_udp_oflow", hw.rmac_udp_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_err_drp_udp_oflow", hw.rmac_err_drp_udp_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_pause_cnt_oflow", hw.rmac_pause_cnt_oflow, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ttl_1519_4095_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_ttl_1519_4095_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ttl_4096_8191_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_ttl_4096_8191_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ttl_8192_max_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_ttl_8192_max_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ttl_gt_max_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_ttl_gt_max_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_osized_alt_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_osized_alt_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_jabber_alt_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_jabber_alt_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_gt_max_alt_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_gt_max_alt_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_vlan_frms",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	        (unsigned long long)hw.rmac_vlan_frms, "%llu");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_fcs_discard", hw.rmac_fcs_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_len_discard", hw.rmac_len_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_da_discard", hw.rmac_da_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_pf_discard", hw.rmac_pf_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_rts_discard", hw.rmac_rts_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_red_discard", hw.rmac_red_discard, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_ingm_full_discard", hw.rmac_ingm_full_discard,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rmac_accepted_ip_oflow", hw.rmac_accepted_ip_oflow,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_rmac_read - Read PCI hardware statistics.
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_tmac_read(), xge_hal_aux_stats_rmac_read(),
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("txmac_intr_cnt", devstat.txmac_intr_cnt, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	__HAL_AUX_ENTRY("rxmac_intr_cnt", devstat.rxmac_intr_cnt, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c: * xge_hal_aux_stats_tmac_read(), xge_hal_aux_stats_rmac_read(),
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	status = xge_hal_aux_stats_tmac_read(hldev, XGE_HAL_DUMP_BUF_SIZE,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	status = xge_hal_aux_stats_rmac_read(hldev, XGE_HAL_DUMP_BUF_SIZE,
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    xge_hal_mac_config_t *mac= &dev_config->mac;
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("tmac_util_period",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->tmac_util_period, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_util_period",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->rmac_util_period, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_bcast_en",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->rmac_bcast_en, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_pause_gen_en",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->rmac_pause_gen_en, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_pause_rcv_en",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->rmac_pause_rcv_en, "%d");
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	    __HAL_AUX_ENTRY("rmac_pause_time",
/usr/src/sys/dev/nxge/xgehal/xgehal-mgmtaux.c:	            mac->rmac_pause_time, "%u");
/usr/src/sys/dev/nxge/xgehal/xgehal-ring.c:	    !hldev->config.rts_mac_en) {
/usr/src/sys/dev/nxge/xgehal/xgehal-ring.c:	                   &bar0->rmac_max_pyld_len);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_data_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_drop_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_mcst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_bcst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_pause_ctrl_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_ttl_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_ucst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_nucst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_any_err_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_ttl_less_fb_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_vld_ip_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_vld_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_drop_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_icmp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_rst_tcp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_tcp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_udp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_data_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_fcs_err_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_drop_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_mcst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_bcst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_in_rng_len_err_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_out_rng_len_err_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_long_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_pause_ctrl_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_unsup_ctrl_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_ucst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_nucst_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_discarded_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_drop_events);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_less_fb_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_usized_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_osized_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frag_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_jabber_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_64_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_65_127_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_128_255_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_256_511_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_512_1023_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_1024_1518_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ip_octets);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_hdr_err_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_drop_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_icmp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_tcp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_udp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_err_drp_udp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_xgmii_err_sym);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q0);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q1);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q2);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q3);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q4);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q5);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q6);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frms_q7);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q0);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q1);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q2);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q3);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q4);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q5);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q6);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_full_q7);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_pause_cnt);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_xgmii_data_err_cnt);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_xgmii_ctrl_err_cnt);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_ip);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_err_tcp);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_data_octets_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_mcst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_bcst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_ttl_octets_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_ucst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_nucst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_any_err_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_vlan_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_vld_ip_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_drop_ip_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_icmp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_rst_tcp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, tmac_udp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_data_octets_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_mcst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vld_bcst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_octets_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_ucst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_nucst_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_discarded_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_drop_events_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_usized_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_osized_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_frag_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_jabber_frms_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ip_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_drop_ip_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_icmp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_udp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_err_drp_udp_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_pause_cnt_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_1519_4095_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_4096_8191_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_8192_max_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ttl_gt_max_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_osized_alt_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_jabber_alt_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_gt_max_alt_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_vlan_frms);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_fcs_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_len_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_da_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_pf_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_rts_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_red_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_ingm_full_discard);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	set_latest_stat_cnt(hldev, rmac_accepted_ip_oflow);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	    mcst = ((u64)hwsta->rmac_vld_mcst_frms_oflow << 32) |
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	        hwsta->rmac_vld_mcst_frms;
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	    bcst = ((u64)hwsta->rmac_vld_bcst_frms_oflow << 32) |
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	        hwsta->rmac_vld_bcst_frms;
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	    hwsta->rmac_vld_mcst_frms_oflow = (u32)(mcst >> 32);
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	    hwsta->rmac_vld_mcst_frms = (u32)mcst;
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	        (u32)(latest->tmac_ttl_less_fb_octets /
/usr/src/sys/dev/nxge/xgehal/xgehal-stats.c:	        (u32)(latest->tmac_ttl_less_fb_octets /
/usr/src/sys/dev/oce/oce_hw.c:	rc = oce_read_mac_addr(sc, 0, 1, MAC_ADDRESS_TYPE_NETWORK,
/usr/src/sys/dev/oce/oce_hw.c:			   0, &sc->macaddr.mac_addr[0], &sc->if_id);
/usr/src/sys/dev/oce/oce_hw.c:	if (link.mac_speed > 0 && link.mac_speed < 5)
/usr/src/sys/dev/oce/oce_hw.c:		sc->link_speed = link.mac_speed;
/usr/src/sys/dev/oce/oce_if.c:static void oce_mac_addr_set(POCE_SOFTC sc);
/usr/src/sys/dev/oce/oce_if.c:	ether_ifattach(sc->ifp, sc->macaddr.mac_addr);
/usr/src/sys/dev/oce/oce_if.c:oce_mac_addr_set(POCE_SOFTC sc)
/usr/src/sys/dev/oce/oce_if.c:	uint32_t old_pmac_id = sc->pmac_id;
/usr/src/sys/dev/oce/oce_if.c:	status = bcmp((IF_LLADDR(sc->ifp)), sc->macaddr.mac_addr,
/usr/src/sys/dev/oce/oce_if.c:					sc->if_id, &sc->pmac_id);
/usr/src/sys/dev/oce/oce_if.c:		status = oce_mbox_macaddr_del(sc, sc->if_id, old_pmac_id);
/usr/src/sys/dev/oce/oce_if.c:		bcopy((IF_LLADDR(sc->ifp)), sc->macaddr.mac_addr,
/usr/src/sys/dev/oce/oce_if.c:	oce_mac_addr_set(sc);
/usr/src/sys/dev/oce/oce_mbox.c:oce_read_mac_addr(POCE_SOFTC sc, uint32_t if_id,
/usr/src/sys/dev/oce/oce_mbox.c:		uint8_t perm, uint8_t type, struct mac_address_format *mac)
/usr/src/sys/dev/oce/oce_mbox.c:	bcopy(&fwcmd->params.rsp.mac.mac_addr[0], &mac->mac_addr[0],
/usr/src/sys/dev/oce/oce_mbox.c: * @param mac_addr	pointer to a buffer containing the mac address
/usr/src/sys/dev/oce/oce_mbox.c:		uint8_t *mac_addr,
/usr/src/sys/dev/oce/oce_mbox.c:	if (mac_addr != NULL) {
/usr/src/sys/dev/oce/oce_mbox.c:		bcopy(mac_addr, &fwcmd->params.req.mac_addr[0], 6);
/usr/src/sys/dev/oce/oce_mbox.c:		fwcmd->params.req.mac_invalid = 0;
/usr/src/sys/dev/oce/oce_mbox.c:		fwcmd->params.req.mac_invalid = 1;
/usr/src/sys/dev/oce/oce_mbox.c:	if (mac_addr != NULL)
/usr/src/sys/dev/oce/oce_mbox.c:		sc->pmac_id = LE_32(fwcmd->params.rsp.pmac_id);
/usr/src/sys/dev/oce/oce_mbox.c:oce_mbox_macaddr_add(POCE_SOFTC sc, uint8_t *mac_addr,
/usr/src/sys/dev/oce/oce_mbox.c:		 uint32_t if_id, uint32_t *pmac_id)
/usr/src/sys/dev/oce/oce_mbox.c:	bcopy(mac_addr, fwcmd->params.req.mac_address, 6);
/usr/src/sys/dev/oce/oce_mbox.c:	*pmac_id = fwcmd->params.rsp.pmac_id;
/usr/src/sys/dev/oce/oce_mbox.c:oce_mbox_macaddr_del(POCE_SOFTC sc, uint32_t if_id, uint32_t pmac_id)
/usr/src/sys/dev/oce/oce_mbox.c:	fwcmd->params.req.pmac_id = pmac_id;
/usr/src/sys/dev/oce/oce_sysctl.c:	adapter_stats->tx_internal_mac_errors =
/usr/src/sys/dev/oce/oce_sysctl.c:		port_stats->tx_internal_mac_errors;
/usr/src/sys/dev/oce/oce_sysctl.c:	adapter_stats->rx_internal_mac_errors =
/usr/src/sys/dev/oce/oce_sysctl.c:		port_stats->rx_internal_mac_errors;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c: * $FreeBSD: stable/9/sys/dev/powermac_nvram/powermac_nvram.c 236368 2012-05-31 23:05:07Z jhibbits $
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:#include <dev/powermac_nvram/powermac_nvramvar.h>
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static int		powermac_nvram_probe(device_t);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static int		powermac_nvram_attach(device_t);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static int		powermac_nvram_detach(device_t);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static int		powermac_nvram_check(void *data);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static device_method_t	powermac_nvram_methods[] = {
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	DEVMETHOD(device_probe,		powermac_nvram_probe),
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	DEVMETHOD(device_attach,	powermac_nvram_attach),
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	DEVMETHOD(device_detach,	powermac_nvram_detach),
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static driver_t	powermac_nvram_driver = {
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	"powermac_nvram",
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	powermac_nvram_methods,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	sizeof(struct powermac_nvram_softc)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static devclass_t powermac_nvram_devclass;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:DRIVER_MODULE(powermac_nvram, nexus, powermac_nvram_driver, powermac_nvram_devclass, 0, 0);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static	d_open_t	powermac_nvram_open;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static	d_close_t	powermac_nvram_close;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static	d_read_t	powermac_nvram_read;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static	d_write_t	powermac_nvram_write;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:static struct cdevsw powermac_nvram_cdevsw = {
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	.d_open =	powermac_nvram_open,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	.d_close =	powermac_nvram_close,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	.d_read =	powermac_nvram_read,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	.d_write =	powermac_nvram_write,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	.d_name =	"powermac_nvram",
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_probe(device_t dev)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_attach(device_t dev)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	gen0 = powermac_nvram_check((void *)sc->sc_bank0);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	gen1 = powermac_nvram_check((void *)sc->sc_bank1);
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	sc->sc_cdev = make_dev(&powermac_nvram_cdevsw, 0, 0, 0, 0600,
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	    "powermac_nvram");
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_detach(device_t dev)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_open(struct cdev *dev, int flags, int fmt, struct thread *td)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc = dev->si_drv1;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc = dev->si_drv1;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_read(struct cdev *dev, struct uio *uio, int ioflag)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc = dev->si_drv1;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_write(struct cdev *dev, struct uio *uio, int ioflag)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc = dev->si_drv1;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:powermac_nvram_check(void *data)
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc;
/usr/src/sys/dev/powermac_nvram/powermac_nvram.c:	struct powermac_nvram_softc *sc;
/usr/src/sys/dev/qlxgb/qla_hw.c:static int qla_config_mac_addr(qla_host_t *ha, uint8_t *mac_addr,
/usr/src/sys/dev/qlxgb/qla_hw.c: * Name: qla_config_mac_addr
/usr/src/sys/dev/qlxgb/qla_hw.c:qla_config_mac_addr(qla_host_t *ha, uint8_t *mac_addr, uint16_t cntxt_id,
/usr/src/sys/dev/qlxgb/qla_hw.c:	qla_fw_cds_config_mac_addr_t mac_config;
/usr/src/sys/dev/qlxgb/qla_hw.c://		"%s: mac_addr %02x:%02x:%02x:%02x:%02x:%02x\n", __func__,
/usr/src/sys/dev/qlxgb/qla_hw.c://		mac_addr[0], mac_addr[1], mac_addr[2],
/usr/src/sys/dev/qlxgb/qla_hw.c://		mac_addr[3], mac_addr[4], mac_addr[5]);
/usr/src/sys/dev/qlxgb/qla_hw.c:	bzero(&mac_config, sizeof(qla_fw_cds_config_mac_addr_t));
/usr/src/sys/dev/qlxgb/qla_hw.c:	mac_config.hdr.cmd = Q8_FWCD_CNTRL_REQ;
/usr/src/sys/dev/qlxgb/qla_hw.c:	mac_config.hdr.opcode = Q8_FWCD_OPCODE_CONFIG_MAC_ADDR;
/usr/src/sys/dev/qlxgb/qla_hw.c:	mac_config.hdr.cntxt_id = cntxt_id;
/usr/src/sys/dev/qlxgb/qla_hw.c:		mac_config.cmd = Q8_FWCD_ADD_MAC_ADDR;
/usr/src/sys/dev/qlxgb/qla_hw.c:		mac_config.cmd = Q8_FWCD_DEL_MAC_ADDR;
/usr/src/sys/dev/qlxgb/qla_hw.c:	bcopy(mac_addr, mac_config.mac_addr,6); 
/usr/src/sys/dev/qlxgb/qla_hw.c:	ret = qla_fw_cmd(ha, &mac_config, sizeof(qla_fw_cds_config_mac_addr_t));
/usr/src/sys/dev/qlxgb/qla_hw.c: * Name: qla_set_mac_rcv_mode
/usr/src/sys/dev/qlxgb/qla_hw.c:qla_set_mac_rcv_mode(qla_host_t *ha, uint16_t cntxt_id, uint32_t mode)
/usr/src/sys/dev/qlxgb/qla_hw.c:	qla_set_mac_rcv_mode_t rcv_mode;
/usr/src/sys/dev/qlxgb/qla_hw.c:	bzero(&rcv_mode, sizeof(qla_set_mac_rcv_mode_t));
/usr/src/sys/dev/qlxgb/qla_hw.c:	ret = qla_fw_cmd(ha, &rcv_mode, sizeof(qla_set_mac_rcv_mode_t));
/usr/src/sys/dev/qlxgb/qla_hw.c:	(void)qla_set_mac_rcv_mode(ha,
/usr/src/sys/dev/qlxgb/qla_hw.c:	(void)qla_set_mac_rcv_mode(ha,
/usr/src/sys/dev/qlxgb/qla_hw.c:	(void)qla_set_mac_rcv_mode(ha,
/usr/src/sys/dev/qlxgb/qla_hw.c:	qla_config_mac_addr(ha, ha->hw.mac_addr,
/usr/src/sys/dev/qlxgb/qla_hw.c:	qla_config_mac_addr(ha, bcast_mac,
/usr/src/sys/dev/qlxgb/qla_hw.c:	//qla_read_mac_addr(ha);
/usr/src/sys/dev/qlxgb/qla_hw.c:		qla_config_mac_addr(ha, mta, rsp->rx_rsp.cntxt_id, add_multi);
/usr/src/sys/dev/qlxgb/qla_os.c:	qla_read_mac_addr(ha);
/usr/src/sys/dev/qlxgb/qla_os.c:	ether_ifattach(ifp, qla_get_mac_addr(ha));
/usr/src/sys/dev/qlxgb/qla_os.c:	bcopy(IF_LLADDR(ha->ifp), ha->hw.mac_addr, ETHER_ADDR_LEN);
/usr/src/sys/dev/ral/rt2860.c:	sc->mac_ver = tmp >> 16;
/usr/src/sys/dev/ral/rt2860.c:	sc->mac_rev = tmp & 0xffff;
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver != 0x2860 &&
/usr/src/sys/dev/ral/rt2860.c:		    sc->mac_ver, sc->mac_rev, rt2860_get_rf(sc->rf_rev),
/usr/src/sys/dev/ral/rt2860.c:	sc->mgtqid = (sc->mac_ver == 0x2860 && sc->mac_rev == 0x0100) ?
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver == 0x3593 && sc->nrxchains > 2)
/usr/src/sys/dev/ral/rt2860.c:		if (sc->mac_ver == 0x3593 && sc->ntxchains > 2)
/usr/src/sys/dev/ral/rt2860.c:		if (sc->mac_ver == 0x3593 && sc->ntxchains > 2)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver == 0x3593) {
/usr/src/sys/dev/ral/rt2860.c:		if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->patch_dac && sc->mac_rev < 0x0211)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver != 0x3593) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_rev < 0x0211)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver == 0x3593) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_rev >= 0x0211 && !sc->ext_2ghz_lna)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver == 0x3593) {
/usr/src/sys/dev/ral/rt2860.c:		if (sc->mac_rev < 0x0211)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->patch_dac && sc->mac_rev < 0x0211) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_rev >= 0x0211) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_rev < 0x0211) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:		if (sc->mac_ver == 0x3593) {
/usr/src/sys/dev/ral/rt2860.c:		} else if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver == 0x2860 && sc->mac_rev != 0x0101)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:	} else if (sc->mac_ver == 0x2860 && sc->mac_rev == 0x0100) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/ral/rt2860.c:	else if (sc->mac_ver == 0x3593 && sc->ntxchains == 2)
/usr/src/sys/dev/ral/rt2860.c:	else if (sc->mac_ver == 0x3593 && sc->ntxchains == 3)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/ral/rt2860.c:	if (sc->mac_ver >= 0x3071)
/usr/src/sys/dev/rt/if_rt.c:	    sc->mac_rev);
/usr/src/sys/dev/rt/if_rt.c:	ether_request_mac(dev, sc->mac_addr);
/usr/src/sys/dev/rt/if_rt.c:	ether_ifattach(ifp, sc->mac_addr);
/usr/src/sys/dev/safe/safe.c:		MD5Update(&md5ctx, hmac_ipad_buffer, MD5_HMAC_BLOCK_LEN - klen);
/usr/src/sys/dev/safe/safe.c:		SHA1Update(&sha1ctx, hmac_ipad_buffer,
/usr/src/sys/dev/safe/safe.c:		MD5Update(&md5ctx, hmac_opad_buffer, MD5_HMAC_BLOCK_LEN - klen);
/usr/src/sys/dev/safe/safe.c:		SHA1Update(&sha1ctx, hmac_opad_buffer,
/usr/src/sys/dev/sbni/if_sbni.c:	if (flags.mac_addr) {
/usr/src/sys/dev/sbni/if_sbni.c:		    htonl(flags.mac_addr | 0x01000000);
/usr/src/sys/dev/sbni/if_sbni.c:		if (flags.mac_addr)
/usr/src/sys/dev/sfxge/common/efx_ev.c:		epp->ep_mac_poll_needed = B_TRUE;
/usr/src/sys/dev/sfxge/common/efx_ev.c:		if (eecp->eec_mac_stats != NULL) {
/usr/src/sys/dev/sfxge/common/efx_ev.c:			eecp->eec_mac_stats(arg,
/usr/src/sys/dev/sfxge/common/efx_filter.c:efx_filter_spec_rx_mac_full(
/usr/src/sys/dev/sfxge/common/efx_filter.c:efx_filter_spec_rx_mac_wild(
/usr/src/sys/dev/sfxge/common/efx_filter.c:efx_filter_spec_tx_mac_full(
/usr/src/sys/dev/sfxge/common/efx_filter.c:efx_filter_spec_tx_mac_wild(
/usr/src/sys/dev/sfxge/common/efx_mac.c:static efx_mac_ops_t	__cs __efx_falcon_gmac_ops = {
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_gmac_reset,		/* emo_reset */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_poll,		/* emo_poll */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_up,			/* emo_up */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_gmac_reconfigure,	/* emo_reconfigure */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_loopback_set,	/* emo_loopback_set */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_stats_upload,	/* emo_stats_upload */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_gmac_stats_update	/* emo_stats_update */
/usr/src/sys/dev/sfxge/common/efx_mac.c:static efx_mac_ops_t	__cs __efx_falcon_xmac_ops = {
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_xmac_reset,		/* emo_reset */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_poll,		/* emo_poll */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_up,			/* emo_up */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_xmac_reconfigure,	/* emo_reconfigure */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_loopback_set,	/* emo_loopback_set */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_mac_stats_upload,	/* emo_stats_upload */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	falcon_xmac_stats_update	/* emo_stats_update */
/usr/src/sys/dev/sfxge/common/efx_mac.c:static efx_mac_ops_t	__cs __efx_siena_mac_ops = {
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_poll,			/* emo_poll */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_up,			/* emo_up */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_reconfigure,		/* emo_reconfigure */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_loopback_set,		/* emo_loopback_set */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_stats_upload,		/* emo_stats_upload */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_stats_periodic,	/* emo_stats_periodic */
/usr/src/sys/dev/sfxge/common/efx_mac.c:	siena_mac_stats_update		/* emo_stats_update */
/usr/src/sys/dev/sfxge/common/efx_mac.c:static efx_mac_ops_t	__cs * __cs __efx_mac_ops[] = {
/usr/src/sys/dev/sfxge/common/efx_mac.c:	&__efx_falcon_gmac_ops,
/usr/src/sys/dev/sfxge/common/efx_mac.c:	&__efx_falcon_xmac_ops,
/usr/src/sys/dev/sfxge/common/efx_mac.c:	&__efx_siena_mac_ops,
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_pdu_set(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	old_pdu = epp->ep_mac_pdu;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	epp->ep_mac_pdu = (uint32_t)pdu;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	epp->ep_mac_pdu = old_pdu;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_addr_set(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	EFX_MAC_ADDR_COPY(old_addr, epp->ep_mac_addr);
/usr/src/sys/dev/sfxge/common/efx_mac.c:	EFX_MAC_ADDR_COPY(epp->ep_mac_addr, addr);
/usr/src/sys/dev/sfxge/common/efx_mac.c:	EFX_MAC_ADDR_COPY(epp->ep_mac_addr, old_addr);
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_filter_set(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_drain(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	if (epp->ep_mac_drain == enabled)
/usr/src/sys/dev/sfxge/common/efx_mac.c:	epp->ep_mac_drain = enabled;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_up(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	__out		boolean_t *mac_upp)
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	if ((rc = emop->emo_up(enp, mac_upp)) != 0)
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_fcntl_set(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_fcntl_get(
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_hash_set(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:static const char 	__cs * __cs __efx_mac_stat_name[] = {
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_stat_name(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	return (__efx_mac_stat_name[id]);
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_stats_upload(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	 * Don't assert !ep_mac_stats_pending, because the client might
/usr/src/sys/dev/sfxge/common/efx_mac.c:	epp->ep_mac_stats_pending = B_TRUE;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_stats_periodic(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_stats_update(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:		epp->ep_mac_stats_pending = B_FALSE;
/usr/src/sys/dev/sfxge/common/efx_mac.c:efx_mac_select(
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_type_t type = EFX_MAC_INVALID;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	efx_mac_ops_t *emop;
/usr/src/sys/dev/sfxge/common/efx_mac.c:	emop = epp->ep_emop = (efx_mac_ops_t *)__efx_mac_ops[type];
/usr/src/sys/dev/sfxge/common/efx_mac.c:	epp->ep_mac_type = type;
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_type = EFX_MAC_INVALID;
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_poll_needed = B_TRUE;
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_drain = B_TRUE;
/usr/src/sys/dev/sfxge/common/efx_port.c:	if ((rc = efx_mac_select(enp)) != 0)
/usr/src/sys/dev/sfxge/common/efx_port.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_port.c:	EFSYS_ASSERT(!epp->ep_mac_stats_pending);
/usr/src/sys/dev/sfxge/common/efx_port.c:	efx_mac_ops_t *emop = epp->ep_emop;
/usr/src/sys/dev/sfxge/common/efx_port.c:	EFSYS_ASSERT(epp->ep_mac_drain);
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_type = EFX_MAC_INVALID;
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_drain = B_FALSE;
/usr/src/sys/dev/sfxge/common/efx_port.c:	epp->ep_mac_poll_needed = B_FALSE;
/usr/src/sys/dev/sfxge/common/efx_wol.c:			paramp->ewp_magic.mac_addr);
/usr/src/sys/dev/sfxge/common/efx_wol.c:				    paramp->elop_arp.mac_addr);
/usr/src/sys/dev/sfxge/common/efx_wol.c:				    paramp->elop_ns.mac_addr);
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_poll(
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_up(
/usr/src/sys/dev/sfxge/common/siena_mac.c:	__out		boolean_t *mac_upp)
/usr/src/sys/dev/sfxge/common/siena_mac.c:	 * siena_mac_poll() being executed to populate epp->ep_mac_up.
/usr/src/sys/dev/sfxge/common/siena_mac.c:	*mac_upp = sls.sls_mac_up;
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_reconfigure(
/usr/src/sys/dev/sfxge/common/siena_mac.c:	MCDI_IN_SET_DWORD(req, SET_MAC_IN_MTU, epp->ep_mac_pdu);
/usr/src/sys/dev/sfxge/common/siena_mac.c:	MCDI_IN_SET_DWORD(req, SET_MAC_IN_DRAIN, epp->ep_mac_drain ? 1 : 0);
/usr/src/sys/dev/sfxge/common/siena_mac.c:			    epp->ep_mac_addr);
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_loopback_set(
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_stats_clear(
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_stats_upload(
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_stats_periodic(
/usr/src/sys/dev/sfxge/common/siena_mac.c:siena_mac_stats_update(
/usr/src/sys/dev/sfxge/common/siena_nic.c:	EFX_MAC_ADDR_COPY(encp->enc_mac_addr, src);
/usr/src/sys/dev/sfxge/common/siena_nic.c:	if ((rc = siena_mac_stats_clear(enp)) != 0)
/usr/src/sys/dev/sfxge/common/siena_phy.c:	 * because we can race with efx_mac_fcntl_set().
/usr/src/sys/dev/sfxge/common/siena_phy.c:	slsp->sls_mac_up = MCDI_OUT_DWORD(req, GET_LINK_OUT_MAC_FAULT) == 0;
/usr/src/sys/dev/sfxge/sfxge.c:					sfxge_mac_filter_set(sc);
/usr/src/sys/dev/sfxge/sfxge.c:			sfxge_mac_filter_set(sc);
/usr/src/sys/dev/sfxge/sfxge.c:	ether_ifattach(ifp, encp->enc_mac_addr);
/usr/src/sys/dev/sfxge/sfxge_ev.c:	sfxge_mac_link_update(sc, link_mode);
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_stat_update(struct sfxge_softc *sc)
/usr/src/sys/dev/sfxge/sfxge_port.c:	efsys_mem_t *esmp = &(port->mac_stats.dma_buf);
/usr/src/sys/dev/sfxge/sfxge_port.c:	if (now - port->mac_stats.update_time < hz) {
/usr/src/sys/dev/sfxge/sfxge_port.c:	port->mac_stats.update_time = now;
/usr/src/sys/dev/sfxge/sfxge_port.c:		if ((rc = efx_mac_stats_update(sc->enp, esmp,
/usr/src/sys/dev/sfxge/sfxge_port.c:                    port->mac_stats.decode_buf, NULL)) != EAGAIN)
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_stat_handler(SYSCTL_HANDLER_ARGS)
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = sfxge_mac_stat_update(sc)) != 0)
/usr/src/sys/dev/sfxge/sfxge_port.c:			  (uint64_t *)sc->port.mac_stats.decode_buf + id,
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_stat_init(struct sfxge_softc *sc)
/usr/src/sys/dev/sfxge/sfxge_port.c:		name = efx_mac_stat_name(sc->enp, id);
/usr/src/sys/dev/sfxge/sfxge_port.c:			sc, id, sfxge_mac_stat_handler, "Q",
/usr/src/sys/dev/sfxge/sfxge_port.c:	efx_mac_fcntl_get(sc->enp, &wanted_fc, &link_fc);
/usr/src/sys/dev/sfxge/sfxge_port.c:		error = efx_mac_fcntl_set(sc->enp, port->wanted_fc, B_TRUE);
/usr/src/sys/dev/sfxge/sfxge_port.c:		efx_mac_fcntl_get(sc->enp, &wanted_fc, &link_fc);
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_link_update(struct sfxge_softc *sc, efx_link_mode_t mode)
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_poll_work(void *arg, int npending)
/usr/src/sys/dev/sfxge/sfxge_port.c:	sfxge_mac_link_update(sc, mode);
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_filter_set_locked(struct sfxge_softc *sc)
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_filter_set(enp, !!(ifp->if_flags & IFF_PROMISC),
/usr/src/sys/dev/sfxge/sfxge_port.c:	return efx_mac_hash_set(enp, bucket);
/usr/src/sys/dev/sfxge/sfxge_port.c:sfxge_mac_filter_set(struct sfxge_softc *sc)
/usr/src/sys/dev/sfxge/sfxge_port.c:	rc = sfxge_mac_filter_set_locked(sc);
/usr/src/sys/dev/sfxge/sfxge_port.c:	port->mac_stats.update_time = 0;
/usr/src/sys/dev/sfxge/sfxge_port.c:	(void)efx_mac_drain(enp, B_TRUE);
/usr/src/sys/dev/sfxge/sfxge_port.c:	(void)efx_mac_stats_periodic(enp, &port->mac_stats.dma_buf, 0, B_FALSE);
/usr/src/sys/dev/sfxge/sfxge_port.c:	uint8_t mac_addr[ETHER_ADDR_LEN];
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_pdu_set(enp, pdu)) != 0)
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_fcntl_set(enp, sfxge_port_wanted_fc(sc), B_TRUE))
/usr/src/sys/dev/sfxge/sfxge_port.c:	      mac_addr, sizeof(mac_addr));
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_addr_set(enp, mac_addr)) != 0)
/usr/src/sys/dev/sfxge/sfxge_port.c:	sfxge_mac_filter_set_locked(sc);
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_stats_periodic(enp, &port->mac_stats.dma_buf,
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = efx_mac_drain(enp, B_FALSE)) != 0)
/usr/src/sys/dev/sfxge/sfxge_port.c:	sfxge_mac_poll_work(sc, 0);
/usr/src/sys/dev/sfxge/sfxge_port.c:	(void)efx_mac_drain(enp, B_TRUE);
/usr/src/sys/dev/sfxge/sfxge_port.c:	(void)efx_mac_stats_periodic(enp, &port->mac_stats.dma_buf,
/usr/src/sys/dev/sfxge/sfxge_port.c:	esmp = &port->mac_stats.dma_buf;
/usr/src/sys/dev/sfxge/sfxge_port.c:	free(port->mac_stats.decode_buf, M_SFXGE);
/usr/src/sys/dev/sfxge/sfxge_port.c:	efsys_mem_t *mac_stats_buf, *phy_stats_buf;
/usr/src/sys/dev/sfxge/sfxge_port.c:	mac_stats_buf = &port->mac_stats.dma_buf;
/usr/src/sys/dev/sfxge/sfxge_port.c:	port->mac_stats.decode_buf = malloc(EFX_MAC_NSTATS * sizeof(uint64_t),
/usr/src/sys/dev/sfxge/sfxge_port.c:	if ((rc = sfxge_dma_alloc(sc, EFX_MAC_STATS_SIZE, mac_stats_buf)) != 0)
/usr/src/sys/dev/sfxge/sfxge_port.c:	bzero(mac_stats_buf->esm_base, mac_stats_buf->esm_size);
/usr/src/sys/dev/sfxge/sfxge_port.c:	sfxge_mac_stat_init(sc);
/usr/src/sys/dev/sfxge/sfxge_port.c:	free(port->mac_stats.decode_buf, M_SFXGE);
/usr/src/sys/dev/sfxge/sfxge_port.c:	rc = efx_mac_fcntl_set(sc->enp, sfxge_port_wanted_fc(sc), B_TRUE);
/usr/src/sys/dev/sge/if_sge.c:static int	sge_get_mac_addr_apc(struct sge_softc *, uint8_t *);
/usr/src/sys/dev/sge/if_sge.c:static int	sge_get_mac_addr_eeprom(struct sge_softc *, uint8_t *);
/usr/src/sys/dev/sge/if_sge.c:sge_get_mac_addr_eeprom(struct sge_softc *sc, uint8_t *dest)
/usr/src/sys/dev/sge/if_sge.c:sge_get_mac_addr_apc(struct sge_softc *sc, uint8_t *dest)
/usr/src/sys/dev/sge/if_sge.c:		sge_get_mac_addr_apc(sc, eaddr);
/usr/src/sys/dev/sge/if_sge.c:		sge_get_mac_addr_eeprom(sc, eaddr);
/usr/src/sys/dev/siba/siba_core.c:	memset(sprom->mac_eth, 0xff, 6);
/usr/src/sys/dev/siba/siba_core.c:	memset(sprom->mac_80211a, 0xff, 6);
/usr/src/sys/dev/siba/siba_core.c:		*(((uint16_t *)out->mac_80211bg) + i) = htobe16(v);
/usr/src/sys/dev/siba/siba_core.c:			*(((uint16_t *)out->mac_eth) + i) = htobe16(v);
/usr/src/sys/dev/siba/siba_core.c:			*(((uint16_t *)out->mac_80211a) + i) = htobe16(v);
/usr/src/sys/dev/siba/siba_core.c:	uint16_t mac_80211bg_offset;
/usr/src/sys/dev/siba/siba_core.c:		mac_80211bg_offset = SIBA_SPROM4_MAC_80211BG;
/usr/src/sys/dev/siba/siba_core.c:		mac_80211bg_offset = SIBA_SPROM5_MAC_80211BG;
/usr/src/sys/dev/siba/siba_core.c:		v = in[SIBA_OFFSET(mac_80211bg_offset) + i];
/usr/src/sys/dev/siba/siba_core.c:		*(((uint16_t *)out->mac_80211bg) + i) = htobe16(v);
/usr/src/sys/dev/siba/siba_core.c:		*(((uint16_t *)out->mac_80211bg) + i) = htobe16(v);
/usr/src/sys/dev/siba/siba_core.c:		*((uint8_t **) result) = siba->siba_sprom.mac_80211bg;
/usr/src/sys/dev/siba/siba_core.c:		*((uint8_t **) result) = siba->siba_sprom.mac_eth;
/usr/src/sys/dev/siba/siba_core.c:		*((uint8_t **) result) = siba->siba_sprom.mac_80211a;
/usr/src/sys/dev/sk/if_sk.c:static int sk_xmac_miibus_readreg(struct sk_if_softc *, int, int);
/usr/src/sys/dev/sk/if_sk.c:static int sk_xmac_miibus_writereg(struct sk_if_softc *, int, int,
/usr/src/sys/dev/sk/if_sk.c:static void sk_xmac_miibus_statchg(struct sk_if_softc *);
/usr/src/sys/dev/sk/if_sk.c:		v = sk_xmac_miibus_readreg(sc_if, phy, reg);
/usr/src/sys/dev/sk/if_sk.c:		v = sk_xmac_miibus_writereg(sc_if, phy, reg, val);
/usr/src/sys/dev/sk/if_sk.c:		sk_xmac_miibus_statchg(sc_if);
/usr/src/sys/dev/sk/if_sk.c:sk_xmac_miibus_readreg(sc_if, phy, reg)
/usr/src/sys/dev/sk/if_sk.c:sk_xmac_miibus_writereg(sc_if, phy, reg, val)
/usr/src/sys/dev/sk/if_sk.c:sk_xmac_miibus_statchg(sc_if)
/usr/src/sys/dev/sk/if_sk.c:		rxstat = le32toh(cur_rx->sk_xmac_rxstat);
/usr/src/sys/dev/sk/if_sk.c:		rxstat = le32toh(cur_rx->sk_xmac_rxstat);
/usr/src/sys/dev/sk/if_sk.c:	status = sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM, BRGPHY_MII_ISR);
/usr/src/sys/dev/sk/if_sk.c:		lstat = sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM,
/usr/src/sys/dev/sk/if_sk.c:			sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,
/usr/src/sys/dev/sk/if_sk.c:	sc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));
/usr/src/sys/dev/sk/if_sk.c:		sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,
/usr/src/sys/dev/sk/if_sk.c:		sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,
/usr/src/sys/dev/sk/if_sk.c:		if (sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM, 0x03)
/usr/src/sys/dev/sk/if_sk.c:				sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,
/usr/src/sys/dev/sk/if_sk.c:	switch(sc_if->sk_xmac_rev) {
/usr/src/sys/dev/sound/pci/vibes.c:	struct resource		*dmaa_reg, *dmac_reg;
/usr/src/sys/dev/sound/pci/vibes.c:	bus_space_tag_t		dmaa_st, dmac_st;
/usr/src/sys/dev/sound/pci/vibes.c:	bus_space_handle_t	dmaa_sh, dmac_sh;
/usr/src/sys/dev/sound/pci/vibes.c:	int			dmaa_type, dmac_type;
/usr/src/sys/dev/sound/pci/vibes.c:	int			dmaa_rid, dmac_rid;
/usr/src/sys/dev/sound/pci/vibes.c:		sv_dma_set_config(sc->dmac_st, sc->dmac_sh,
/usr/src/sys/dev/sound/pci/vibes.c:	remain = (sv_dma_get_count(sc->dmac_st, sc->dmac_sh) + 1) * 2;
/usr/src/sys/dev/sound/pci/vibes.c:	sc->dmac_rid = SV_PCI_DMAC;
/usr/src/sys/dev/sound/pci/vibes.c:	sc->dmac_type = SYS_RES_IOPORT;
/usr/src/sys/dev/sound/pci/vibes.c:	sc->dmac_reg  = bus_alloc_resource(dev, sc->dmac_type,
/usr/src/sys/dev/sound/pci/vibes.c:					   &sc->dmac_rid, 0, ~0,
/usr/src/sys/dev/sound/pci/vibes.c:	if (sc->dmac_reg == NULL) {
/usr/src/sys/dev/sound/pci/vibes.c:	sc->dmac_st = rman_get_bustag(sc->dmac_reg);
/usr/src/sys/dev/sound/pci/vibes.c:	sc->dmac_sh = rman_get_bushandle(sc->dmac_reg);
/usr/src/sys/dev/sound/pci/vibes.c:	if (sc->dmac_reg)
/usr/src/sys/dev/sound/pci/vibes.c:		bus_release_resource(dev, sc->dmac_type, sc->dmac_rid, sc->dmac_reg);
/usr/src/sys/dev/sound/pci/vibes.c:	bus_release_resource(dev, sc->dmac_type, sc->dmac_rid, sc->dmac_reg);
/usr/src/sys/dev/tsec/if_tsec.c:static void	tsec_set_mac_address(struct tsec_softc *sc);
/usr/src/sys/dev/tsec/if_tsec.c:	tsec_set_mac_address(sc);
/usr/src/sys/dev/tsec/if_tsec.c:tsec_set_mac_address(struct tsec_softc *sc)
/usr/src/sys/dev/tsec/if_tsec.c:	    ("tsec_set_mac_address: (%d <= %d", ETHER_ADDR_LEN,
/usr/src/sys/dev/ubsec/ubsec.c:		MD5Update(&md5ctx, hmac_ipad_buffer, MD5_HMAC_BLOCK_LEN - klen);
/usr/src/sys/dev/ubsec/ubsec.c:		SHA1Update(&sha1ctx, hmac_ipad_buffer,
/usr/src/sys/dev/ubsec/ubsec.c:		MD5Update(&md5ctx, hmac_opad_buffer, MD5_HMAC_BLOCK_LEN - klen);
/usr/src/sys/dev/ubsec/ubsec.c:		SHA1Update(&sha1ctx, hmac_opad_buffer,
/usr/src/sys/dev/usb/net/if_ipheth.c:ipheth_get_mac_addr(struct ipheth_softc *sc)
/usr/src/sys/dev/usb/net/if_ipheth.c:	error = ipheth_get_mac_addr(sc);
/usr/src/sys/dev/usb/wlan/if_run.c:	sc->mac_ver = ver >> 16;
/usr/src/sys/dev/usb/wlan/if_run.c:	sc->mac_rev = ver & 0xffff;
/usr/src/sys/dev/usb/wlan/if_run.c:	    sc->mac_ver, sc->mac_rev, run_get_rf(sc->rf_rev),
/usr/src/sys/dev/usb/wlan/if_run.c:	if ((sc->mac_ver) != 0x2860 &&
/usr/src/sys/dev/usb/wlan/if_run.c:	    (sc->mac_ver) != 0x2872 &&
/usr/src/sys/dev/usb/wlan/if_run.c:	    (sc->mac_ver) != 0x3070) { 
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:		} else if (sc->mac_ver >= 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_ver == 0x3572)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_ver >= 0x3070)
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_ver == 0x3572)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572)
/usr/src/sys/dev/usb/wlan/if_run.c:	else if (sc->mac_ver >= 0x3070)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x2860 && sc->mac_rev != 0x0101)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_ver == 0x2860 && sc->mac_rev == 0x0100) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_ver == 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev < 0x0211)
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev < 0x0211 || !sc->patch_dac) {
/usr/src/sys/dev/usb/wlan/if_run.c:	target = (sc->mac_ver < 0x3071) ? 0x16 : 0x13;
/usr/src/sys/dev/usb/wlan/if_run.c:	target = (sc->mac_ver < 0x3071) ? 0x19 : 0x15;
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_rev < 0x0211)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3070 || sc->mac_ver == 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if ((sc->mac_ver == 0x3070 ||
/usr/src/sys/dev/usb/wlan/if_run.c:		     (sc->mac_ver == 0x3071 && sc->mac_rev >= 0x0211)) &&
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_rev == 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3070 || sc->mac_ver == 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev < 0x0211)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver == 0x3572) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev >= 0x0201)
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev >= 0x0211) {
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_ver == 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev >= 0x0201)
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev >= 0x0211) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev < 0x0211) {
/usr/src/sys/dev/usb/wlan/if_run.c:	} else if (sc->mac_ver == 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev >= 0x0201) {
/usr/src/sys/dev/usb/wlan/if_run.c:		if (sc->mac_rev < 0x0211) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3071) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070) {
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_rev != 0x0101)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070)
/usr/src/sys/dev/usb/wlan/if_run.c:	if (sc->mac_ver >= 0x3070)
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_stats *stats;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	mem = (struct upgt_lmac_mem *)data_cmd->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	stats = (struct upgt_lmac_stats *)(mem + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_stats) - sizeof(struct upgt_lmac_header));
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_led *led;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	mem = (struct upgt_lmac_mem *)data_cmd->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	led = (struct upgt_lmac_led *)(mem + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_led) -
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_header));
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_filter *filter;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	mem = (struct upgt_lmac_mem *)data_cmd->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	filter = (struct upgt_lmac_filter *)(mem + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_filter) -
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_header));
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_channel *chan;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	mem = (struct upgt_lmac_mem *)data_cmd->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	chan = (struct upgt_lmac_channel *)(mem + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	    sizeof(struct upgt_lmac_channel) - sizeof(struct upgt_lmac_header));
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_freq3 *freq3;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	freq3 = (struct upgt_lmac_freq3 *)(freq3_header + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_freq6 *freq6;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	freq6 = (struct upgt_lmac_freq6 *)data;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	elements = len / sizeof(struct upgt_lmac_freq6);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_eeprom	*eeprom;
/usr/src/sys/dev/usb/wlan/if_upgt.c:		mem = (struct upgt_lmac_mem *)data_cmd->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:		eeprom = (struct upgt_lmac_eeprom *)(mem + 1);
/usr/src/sys/dev/usb/wlan/if_upgt.c:		    sizeof(struct upgt_lmac_eeprom) -
/usr/src/sys/dev/usb/wlan/if_upgt.c:		    sizeof(struct upgt_lmac_header)) + block);
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_header *header;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_eeprom *eeprom;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	header = (struct upgt_lmac_header *)(data->buf + 4);
/usr/src/sys/dev/usb/wlan/if_upgt.c:		eeprom = (struct upgt_lmac_eeprom *)(data->buf + 4);
/usr/src/sys/dev/usb/wlan/if_upgt.c:		    data->buf + sizeof(struct upgt_lmac_eeprom) + 4,
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_rx_desc *rxdesc;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	rxdesc = (struct upgt_lmac_rx_desc *)data;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_tx_done_desc *desc;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	desc = (struct upgt_lmac_tx_done_desc *)data;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_mem *mem;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	struct upgt_lmac_tx_desc *txdesc;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	mem = (struct upgt_lmac_mem *)data->buf;
/usr/src/sys/dev/usb/wlan/if_upgt.c:	txdesc = (struct upgt_lmac_tx_desc *)(mem + 1);
/usr/src/sys/dev/virtio/network/if_vtnet.c:			sc->vtnet_mac_filter = malloc(
/usr/src/sys/dev/virtio/network/if_vtnet.c:			    sizeof(struct vtnet_mac_filter), M_DEVBUF,
/usr/src/sys/dev/virtio/network/if_vtnet.c:			if (sc->vtnet_mac_filter == NULL) {
/usr/src/sys/dev/virtio/network/if_vtnet.c:	if (sc->vtnet_mac_filter != NULL) {
/usr/src/sys/dev/virtio/network/if_vtnet.c:		free(sc->vtnet_mac_filter, M_DEVBUF);
/usr/src/sys/dev/virtio/network/if_vtnet.c:		sc->vtnet_mac_filter = NULL;
/usr/src/sys/dev/virtio/network/if_vtnet.c:	struct vtnet_mac_filter *filter;
/usr/src/sys/dev/virtio/network/if_vtnet.c:	filter = sc->vtnet_mac_filter;
/usr/src/sys/dev/vte/if_vte.c:static void	vte_mac_config(struct vte_softc *);
/usr/src/sys/dev/vte/if_vte.c:		vte_mac_config(sc);
/usr/src/sys/dev/vte/if_vte.c:vte_mac_config(struct vte_softc *sc)
/usr/src/sys/dev/vxge/vxge.c:		vxge_os_memcpy((u8 *) vdev->vpaths[j].mac_addr,
/usr/src/sys/dev/vxge/vxge.c:		    (u8 *) (vdev->config.hw_info.mac_addrs[i]),
/usr/src/sys/dev/vxge/vxge.c:	ether_ifattach(ifp, vdev->vpaths[0].mac_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_en != VXGE_HAL_WIRE_PORT_TMAC_ENABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_en != VXGE_HAL_WIRE_PORT_TMAC_DISABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_en != VXGE_HAL_WIRE_PORT_TMAC_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_en != VXGE_HAL_WIRE_PORT_RMAC_ENABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_en != VXGE_HAL_WIRE_PORT_RMAC_DISABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_en != VXGE_HAL_WIRE_PORT_RMAC_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_pad != VXGE_HAL_WIRE_PORT_TMAC_NO_PAD) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad != VXGE_HAL_WIRE_PORT_TMAC_64B_PAD) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad != VXGE_HAL_WIRE_PORT_TMAC_PAD_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_pad_byte >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad_byte !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_util_period >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_util_period >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if (((port_config->rmac_pause_time <
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_time >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_en != VXGE_HAL_SWITCH_PORT_TMAC_ENABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_en != VXGE_HAL_SWITCH_PORT_TMAC_DISABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_en != VXGE_HAL_SWITCH_PORT_TMAC_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_en != VXGE_HAL_SWITCH_PORT_RMAC_ENABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_en != VXGE_HAL_SWITCH_PORT_RMAC_DISABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_en != VXGE_HAL_SWITCH_PORT_RMAC_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_pad != VXGE_HAL_SWITCH_PORT_TMAC_NO_PAD) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad != VXGE_HAL_SWITCH_PORT_TMAC_64B_PAD) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad != VXGE_HAL_SWITCH_PORT_TMAC_PAD_DEFAULT))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_pad_byte >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_pad_byte !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->tmac_util_period >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->tmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_util_period >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if (((port_config->rmac_pause_time <
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_time >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (port_config->rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c: * __hal_device_mac_config_check - Check mac port configuration.
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c: * @mac_config: MAC configuration information
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:__hal_device_mac_config_check(vxge_hal_mac_config_t *mac_config)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &mac_config->wire_port_config[0]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &mac_config->wire_port_config[1]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &mac_config->switch_port_config);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->network_stability_period >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->network_stability_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		if ((mac_config->mc_pause_threshold[i] >
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		    (mac_config->mc_pause_threshold[i] !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_perma_stop_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_perma_stop_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_perma_stop_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_tx_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_tx_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_tx_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_lossy_switch_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_lossy_switch_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_lossy_switch_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_lossy_wire_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_lossy_wire_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_lossy_wire_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_bcast_to_wire_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_bcast_to_wire_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_bcast_to_wire_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_bcast_to_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_bcast_to_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_bcast_to_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tmac_host_append_fcs_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_host_append_fcs_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tmac_host_append_fcs_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->tpa_ecc_enable_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tpa_ecc_enable_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->tpa_ecc_enable_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_ignore_frame_err !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_ignore_frame_err !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_ignore_frame_err !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_search_for_hao !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_search_for_hao !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_search_for_hao !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_support_ipv6_mobile_hdrs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_support_ipv6_mobile_hdrs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_support_ipv6_mobile_hdrs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_ipv6_stop_searching !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_ipv6_stop_searching !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_ipv6_stop_searching !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_no_ps_if_unknown !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_no_ps_if_unknown !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_no_ps_if_unknown !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_search_for_etype !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_search_for_etype !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_search_for_etype !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_l4_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l4_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l4_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_l3_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l3_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l3_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_l3_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l3_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l3_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_ipv4_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv4_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv4_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_ipv6_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv6_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv6_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_ipv4_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv4_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv4_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_ipv6_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv6_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_ipv6_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_l4_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l4_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_l4_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((mac_config->rpa_repl_strip_vlan_tag !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_strip_vlan_tag !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (mac_config->rpa_repl_strip_vlan_tag !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((aggr_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (aggr_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (aggr_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((aggr_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (aggr_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (aggr_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((lag_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (lag_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (lag_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((lag_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (lag_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (lag_config->mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((status = __hal_device_mac_config_check(&config->mac_config)) !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	if ((new_config->rts_mac_en != VXGE_HAL_RTS_MAC_DISABLE) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    (new_config->rts_mac_en != VXGE_HAL_RTS_MAC_ENABLE))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	vxge_hal_mac_config_t *mac_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config = &device_config->mrpcim_config.mac_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config = &mac_config->wire_port_config[i];
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->tmac_pad =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->tmac_pad_byte =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->tmac_util_period =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_strip_fcs =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_prom_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_discard_pfrm =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_util_period =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_pause_gen_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_pause_rcv_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		wire_port_config->rmac_pause_time =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config = &mac_config->switch_port_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->tmac_pad =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->tmac_pad_byte =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->tmac_util_period =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_strip_fcs =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_prom_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_discard_pfrm =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_util_period =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_pause_gen_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_pause_rcv_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	switch_port_config->rmac_pause_time =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->network_stability_period =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		mac_config->mc_pause_threshold[i] =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_perma_stop_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_tx_switch_dis =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_lossy_switch_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_lossy_wire_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_bcast_to_wire_dis =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_bcast_to_switch_dis =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tmac_host_append_fcs_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tpa_support_snap_ab_n =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->tpa_ecc_enable_n =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_ignore_frame_err =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_support_snap_ab_n =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_search_for_hao =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_support_ipv6_mobile_hdrs =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_ipv6_stop_searching =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_no_ps_if_unknown =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_search_for_etype =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_l4_comp_csum =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_l3_incl_cf =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_l3_comp_csum =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_ipv4_tcp_incl_ph =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_ipv6_tcp_incl_ph =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_ipv4_udp_incl_ph =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_ipv6_udp_incl_ph =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_l4_incl_cf =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	mac_config->rpa_repl_strip_vlan_tag =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		    mrpcim_config.lag_config.aggr_config[i].use_port_mac_addr =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:		    mrpcim_config.lag_config.aggr_config[i].mac_addr_sel =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	device_config->mrpcim_config.lag_config.use_port_mac_addr =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	device_config->mrpcim_config.lag_config.mac_addr_sel =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	device_config->rts_mac_en = VXGE_HAL_RTS_MAC_DEFAULT;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-config.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:			    &mrpcim_reg->xgmac_gen_fw_memo_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		    hw_info->mac_addrs[i], hw_info->mac_addr_masks[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c: * vxge_hal_device_xmac_stats_get - Get the Device XMAC Statistics
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c: * @xmac_stats: Buffer to return XMAC Statistics.
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:vxge_hal_device_xmac_stats_get(vxge_hal_device_h devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:    vxge_hal_device_xmac_stats_t *xmac_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:	vxge_assert((hldev != NULL) && (xmac_stats != NULL));
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:	    "devh = 0x"VXGE_OS_STXFMT", xmac_stats = 0x"VXGE_OS_STXFMT,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:	    (ptr_t) devh, (ptr_t) xmac_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		status = __hal_vpath_xmac_tx_stats_get(&hldev->virtual_paths[i],
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		    &xmac_stats->vpath_tx_stats[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		status = __hal_vpath_xmac_rx_stats_get(&hldev->virtual_paths[i],
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		    &xmac_stats->vpath_rx_stats[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-device.c:		    rxmac_pause_cfg_port_vpmgmt_clone[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmt.c:	    &hldev->mrpcim_reg->xmac_cfg_port[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmt.c:	    &hldev->mrpcim_reg->xmac_cfg_port[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	vxge_hal_mac_config_t *mac_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		mac_config = &dev_config->mrpcim_config.mac_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].port_id, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].media, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].mtu, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].autoneg_mode, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].fixed_use_fsm, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].antp_use_fsm, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].anbe_use_fsm, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].link_stability_period,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].port_stability_period,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("tmac_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].tmac_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("tmac_pad",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].tmac_pad, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("tmac_pad_byte",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].tmac_pad_byte, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("tmac_util_period",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].tmac_util_period, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_strip_fcs",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_strip_fcs, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_prom_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_prom_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_discard_pfrm",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_discard_pfrm, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_util_period",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_util_period, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_pause_gen_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_pause_gen_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_pause_rcv_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_pause_rcv_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		__HAL_AUX_CONFIG_ENTRY("rmac_pause_time",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].rmac_pause_time, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].limiter_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->wire_port_config[i].max_limit, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.mtu, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.tmac_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_pad",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.tmac_pad, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_pad_byte",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.tmac_pad_byte, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_util_period",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.tmac_util_period, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_strip_fcs",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_strip_fcs, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_prom_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_prom_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_discard_pfrm",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_discard_pfrm, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_util_period",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_util_period, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_pause_gen_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_pause_gen_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_pause_rcv_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_pause_rcv_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("rmac_pause_time",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.rmac_pause_time, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.limiter_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->switch_port_config.max_limit, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->network_stability_period, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:		    mac_config->mc_pause_threshold[i], "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_perma_stop_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_perma_stop_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_tx_switch_dis",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_tx_switch_dis, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_lossy_switch_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_lossy_switch_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_lossy_wire_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_lossy_wire_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_bcast_to_wire_dis",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_bcast_to_wire_dis, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_bcast_to_switch_dis",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_bcast_to_switch_dis, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_CONFIG_ENTRY("tmac_host_append_fcs_en",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tmac_host_append_fcs_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tpa_support_snap_ab_n, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->tpa_ecc_enable_n, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_ignore_frame_err, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_support_snap_ab_n, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_search_for_hao, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_support_ipv6_mobile_hdrs, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_ipv6_stop_searching, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_no_ps_if_unknown, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_search_for_etype, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_l4_comp_csum, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_l3_incl_cf, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_l3_comp_csum, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_ipv4_tcp_incl_ph, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_ipv6_tcp_incl_ph, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_ipv4_udp_incl_ph, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_ipv6_udp_incl_ph, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_l4_incl_cf, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mac_config->rpa_repl_strip_vlan_tag, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    dev_config->rts_mac_en, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_vld_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_vld_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_rst_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_parse_error, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_unknown_protocol, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_drop_ip, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_any_err_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].tx_drop_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_vld_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_offload_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_offload_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_vld_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_vld_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_accepted_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_accepted_nucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_long_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_usized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_osized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_frag_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_jabber_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_64_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_65_127_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_128_255_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_256_511_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_512_1023_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_1024_1518_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_1519_4095_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_4096_8191_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_8192_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ttl_gt_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_accepted_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_err_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_err_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_pause_count, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_unsup_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_fcs_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_in_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_out_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_drop_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_drop_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_drop_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_unknown_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_fcs_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_illegal_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_switch_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_len_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_rpa_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_l2_mgmt_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_rts_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_trash_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_buff_full_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_red_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_ctrl_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_data_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_err_sym, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_local_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_jettison, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[0].rx_remote_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_vld_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_vld_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_rst_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_parse_error, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_unknown_protocol, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_drop_ip, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_any_err_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].tx_drop_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_vld_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_offload_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_offload_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_vld_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_vld_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_accepted_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_accepted_nucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_long_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_usized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_osized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_frag_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_jabber_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_64_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_65_127_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_128_255_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_256_511_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_512_1023_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_1024_1518_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_1519_4095_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_4096_8191_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_8192_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ttl_gt_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_accepted_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_err_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_err_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_pause_count, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_unsup_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_fcs_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_in_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_out_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_drop_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_drop_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_drop_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_unknown_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_fcs_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_illegal_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_switch_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_len_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_rpa_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_l2_mgmt_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_rts_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_trash_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_buff_full_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_red_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_ctrl_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_data_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_err_sym, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_local_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_jettison, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[1].rx_remote_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_vld_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_vld_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_rst_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_parse_error, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_unknown_protocol, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_drop_ip, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_any_err_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].tx_drop_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_vld_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_offload_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_offload_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_vld_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_vld_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_accepted_ucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_accepted_nucast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_tagged_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_long_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_usized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_osized_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_frag_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_jabber_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_64_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_65_127_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_128_255_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_256_511_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_512_1023_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_1024_1518_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_1519_4095_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_4096_8191_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_8192_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ttl_gt_max_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_accepted_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_ip_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_err_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_icmp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_err_tcp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_pause_count, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_pause_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_unsup_ctrl_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_fcs_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_in_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_out_rng_len_err_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_drop_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_drop_ip, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_drop_udp, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_marker_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_lacpdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_unknown_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_marker_resp_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_fcs_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_illegal_pdu_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_switch_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_len_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_rpa_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_l2_mgmt_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_rts_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_trash_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_buff_full_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_red_discard, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_ctrl_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_data_err_cnt, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_char1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_err_sym, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_column1_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_char2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_local_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_xgmii_column2_match, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_jettison, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port[2].rx_remote_fault, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].tx_errored_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_errored_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[0].rx_unknown_slow_proto_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].tx_errored_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_data_octets, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_mcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_bcast_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_discarded_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_errored_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_aggr[1].rx_unknown_slow_proto_frms, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_global_prog_event_gnum0",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_global_prog_event_gnum0, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_global_prog_event_gnum1",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_global_prog_event_gnum1, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_orp_lro_events",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_orp_lro_events, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_orp_bs_events",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_orp_bs_events, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_orp_iwarp_events",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_orp_iwarp_events, "%llu");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_tx_permitted_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_tx_permitted_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port2_tx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port2_tx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port1_tx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port1_tx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port0_tx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port0_tx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port2_rx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port2_rx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port1_rx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port1_rx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	__HAL_AUX_ENTRY("xgmac_port0_rx_any_frms",
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mgmtaux.c:	    mrpcim_info.xgmac_port0_rx_any_frms, "%u");
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->xmac_gen_err_reg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->xgmac_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->rxmac_ecc_err_reg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->rxmac_various_err_reg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->rxmac_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->txmac_gen_err_reg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->txmac_ecc_err_reg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_CLEAR(&mrpcim_reg->tmac_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_UNMASK(val64, &mrpcim_reg->xmac_gen_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_UNMASK(val64, &mrpcim_reg->xgmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_reg->rxmac_ecc_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_reg->rxmac_various_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_UNMASK(val64, &mrpcim_reg->rxmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_reg->txmac_gen_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_reg->txmac_ecc_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_UNMASK(val64, &mrpcim_reg->tmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->xmac_gen_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->xgmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->rxmac_ecc_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->rxmac_various_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->rxmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->txmac_gen_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->txmac_ecc_err_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	VXGE_HAL_MRPCIM_ERROR_REG_MASK(&mrpcim_reg->tmac_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = __hal_mrpcim_mac_configure(hldev);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_authorize_all_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_authorize_all_vid);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->xmac_stats_sys_cmd);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->xmac_stats_sys_cmd);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->xmac_stats_sys_cmd,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->xmac_stats_sys_data);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * vxge_hal_mrpcim_xmac_aggr_stats_get - Get the Statistics on aggregate port
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:vxge_hal_mrpcim_xmac_aggr_stats_get(vxge_hal_device_h devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:    vxge_hal_xmac_aggr_stats_t *aggr_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * vxge_hal_mrpcim_xmac_port_stats_get - Get the Statistics on a port
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:vxge_hal_mrpcim_xmac_port_stats_get(vxge_hal_device_h devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:    vxge_hal_xmac_port_stats_t *port_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * vxge_hal_mrpcim_xmac_stats_get - Get the XMAC Statistics
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * @xmac_stats: Buffer to return XMAC Statistics.
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:vxge_hal_mrpcim_xmac_stats_get(vxge_hal_device_h devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:    vxge_hal_mrpcim_xmac_stats_t *xmac_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	vxge_assert((devh != NULL) && (xmac_stats != NULL));
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    (ptr_t) devh, (ptr_t) xmac_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = vxge_hal_mrpcim_xmac_aggr_stats_get(devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &xmac_stats->aggr_stats[0]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = vxge_hal_mrpcim_xmac_aggr_stats_get(devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &xmac_stats->aggr_stats[1]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		status = vxge_hal_mrpcim_xmac_port_stats_get(devh,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &xmac_stats->port_stats[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = vxge_hal_mrpcim_xmac_aggr_stats_get(hldev,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_stats->xgmac_aggr[0]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = vxge_hal_mrpcim_xmac_aggr_stats_get(hldev,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &mrpcim_stats->xgmac_aggr[1]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		status = vxge_hal_mrpcim_xmac_port_stats_get(hldev,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &mrpcim_stats->xgmac_port[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_global_prog_event_gnum0 =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_global_prog_event_gnum1 =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_orp_lro_events =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_orp_bs_events =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_orp_iwarp_events =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_tx_permitted_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port0_tx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port1_tx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port2_tx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port0_rx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port1_rx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mrpcim_stats->xgmac_port2_rx_any_frms =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * __hal_mrpcim_mac_configure - Initialize mac
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:__hal_mrpcim_mac_configure(__hal_device_t *hldev)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	vxge_hal_mac_config_t *mac_config =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	&hldev->header.config.mrpcim_config.mac_config;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		port_id = mac_config->wire_port_config[i].port_id;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].tmac_en ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    &hldev->mrpcim_reg->txmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:				mac_config->wire_port_config[i].tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:				mac_config->wire_port_config[i].tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_en ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    &hldev->mrpcim_reg->rxmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:				mac_config->wire_port_config[i].rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:				mac_config->wire_port_config[i].rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if ((!(mac_config->wire_port_config[i].rmac_en)) &&
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    (!(mac_config->wire_port_config[i].tmac_en)))
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->xgmac_main_cfg_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].rmac_strip_fcs)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].rmac_discard_pfrm)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].mtu !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].mtu);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg2_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].rmac_prom_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg2_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_pause_cfg_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].rmac_pause_gen_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].rmac_pause_rcv_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].rmac_pause_time);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].limiter_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].max_limit !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].max_limit);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_pause_cfg_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_link_util_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].rmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].rmac_util_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_link_util_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->xgmac_debounce_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].link_stability_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].link_stability_period) |
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].link_stability_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].port_stability_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].port_stability_period) |
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].port_stability_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->xgmac_debounce_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].tmac_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].tmac_pad !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].tmac_pad)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].tmac_pad_byte !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].tmac_pad_byte);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_cfg0_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_link_util_port);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].tmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].tmac_util_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_link_util_port[port_id]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].autoneg_mode !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->wire_port_config[i].autoneg_mode);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].autoneg_rate !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].autoneg_rate)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].fixed_use_fsm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].fixed_use_fsm)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].antp_use_fsm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].antp_use_fsm)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->wire_port_config[i].anbe_use_fsm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->wire_port_config[i].anbe_use_fsm)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->switch_port_config.tmac_en ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_config->switch_port_config.tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_config->switch_port_config.tmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->switch_port_config.rmac_en ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_config->switch_port_config.rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_config->switch_port_config.rmac_en =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->switch_port_config.rmac_en ||
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    mac_config->switch_port_config.tmac_en) {
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_strip_fcs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.rmac_strip_fcs)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_discard_pfrm !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.rmac_discard_pfrm)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.mtu !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.mtu);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg2_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_prom_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.rmac_prom_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_cfg2_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_pause_cfg_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_pause_gen_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.rmac_pause_gen_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_pause_rcv_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.rmac_pause_rcv_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.rmac_pause_time);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_pause_time !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.limiter_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.max_limit !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.max_limit);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_pause_cfg_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_link_util_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.rmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.rmac_util_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->rxmac_link_util_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.tmac_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.tmac_pad !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (mac_config->switch_port_config.tmac_pad)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.tmac_pad_byte !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.tmac_pad_byte);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_cfg0_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_link_util_port);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->switch_port_config.tmac_util_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_config->switch_port_config.tmac_util_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    &hldev->mrpcim_reg->txmac_link_util_port[
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->txmac_gen_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_perma_stop_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_perma_stop_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_tx_switch_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_tx_switch_dis)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_lossy_switch_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_lossy_switch_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_lossy_switch_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_lossy_wire_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_bcast_to_wire_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_bcast_to_wire_dis)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_bcast_to_wire_dis !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_bcast_to_switch_dis)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tmac_host_append_fcs_en !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tmac_host_append_fcs_en)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->txmac_gen_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_ignore_frame_err !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_ignore_frame_err)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_support_snap_ab_n)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_search_for_hao !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_search_for_hao)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_support_ipv6_mobile_hdrs !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_support_ipv6_mobile_hdrs)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_ipv6_stop_searching !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_ipv6_stop_searching)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_no_ps_if_unknown !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_no_ps_if_unknown)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_search_for_etype !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_search_for_etype)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_l4_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_l4_comp_csum)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_l3_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_l3_incl_cf)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_l3_comp_csum !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_l3_comp_csum)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_ipv4_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_ipv4_tcp_incl_ph)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_ipv6_tcp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_ipv6_tcp_incl_ph)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_ipv4_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_ipv4_udp_incl_ph)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_ipv6_udp_incl_ph !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_ipv6_udp_incl_ph)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_l4_incl_cf !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_l4_incl_cf)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->rpa_repl_strip_vlan_tag !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->rpa_repl_strip_vlan_tag)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->xmac_gen_cfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->network_stability_period !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    mac_config->network_stability_period) |
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		    mac_config->network_stability_period);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->xmac_gen_cfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tpa_support_snap_ab_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tpa_support_snap_ab_n)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_config->tpa_ecc_enable_n !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_config->tpa_ecc_enable_n)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	u64 mac_addr;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		mac_addr = 0;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_addr <<= 8;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_addr |=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    (u8) lag_config->port_config[i].partner_mac_addr[j];
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_addr != 0xffffffffffffULL) {
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			    mac_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		mac_addr = 0;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_addr <<= 8;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			mac_addr |= (u8) lag_config->aggr_config[i].mac_addr[j];
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (mac_addr != 0xffffffffffffULL) {
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			val64 |= VXGE_HAL_LAG_AGGR_ADDR_CFG_ADDR(mac_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (lag_config->aggr_config[i].use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (lag_config->aggr_config[i].use_port_mac_addr ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (lag_config->aggr_config[i].mac_addr_sel !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:			if (lag_config->aggr_config[i].mac_addr_sel ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	mac_addr = 0;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		mac_addr <<= 8;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		mac_addr |= (u8) lag_config->mac_addr[j];
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (mac_addr != 0xffffffffffffULL) {
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		val64 |= VXGE_HAL_LAG_SYS_ID_ADDR(mac_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (lag_config->use_port_mac_addr !=
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (lag_config->use_port_mac_addr ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (lag_config->mac_addr_sel != VXGE_HAL_LAG_MAC_ADDR_SEL_DEFAULT) {
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:		if (lag_config->mac_addr_sel ==
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * vxge_hal_mrpcim_mac_addr_add - Add the mac address entry
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: *		vxge_hal_vpath_mac_addr_add_mode_e {}
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * see also: vxge_hal_mrpcim_mac_addr_get
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:vxge_hal_mrpcim_mac_addr_add(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * vxge_hal_mrpcim_mac_addr_get - Read the mac address entry into
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c: * see also: vxge_hal_mrpcim_mac_addr_add
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:vxge_hal_mrpcim_mac_addr_get(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (hldev->header.config.mrpcim_config.mac_config.
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	hldev->header.config.mrpcim_config.mac_config.rpa_repl_strip_vlan_tag =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	if (hldev->header.config.mrpcim_config.mac_config.
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_rx_pa_cfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	hldev->header.config.mrpcim_config.mac_config.rpa_repl_strip_vlan_tag =
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_pause_cfg_port[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_pause_cfg_port[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    val64, &hldev->mrpcim_reg->rxmac_pause_cfg_port[port]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	status = __hal_mrpcim_mac_configure(hldev);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_authorize_all_addr);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-mrpcim.c:	    &hldev->mrpcim_reg->rxmac_authorize_all_vid);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-ring.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-ring.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:	u64 xgmac_status;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:		xgmac_status = vxge_os_pio_mem_read64(hldev->header.pdev,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:		    &srpcim_reg->xgmac_sr_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:		vxge_hal_info_log_srpcim_irq("xgmac_status = 0x"VXGE_OS_STXFMT,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:		    (ptr_t) xgmac_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:		if (xgmac_status &
/usr/src/sys/dev/vxge/vxgehal/vxgehal-srpcim.c:	    &srpcim_reg->xgmac_sr_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_add - Add the mac address entry for this vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: *		vxge_hal_vpath_mac_addr_add_mode_e {}
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * see also: vxge_hal_vpath_mac_addr_delete, vxge_hal_vpath_mac_addr_get and
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_get_next
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_mac_addr_add(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_vpath_mac_addr_add_mode_e duplicate_mode)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * see also: vxge_hal_vpath_mac_addr_get_next
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_get - Get the first mac address entry for this vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * see also: vxge_hal_vpath_mac_addr_get_next
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_mac_addr_get(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_get_next - Get the next mac address entry for vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * see also: vxge_hal_vpath_mac_addr_get
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_mac_addr_get_next(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_delete - Delete the mac address entry for this vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * see also: vxge_hal_vpath_mac_addr_add, vxge_hal_vpath_mac_addr_get and
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_mac_addr_get_next
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_mac_addr_delete(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xgmac_vp_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xgmac_vp_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xgmac_vp_int_mask);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vpmgmt_reg->xgmac_gen_status_vpmgmt_clone);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vpmgmt_reg->xgmac_gen_status_vpmgmt_clone);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	u64 xgmac_status;
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		xgmac_status = vxge_os_pio_mem_read64(hldev->header.pdev,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->xgmac_vp_int_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		vxge_hal_info_log_vpath_irq("xgmac_status = 0x"VXGE_OS_STXFMT,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    (ptr_t) xgmac_status);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		if (xgmac_status &
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vpmgmt_reg->rxmac_cfg0_port_vpmgmt_clone[i]);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vpmgmt_reg->xmac_vsport_choices_vp);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vpmgmt_reg->xgmac_gen_status_vpmgmt_clone);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * __hal_vpath_mac_configure
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:__hal_vpath_mac_configure(
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_vsport_choice);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->xmac_rpa_vcfg);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->rxmac_vcfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->rxmac_vcfg1);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vp->vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vp->vpath->vp_reg->rxmac_vcfg0);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	status = __hal_vpath_mac_configure(hldev, vp_id);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_stats_access_cmd);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_stats_access_cmd);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	    &vpath->vp_reg->xmac_stats_access_cmd,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:		    &vpath->vp_reg->xmac_stats_access_data);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * __hal_vpath_xmac_tx_stats_get - Get the TX Statistics of a vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:__hal_vpath_xmac_tx_stats_get(__hal_virtualpath_t *vpath,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_vpath_tx_stats_t *vpath_tx_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * __hal_vpath_xmac_rx_stats_get - Get the RX Statistics of a vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:__hal_vpath_xmac_rx_stats_get(__hal_virtualpath_t *vpath,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_vpath_rx_stats_t *vpath_rx_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_xmac_tx_stats_get - Get the TX Statistics of a vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_xmac_tx_stats_get(vxge_hal_vpath_h vpath_handle,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_vpath_tx_stats_t *vpath_tx_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	status = __hal_vpath_xmac_tx_stats_get(vp->vpath, vpath_tx_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c: * vxge_hal_vpath_xmac_rx_stats_get - Get the RX Statistics of a vpath
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:vxge_hal_vpath_xmac_rx_stats_get(vxge_hal_vpath_h vpath_handle,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_vpath_rx_stats_t *vpath_rx_stats)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	status = __hal_vpath_xmac_rx_stats_get(vp->vpath, vpath_rx_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	status = __hal_vpath_xmac_tx_stats_get(vpath, &hw_stats->tx_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:	status = __hal_vpath_xmac_rx_stats_get(vpath, &hw_stats->rx_stats);
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_nwif_actconfig req_config,
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_nwif_dp_mode port_mode)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    vxge_hal_xmac_nwif_behavior_on_failure behave_on_failure)
/usr/src/sys/dev/vxge/vxgehal/vxgehal-virtualpath.c:    enum vxge_hal_xmac_nwif_l2_switch_status l2_switch)
/usr/src/sys/fs/devfs/devfs_devs.c:#include <security/mac/mac_framework.h>
/usr/src/sys/fs/devfs/devfs_devs.c:	mac_devfs_init(de);
/usr/src/sys/fs/devfs/devfs_devs.c:	mac_devfs_create_directory(dmp->dm_mount, name, namelen, dd);
/usr/src/sys/fs/devfs/devfs_devs.c:	mac_devfs_destroy(de);
/usr/src/sys/fs/devfs/devfs_devs.c:		mac_devfs_create_device(cdp->cdp_c.si_cred, dm->dm_mount,
/usr/src/sys/fs/devfs/devfs_vnops.c:#include <security/mac/mac_framework.h>
/usr/src/sys/fs/devfs/devfs_vnops.c:	mac_devfs_vnode_associate(mp, de, vp);
/usr/src/sys/fs/devfs/devfs_vnops.c:	mac_vnode_relabel(ap->a_cred, vp, ap->a_label);
/usr/src/sys/fs/devfs/devfs_vnops.c:	mac_devfs_update(vp->v_mount, de, vp);
/usr/src/sys/fs/devfs/devfs_vnops.c:	mac_devfs_create_symlink(ap->a_cnp->cn_cred, dmp->dm_mount, dd, de);
/usr/src/sys/fs/nfsclient/nfs_clkrpc.c:		mac_cred_associate_nfsd(nd.nd_cred);
/usr/src/sys/fs/nfsserver/nfs_nfsdkrpc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/fs/nfsserver/nfs_nfsdkrpc.c:		mac_cred_associate_nfsd(nd.nd_cred);
/usr/src/sys/fs/unionfs/union_subr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/fs/unionfs/union_subr.c:	if ((error = mac_vnode_check_open(cred, vp, VEXEC|VREAD)) != 0)
/usr/src/sys/fs/unionfs/union_subr.c:	error = mac_vnode_check_readdir(td->td_ucred, lvp);
/usr/src/sys/geom/eli/g_eli.c:g_eli_keyfiles_load(struct hmac_ctx *ctx, const char *provider)
/usr/src/sys/geom/eli/g_eli.c:		g_eli_crypto_hmac_update(ctx, data, size);
/usr/src/sys/geom/eli/g_eli.c:	struct hmac_ctx ctx;
/usr/src/sys/geom/eli/g_eli.c:		g_eli_crypto_hmac_init(&ctx, NULL, 0);
/usr/src/sys/geom/eli/g_eli.c:			g_eli_crypto_hmac_update(&ctx, md.md_salt,
/usr/src/sys/geom/eli/g_eli.c:			g_eli_crypto_hmac_update(&ctx, passphrase,
/usr/src/sys/geom/eli/g_eli.c:			g_eli_crypto_hmac_update(&ctx, dkey, sizeof(dkey));
/usr/src/sys/geom/eli/g_eli.c:		g_eli_crypto_hmac_final(&ctx, key, 0);
/usr/src/sys/geom/eli/g_eli_crypto.c:g_eli_crypto_hmac_init(struct hmac_ctx *ctx, const uint8_t *hkey,
/usr/src/sys/geom/eli/g_eli_crypto.c:g_eli_crypto_hmac_update(struct hmac_ctx *ctx, const uint8_t *data,
/usr/src/sys/geom/eli/g_eli_crypto.c:g_eli_crypto_hmac_final(struct hmac_ctx *ctx, uint8_t *md, size_t mdsize)
/usr/src/sys/geom/eli/g_eli_crypto.c:	struct hmac_ctx ctx;
/usr/src/sys/geom/eli/g_eli_crypto.c:	g_eli_crypto_hmac_init(&ctx, hkey, hkeysize);
/usr/src/sys/geom/eli/g_eli_crypto.c:	g_eli_crypto_hmac_update(&ctx, data, datasize);
/usr/src/sys/geom/eli/g_eli_crypto.c:	g_eli_crypto_hmac_final(&ctx, md, mdsize);
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:static xfs_mac_label_t *mac_low_high_lp;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:static xfs_mac_label_t *mac_high_low_lp;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:static xfs_mac_label_t *mac_admin_high_lp;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:static xfs_mac_label_t *mac_equal_equal_lp;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:xfs_mac_vhaslabel(
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:	int		len = sizeof(xfs_mac_label_t);
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:xfs_mac_iaccess(xfs_inode_t *ip, mode_t mode, struct cred *cr)
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:	xfs_mac_label_t mac;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:	xfs_mac_label_t *mp = mac_high_low_lp;
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:		if ((mp = mac_add_label(&mac)) == NULL) {
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:			return mac_access(mac_high_low_lp, cr, mode);
/usr/src/sys/gnu/fs/xfs/xfs_mac.c:	return mac_access(mp, cr, mode);
/usr/src/sys/i386/ibcs2/ibcs2_misc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/i386/ibcs2/ibcs2_misc.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/i386/ibcs2/ibcs2_misc.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/kern/init_main.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/init_main.c:	mac_cred_create_swapper(p->p_ucred);
/usr/src/sys/kern/init_main.c:	mac_cred_create_init(newcred);
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_get_proc_args), (sy_call_t *)sys___mac_get_proc, AUE_NULL, NULL, 0, 0, SYF_CAPENABLED, SY_THR_STATIC },	/* 384 = __mac_get_proc */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_set_proc_args), (sy_call_t *)sys___mac_set_proc, AUE_NULL, NULL, 0, 0, SYF_CAPENABLED, SY_THR_STATIC },	/* 385 = __mac_set_proc */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_get_fd_args), (sy_call_t *)sys___mac_get_fd, AUE_NULL, NULL, 0, 0, SYF_CAPENABLED, SY_THR_STATIC },	/* 386 = __mac_get_fd */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_get_file_args), (sy_call_t *)sys___mac_get_file, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 387 = __mac_get_file */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_set_fd_args), (sy_call_t *)sys___mac_set_fd, AUE_NULL, NULL, 0, 0, SYF_CAPENABLED, SY_THR_STATIC },	/* 388 = __mac_set_fd */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_set_file_args), (sy_call_t *)sys___mac_set_file, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 389 = __mac_set_file */
/usr/src/sys/kern/init_sysent.c:	{ AS(mac_syscall_args), (sy_call_t *)sys_mac_syscall, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 394 = mac_syscall */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_get_pid_args), (sy_call_t *)sys___mac_get_pid, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 409 = __mac_get_pid */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_get_link_args), (sy_call_t *)sys___mac_get_link, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 410 = __mac_get_link */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_set_link_args), (sy_call_t *)sys___mac_set_link, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 411 = __mac_set_link */
/usr/src/sys/kern/init_sysent.c:	{ AS(__mac_execve_args), (sy_call_t *)sys___mac_execve, AUE_NULL, NULL, 0, 0, 0, SY_THR_STATIC },	/* 415 = __mac_execve */
/usr/src/sys/kern/kern_acct.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_acct.c:		error = mac_system_check_acct(td->td_ucred, nd.ni_vp);
/usr/src/sys/kern/kern_acct.c:		error = mac_system_check_acct(td->td_ucred, NULL);
/usr/src/sys/kern/kern_alq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_alq.c:	if (mac_vnode_check_write(alq->aq_cred, NOCRED, vp) == 0)
/usr/src/sys/kern/kern_environment.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_environment.c:		error = mac_kenv_check_dump(td->td_ucred);
/usr/src/sys/kern/kern_environment.c:		error = mac_kenv_check_get(td->td_ucred, name);
/usr/src/sys/kern/kern_environment.c:		error = mac_kenv_check_set(td->td_ucred, name, value);
/usr/src/sys/kern/kern_environment.c:		error = mac_kenv_check_unset(td->td_ucred, name);
/usr/src/sys/kern/kern_exec.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_exec.c:    struct mac *mac_p);
/usr/src/sys/kern/kern_exec.c:struct __mac_execve_args {
/usr/src/sys/kern/kern_exec.c:	struct mac	*mac_p;
/usr/src/sys/kern/kern_exec.c:sys___mac_execve(td, uap)
/usr/src/sys/kern/kern_exec.c:	struct __mac_execve_args /* {
/usr/src/sys/kern/kern_exec.c:		struct mac *mac_p;
/usr/src/sys/kern/kern_exec.c:		error = kern_execve(td, &args, uap->mac_p);
/usr/src/sys/kern/kern_exec.c:kern_execve(td, args, mac_p)
/usr/src/sys/kern/kern_exec.c:	struct mac *mac_p;
/usr/src/sys/kern/kern_exec.c:	error = do_execve(td, args, mac_p);
/usr/src/sys/kern/kern_exec.c:do_execve(td, args, mac_p)
/usr/src/sys/kern/kern_exec.c:	struct mac *mac_p;
/usr/src/sys/kern/kern_exec.c:	error = mac_execve_enter(imgp, mac_p);
/usr/src/sys/kern/kern_exec.c:		mac_execve_interpreter_enter(binvp, &interpvplabel);
/usr/src/sys/kern/kern_exec.c:	will_transition = mac_vnode_execve_will_transition(oldcred, imgp->vp,
/usr/src/sys/kern/kern_exec.c:			mac_vnode_execve_transition(oldcred, newcred, imgp->vp,
/usr/src/sys/kern/kern_exec.c:	mac_execve_exit(imgp);
/usr/src/sys/kern/kern_exec.c:	mac_execve_interpreter_exit(interpvplabel);
/usr/src/sys/kern/kern_exec.c:	error = mac_vnode_check_exec(td->td_ucred, imgp->vp, imgp);
/usr/src/sys/kern/kern_exit.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_exit.c:	mac_proc_destroy(p);
/usr/src/sys/kern/kern_fork.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_fork.c:	mac_proc_init(newproc);
/usr/src/sys/kern/kern_fork.c:	mac_proc_destroy(newproc);
/usr/src/sys/kern/kern_jail.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_jail.c:	if ((error = mac_vnode_check_chroot(td->td_ucred, pr->pr_root)))
/usr/src/sys/kern/kern_ktrace.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_ktrace.c:	error = mac_vnode_check_write(cred, NOCRED, vp);
/usr/src/sys/kern/kern_linker.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(td->td_ucred);
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(td->td_ucred);
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(td->td_ucred);
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(td->td_ucred);
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(td->td_ucred);
/usr/src/sys/kern/kern_linker.c:	error = mac_kld_check_stat(req->td->td_ucred);
/usr/src/sys/kern/kern_mbuf.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_mbuf.c:		error = mac_mbuf_init(m, how);
/usr/src/sys/kern/kern_mbuf.c:		error = mac_mbuf_init(m, how);
/usr/src/sys/kern/kern_mbuf.c:	error = mac_mbuf_init(m, how);
/usr/src/sys/kern/kern_priv.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_priv.c:	error = mac_priv_check(cred, priv);
/usr/src/sys/kern/kern_priv.c:	if (mac_priv_grant(cred, priv) == 0) {
/usr/src/sys/kern/kern_prot.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setuid(oldcred, uid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_seteuid(oldcred, euid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setgid(oldcred, gid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setegid(oldcred, egid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setgroups(oldcred, ngrp, groups);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setreuid(oldcred, ruid, euid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setregid(oldcred, rgid, egid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setresuid(oldcred, ruid, euid, suid);
/usr/src/sys/kern/kern_prot.c:	error = mac_cred_check_setresgid(oldcred, rgid, egid, sgid);
/usr/src/sys/kern/kern_prot.c:	if ((error = mac_cred_check_visible(u1, u2)))
/usr/src/sys/kern/kern_prot.c:	if ((error = mac_proc_check_signal(cred, proc, signum)))
/usr/src/sys/kern/kern_prot.c:	if ((error = mac_proc_check_sched(td->td_ucred, p)))
/usr/src/sys/kern/kern_prot.c:	if ((error = mac_proc_check_debug(td->td_ucred, p)))
/usr/src/sys/kern/kern_prot.c:	error = mac_socket_check_visible(cred, so);
/usr/src/sys/kern/kern_prot.c:	error = mac_inpcb_check_visible(cred, inp);
/usr/src/sys/kern/kern_prot.c:	if ((error = mac_proc_check_wait(td->td_ucred, p)))
/usr/src/sys/kern/kern_prot.c:	mac_cred_init(cr);
/usr/src/sys/kern/kern_prot.c:		mac_cred_destroy(cr);
/usr/src/sys/kern/kern_prot.c:	mac_cred_copy(src, dest);
/usr/src/sys/kern/kern_shutdown.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_shutdown.c:	error = mac_system_check_reboot(td->td_ucred, uap->opt);
/usr/src/sys/kern/kern_sysctl.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/kern_sysctl.c:	error = mac_system_check_sysctl(req->td->td_ucred, oid, arg1, arg2,
/usr/src/sys/kern/link_elf.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/link_elf.c:	error = mac_kld_check_load(curthread->td_ucred, nd.ni_vp);
/usr/src/sys/kern/link_elf_obj.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/link_elf_obj.c:	error = mac_kld_check_load(td->td_ucred, nd.ni_vp);
/usr/src/sys/kern/subr_trap.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/subr_trap.c:		mac_thread_userret(td);
/usr/src/sys/kern/sys_pipe.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/sys_pipe.c:	 * result mac_pipe_init() and mac_pipe_create() are called once
/usr/src/sys/kern/sys_pipe.c:	mac_pipe_init(pp);
/usr/src/sys/kern/sys_pipe.c:	mac_pipe_create(td->td_ucred, pp);
/usr/src/sys/kern/sys_pipe.c:	error = mac_pipe_check_read(active_cred, rpipe->pipe_pair);
/usr/src/sys/kern/sys_pipe.c:	error = mac_pipe_check_write(active_cred, wpipe->pipe_pair);
/usr/src/sys/kern/sys_pipe.c:	error = mac_pipe_check_ioctl(active_cred, mpipe->pipe_pair, cmd, data);
/usr/src/sys/kern/sys_pipe.c:	error = mac_pipe_check_poll(active_cred, rpipe->pipe_pair);
/usr/src/sys/kern/sys_pipe.c:	error = mac_pipe_check_stat(active_cred, pipe->pipe_pair);
/usr/src/sys/kern/sys_pipe.c:		mac_pipe_destroy(pp);
/usr/src/sys/kern/sys_socket.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/sys_socket.c:	error = mac_socket_check_receive(active_cred, so);
/usr/src/sys/kern/sys_socket.c:	error = mac_socket_check_send(active_cred, so);
/usr/src/sys/kern/sys_socket.c:	error = mac_socket_check_poll(active_cred, so);
/usr/src/sys/kern/sys_socket.c:	error = mac_socket_check_stat(active_cred, so);
/usr/src/sys/kern/syscalls.c:	"__mac_get_proc",			/* 384 = __mac_get_proc */
/usr/src/sys/kern/syscalls.c:	"__mac_set_proc",			/* 385 = __mac_set_proc */
/usr/src/sys/kern/syscalls.c:	"__mac_get_fd",			/* 386 = __mac_get_fd */
/usr/src/sys/kern/syscalls.c:	"__mac_get_file",			/* 387 = __mac_get_file */
/usr/src/sys/kern/syscalls.c:	"__mac_set_fd",			/* 388 = __mac_set_fd */
/usr/src/sys/kern/syscalls.c:	"__mac_set_file",			/* 389 = __mac_set_file */
/usr/src/sys/kern/syscalls.c:	"mac_syscall",			/* 394 = mac_syscall */
/usr/src/sys/kern/syscalls.c:	"__mac_get_pid",			/* 409 = __mac_get_pid */
/usr/src/sys/kern/syscalls.c:	"__mac_get_link",			/* 410 = __mac_get_link */
/usr/src/sys/kern/syscalls.c:	"__mac_set_link",			/* 411 = __mac_set_link */
/usr/src/sys/kern/syscalls.c:	"__mac_execve",			/* 415 = __mac_execve */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_proc */
/usr/src/sys/kern/systrace_args.c:		struct __mac_get_proc_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[0] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_proc */
/usr/src/sys/kern/systrace_args.c:		struct __mac_set_proc_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[0] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_fd */
/usr/src/sys/kern/systrace_args.c:		struct __mac_get_fd_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_file */
/usr/src/sys/kern/systrace_args.c:		struct __mac_get_file_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_fd */
/usr/src/sys/kern/systrace_args.c:		struct __mac_set_fd_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_file */
/usr/src/sys/kern/systrace_args.c:		struct __mac_set_file_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* mac_syscall */
/usr/src/sys/kern/systrace_args.c:		struct mac_syscall_args *p = params;
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_pid */
/usr/src/sys/kern/systrace_args.c:		struct __mac_get_pid_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_link */
/usr/src/sys/kern/systrace_args.c:		struct __mac_get_link_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_link */
/usr/src/sys/kern/systrace_args.c:		struct __mac_set_link_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[1] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_execve */
/usr/src/sys/kern/systrace_args.c:		struct __mac_execve_args *p = params;
/usr/src/sys/kern/systrace_args.c:		uarg[3] = (intptr_t) p->mac_p; /* struct mac * */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_proc */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_proc */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_fd */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_file */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_fd */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_file */
/usr/src/sys/kern/systrace_args.c:	/* mac_syscall */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_pid */
/usr/src/sys/kern/systrace_args.c:	/* __mac_get_link */
/usr/src/sys/kern/systrace_args.c:	/* __mac_set_link */
/usr/src/sys/kern/systrace_args.c:	/* __mac_execve */
/usr/src/sys/kern/sysv_msg.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsg_init(&msghdrs[i]);
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsq_init(&msqids[i]);
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsg_destroy(&msghdrs[i]);
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsq_destroy(&msqids[msqid]);
/usr/src/sys/kern/sysv_msg.c:	mac_sysvmsg_cleanup(msghdr);
/usr/src/sys/kern/sysv_msg.c:	error = mac_sysvmsq_check_msqctl(td->td_ucred, msqkptr, cmd);
/usr/src/sys/kern/sysv_msg.c:			error = mac_sysvmsq_check_msgrmid(td->td_ucred, msghdr);
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsq_cleanup(msqkptr);
/usr/src/sys/kern/sysv_msg.c:			error = mac_sysvmsq_check_msqget(cred, msqkptr);
/usr/src/sys/kern/sysv_msg.c:		mac_sysvmsq_create(cred, msqkptr);
/usr/src/sys/kern/sysv_msg.c:	error = mac_sysvmsq_check_msqsnd(td->td_ucred, msqkptr);
/usr/src/sys/kern/sysv_msg.c:	 * XXXMAC: Should the mac_sysvmsq_check_msgmsq check follow here
/usr/src/sys/kern/sysv_msg.c:	mac_sysvmsg_create(td->td_ucred, msqkptr, msghdr);
/usr/src/sys/kern/sysv_msg.c:	 * permissions to the msgq.  The mac_sysvmsq_check_msqsnd check would
/usr/src/sys/kern/sysv_msg.c:	error = mac_sysvmsq_check_msgmsq(td->td_ucred, msghdr, msqkptr);
/usr/src/sys/kern/sysv_msg.c:	error = mac_sysvmsq_check_msqrcv(td->td_ucred, msqkptr);
/usr/src/sys/kern/sysv_msg.c:				error = mac_sysvmsq_check_msgrcv(td->td_ucred,
/usr/src/sys/kern/sysv_msg.c:					error = mac_sysvmsq_check_msgrcv(
/usr/src/sys/kern/sysv_sem.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/sysv_sem.c:		mac_sysvsem_init(&sema[i]);
/usr/src/sys/kern/sysv_sem.c:		mac_sysvsem_destroy(&sema[i]);
/usr/src/sys/kern/sysv_sem.c:		error = mac_sysvsem_check_semctl(cred, semakptr, cmd);
/usr/src/sys/kern/sysv_sem.c:	error = mac_sysvsem_check_semctl(cred, semakptr, cmd);
/usr/src/sys/kern/sysv_sem.c:		mac_sysvsem_cleanup(semakptr);
/usr/src/sys/kern/sysv_sem.c:			error = mac_sysvsem_check_semget(cred, &sema[semid]);
/usr/src/sys/kern/sysv_sem.c:		mac_sysvsem_create(cred, &sema[semid]);
/usr/src/sys/kern/sysv_sem.c:	error = mac_sysvsem_check_semop(td->td_ucred, semakptr, j);
/usr/src/sys/kern/sysv_shm.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/sysv_shm.c:	mac_sysvshm_cleanup(shmseg);
/usr/src/sys/kern/sysv_shm.c:	error = mac_sysvshm_check_shmdt(td->td_ucred, shmsegptr);
/usr/src/sys/kern/sysv_shm.c:	error = mac_sysvshm_check_shmat(td->td_ucred, shmseg, shmflg);
/usr/src/sys/kern/sysv_shm.c:	error = mac_sysvshm_check_shmctl(td->td_ucred, shmseg, cmd);
/usr/src/sys/kern/sysv_shm.c:	error = mac_sysvshm_check_shmget(td->td_ucred, shmseg, uap->shmflg);
/usr/src/sys/kern/sysv_shm.c:	mac_sysvshm_create(cred, shmseg);
/usr/src/sys/kern/sysv_shm.c:		mac_sysvshm_init(&shmsegs[i]);
/usr/src/sys/kern/sysv_shm.c:		mac_sysvshm_init(&shmsegs[i]);
/usr/src/sys/kern/sysv_shm.c:		mac_sysvshm_destroy(&shmsegs[i]);
/usr/src/sys/kern/sysv_shm.c:		error = mac_sysvshm_check_shmctl(td->td_ucred, shmseg, uap->cmd);
/usr/src/sys/kern/uipc_mbuf2.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_mbuf2.c:		mac_mbuf_tag_destroy(t);
/usr/src/sys/kern/uipc_mbuf2.c:		if (mac_mbuf_tag_init(p, how) != 0) {
/usr/src/sys/kern/uipc_mbuf2.c:		mac_mbuf_tag_copy(t, p);
/usr/src/sys/kern/uipc_sem.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_stat(active_cred, fp->f_cred, ks);
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_setmode(active_cred, ks, mode);
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_setowner(active_cred, ks, uid, gid);
/usr/src/sys/kern/uipc_sem.c:	mac_posixsem_init(ks);
/usr/src/sys/kern/uipc_sem.c:	mac_posixsem_create(ucred, ks);
/usr/src/sys/kern/uipc_sem.c:		mac_posixsem_destroy(ks);
/usr/src/sys/kern/uipc_sem.c:			error = mac_posixsem_check_unlink(ucred, map->km_ksem);
/usr/src/sys/kern/uipc_sem.c:				error = mac_posixsem_check_open(td->td_ucred,
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_post(td->td_ucred, fp->f_cred, ks);
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_wait(td->td_ucred, fp->f_cred, ks);
/usr/src/sys/kern/uipc_sem.c:	error = mac_posixsem_check_getvalue(td->td_ucred, fp->f_cred, ks);
/usr/src/sys/kern/uipc_shm.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_shm.c:	error = mac_posixshm_check_truncate(active_cred, fp->f_cred, shmfd);
/usr/src/sys/kern/uipc_shm.c:	error = mac_posixshm_check_stat(active_cred, fp->f_cred, shmfd);
/usr/src/sys/kern/uipc_shm.c:	mac_posixshm_init(shmfd);
/usr/src/sys/kern/uipc_shm.c:	mac_posixshm_create(ucred, shmfd);
/usr/src/sys/kern/uipc_shm.c:		mac_posixshm_destroy(shmfd);
/usr/src/sys/kern/uipc_shm.c:			error = mac_posixshm_check_unlink(ucred, map->sm_shmfd);
/usr/src/sys/kern/uipc_shm.c:				error = mac_posixshm_check_create(td->td_ucred,
/usr/src/sys/kern/uipc_shm.c:				error = mac_posixshm_check_open(td->td_ucred,
/usr/src/sys/kern/uipc_shm.c:				error = mac_posixshm_check_truncate(
/usr/src/sys/kern/uipc_shm.c:	error = mac_posixshm_check_setmode(active_cred, shmfd, mode);
/usr/src/sys/kern/uipc_shm.c:	error = mac_posixshm_check_setowner(active_cred, shmfd, uid, gid);
/usr/src/sys/kern/uipc_socket.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_socket.c:	if (mac_socket_init(so, M_NOWAIT) != 0) {
/usr/src/sys/kern/uipc_socket.c:	mac_socket_destroy(so);
/usr/src/sys/kern/uipc_socket.c:	mac_socket_create(cred, so);
/usr/src/sys/kern/uipc_socket.c:	mac_socket_newconn(head, so);
/usr/src/sys/kern/uipc_socket.c:			error = mac_setsockopt_label(sopt->sopt_td->td_ucred,
/usr/src/sys/kern/uipc_socket.c:			error = mac_getsockopt_label(sopt->sopt_td->td_ucred,
/usr/src/sys/kern/uipc_socket.c:			error = mac_getsockopt_peerlabel(
/usr/src/sys/kern/uipc_syscalls.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_create(td->td_ucred, uap->domain, type,
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_bind(td->td_ucred, so, sa);
/usr/src/sys/kern/uipc_syscalls.c:		error = mac_socket_check_listen(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_accept(td->td_ucred, head);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_connect(td->td_ucred, so, sa);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_create(td->td_ucred, domain, type,
/usr/src/sys/kern/uipc_syscalls.c:		error = mac_socket_check_connect(td->td_ucred, so,
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_send(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_receive(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_send(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_send(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_send(td->td_ucred, so);
/usr/src/sys/kern/uipc_syscalls.c:	error = mac_socket_check_receive(td->td_ucred, so);
/usr/src/sys/kern/uipc_usrreq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/uipc_usrreq.c:	error = mac_vnode_check_create(td->td_ucred, nd.ni_dvp, &nd.ni_cnd,
/usr/src/sys/kern/uipc_usrreq.c:	mac_vnode_post_create(td->td_ucred, nd.ni_dvp, nd.ni_vp, &nd.ni_cnd, &vattr);
/usr/src/sys/kern/uipc_usrreq.c:	error = mac_vnode_check_open(td->td_ucred, vp, VWRITE | VREAD);
/usr/src/sys/kern/uipc_usrreq.c:		mac_socketpeer_set_from_socket(so, so3);
/usr/src/sys/kern/uipc_usrreq.c:		mac_socketpeer_set_from_socket(so3, so);
/usr/src/sys/kern/vfs_acl.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_acl.c:	error = mac_vnode_check_setacl(td->td_ucred, vp, type, inkernelacl);
/usr/src/sys/kern/vfs_acl.c:	error = mac_vnode_check_getacl(td->td_ucred, vp, type);
/usr/src/sys/kern/vfs_acl.c:	error = mac_vnode_check_deleteacl(td->td_ucred, vp, type);
/usr/src/sys/kern/vfs_default.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_default.c:		error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/kern/vfs_extattr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_extattr.c:	error = mac_vnode_check_setextattr(td->td_ucred, vp, attrnamespace,
/usr/src/sys/kern/vfs_extattr.c:	error = mac_vnode_check_getextattr(td->td_ucred, vp, attrnamespace,
/usr/src/sys/kern/vfs_extattr.c:	error = mac_vnode_check_deleteextattr(td->td_ucred, vp, attrnamespace,
/usr/src/sys/kern/vfs_extattr.c:	error = mac_vnode_check_listextattr(td->td_ucred, vp, attrnamespace);
/usr/src/sys/kern/vfs_lookup.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_lookup.c:			error = mac_vnode_check_readlink(td->td_ucred,
/usr/src/sys/kern/vfs_lookup.c:		error = mac_vnode_check_lookup(cnp->cn_thread->td_ucred, dp,
/usr/src/sys/kern/vfs_lookup.c:		mac_vnode_post_lookup(cnp->cn_thread->td_ucred, dp,
/usr/src/sys/kern/vfs_mount.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_mount.c:	mac_mount_init(mp);
/usr/src/sys/kern/vfs_mount.c:	mac_mount_create(cred, mp);
/usr/src/sys/kern/vfs_mount.c:	mac_mount_destroy(mp);
/usr/src/sys/kern/vfs_subr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_subr.c:	mac_vnode_init(vp);
/usr/src/sys/kern/vfs_subr.c:		mac_vnode_associate_singlelabel(mp, vp);
/usr/src/sys/kern/vfs_subr.c:	mac_vnode_destroy(vp);
/usr/src/sys/kern/vfs_syscalls.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_mount_check_stat(td->td_ucred, mp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_mount_check_stat(td->td_ucred, mp);
/usr/src/sys/kern/vfs_syscalls.c:		if (mac_mount_check_stat(td->td_ucred, mp) != 0) {
/usr/src/sys/kern/vfs_syscalls.c:	if ((error = mac_vnode_check_chroot(td->td_ucred, nd.ni_vp)))
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_chdir(td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c: * responsible for invoking priv_check() and mac_vnode_check_chroot() to
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_create(td->td_ucred, nd.ni_dvp,
/usr/src/sys/kern/vfs_syscalls.c:				mac_vnode_post_create(td->td_ucred,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_create(td->td_ucred, nd.ni_dvp, &nd.ni_cnd,
/usr/src/sys/kern/vfs_syscalls.c:		mac_vnode_post_create(td->td_ucred,
/usr/src/sys/kern/vfs_syscalls.c:				error = mac_vnode_check_link(td->td_ucred,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_create(td->td_ucred, nd.ni_dvp, &nd.ni_cnd,
/usr/src/sys/kern/vfs_syscalls.c:		mac_vnode_post_create(td->td_ucred,
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_unlink(td->td_ucred, nd.ni_dvp, vp,
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_access(cred, vp, accmode);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_readlink(td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_setflags(td->td_ucred, vp, vattr.va_flags);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_setmode(cred, vp, vattr.va_mode);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_setowner(cred, vp, vattr.va_uid,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_setutimes(td->td_ucred, vp, vattr.va_atime,
/usr/src/sys/kern/vfs_syscalls.c:	else if ((error = mac_vnode_check_write(td->td_ucred, NOCRED, vp))) {
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_rename_from(td->td_ucred, fromnd.ni_dvp,
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_rename_to(td->td_ucred, tdvp,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_create(td->td_ucred, nd.ni_dvp, &nd.ni_cnd,
/usr/src/sys/kern/vfs_syscalls.c:		mac_vnode_post_create(td->td_ucred,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_unlink(td->td_ucred, nd.ni_dvp, vp,
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_readdir(td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_revoke(td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_vnode_check_open(td->td_ucred, vp, accmode);
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_write(td->td_ucred, td->td_ucred, vp);
/usr/src/sys/kern/vfs_syscalls.c:	error = mac_mount_check_stat(td->td_ucred, mp);
/usr/src/sys/kern/vfs_syscalls.c:		error = mac_vnode_check_write(td->td_ucred, fp->f_cred, vp);
/usr/src/sys/kern/vfs_vnops.c:#include <security/mac/mac_framework.h>
/usr/src/sys/kern/vfs_vnops.c:			error = mac_vnode_check_create(cred, ndp->ni_dvp,
/usr/src/sys/kern/vfs_vnops.c:		        mac_vnode_post_create(cred, ndp->ni_dvp, ndp->ni_vp,
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_open(cred, vp, accmode);
/usr/src/sys/kern/vfs_vnops.c:			error = mac_vnode_check_read(active_cred, file_cred,
/usr/src/sys/kern/vfs_vnops.c:			error = mac_vnode_check_write(active_cred, file_cred,
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_read(active_cred, fp->f_cred, vp);
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_write(active_cred, fp->f_cred, vp);
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_write(active_cred, fp->f_cred, vp);
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_stat(active_cred, file_cred, vp);
/usr/src/sys/kern/vfs_vnops.c:	error = mac_vnode_check_poll(active_cred, fp->f_cred, vp);
/usr/src/sys/kgssapi/krb5/krb5_mech.c:static uint8_t sgn_alg_hmac_md5[] = { 0x11, 0x00 };
/usr/src/sys/kgssapi/krb5/krb5_mech.c:		return (krb5_get_mic_old(kc, m, micp, sgn_alg_hmac_md5));
/usr/src/sys/kgssapi/krb5/krb5_mech.c:		return (krb5_verify_mic_old(kc, m, mic, sgn_alg_hmac_md5));
/usr/src/sys/kgssapi/krb5/krb5_mech.c:			mp, conf_state, sgn_alg_hmac_md5, seal_alg_rc4));
/usr/src/sys/kgssapi/krb5/krb5_mech.c:			sgn_alg_hmac_md5, seal_alg_rc4);
/usr/src/sys/mips/atheros/if_arge.c:	if (sc->arge_mac_unit == 0)
/usr/src/sys/mips/atheros/if_arge.c:	int			is_base_mac_empty, i, phys_total;
/usr/src/sys/mips/atheros/if_arge.c:	long			eeprom_mac_addr = 0;
/usr/src/sys/mips/atheros/if_arge.c:	sc->arge_mac_unit = device_get_unit(dev);
/usr/src/sys/mips/atheros/if_arge.c:	if (sc->arge_mac_unit == 0 &&
/usr/src/sys/mips/atheros/if_arge.c:	    "eeprommac", &eeprom_mac_addr) == 0) {
/usr/src/sys/mips/atheros/if_arge.c:		const char *mac = (const char *) MIPS_PHYS_TO_KSEG1(eeprom_mac_addr);
/usr/src/sys/mips/atheros/if_arge.c:	KASSERT(((sc->arge_mac_unit == 0) || (sc->arge_mac_unit == 1)), 
/usr/src/sys/mips/atheros/if_arge.c:		if (sc->arge_mac_unit == 0)
/usr/src/sys/mips/atheros/if_arge.c:	is_base_mac_empty = 1;
/usr/src/sys/mips/atheros/if_arge.c:			is_base_mac_empty = 0;
/usr/src/sys/mips/atheros/if_arge.c:	if (is_base_mac_empty) {
/usr/src/sys/mips/atheros/if_arge.c:	if (sc->arge_mac_unit != 0)
/usr/src/sys/mips/atheros/if_arge.c:		eaddr[5] +=  sc->arge_mac_unit;
/usr/src/sys/mips/atheros/if_arge.c:	ar71xx_device_stop(sc->arge_mac_unit == 0 ? RST_RESET_GE0_MAC : RST_RESET_GE1_MAC);
/usr/src/sys/mips/atheros/if_arge.c:	ar71xx_device_start(sc->arge_mac_unit == 0 ? RST_RESET_GE0_MAC : RST_RESET_GE1_MAC);
/usr/src/sys/mips/atheros/if_arge.c:	if (sc->arge_mac_unit == 0)
/usr/src/sys/mips/cavium/if_octm.c:	memcpy((u_int8_t *)&mac + 2, octeon_bootinfo->mac_addr_base, 6);
/usr/src/sys/mips/cavium/octe/ethernet-common.c:void cvm_oct_common_set_mac_address(struct ifnet *ifp, const void *addr)
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[0],
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[1],
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[2],
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[3],
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[4],
/usr/src/sys/mips/cavium/octe/ethernet-common.c:		octeon_bootinfo->mac_addr_base[5] };
/usr/src/sys/mips/cavium/octe/ethernet-common.c:	mac[5] += cvm_oct_mac_addr_offset++;
/usr/src/sys/mips/cavium/octe/ethernet-common.c:	cvm_oct_common_set_mac_address(ifp, mac);
/usr/src/sys/mips/cavium/octe/ethernet.c: * The offset from mac_addr_base that should be used for the next port
/usr/src/sys/mips/cavium/octe/ethernet.c:unsigned int cvm_oct_mac_addr_offset;
/usr/src/sys/mips/cavium/octe/ethernet.c:		cvm_oct_mac_addr_offset = 1;
/usr/src/sys/mips/cavium/octe/ethernet.c:		cvm_oct_mac_addr_offset = 2;
/usr/src/sys/mips/cavium/octe/ethernet.c:		cvm_oct_mac_addr_offset = 0;
/usr/src/sys/mips/cavium/octe/octe.c:	cvm_oct_common_set_mac_address(ifp, IF_LLADDR(ifp));
/usr/src/sys/mips/cavium/octeon_machdep.c:	uint8_t mac_addr_base[6];
/usr/src/sys/mips/cavium/octeon_machdep.c:	uint8_t mac_addr_count;
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[0],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[1],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[2],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[3],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[4],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_base[5],
/usr/src/sys/mips/cavium/octeon_machdep.c:	    octeon_bootinfo->mac_addr_count);
/usr/src/sys/mips/rmi/board.c:	struct xlr_gmac_block_t *blk0, *blk1, *blk2;
/usr/src/sys/mips/rmi/board.c:	blk0 = &board->gmac_block[0];
/usr/src/sys/mips/rmi/board.c:	blk1 = &board->gmac_block[1];
/usr/src/sys/mips/rmi/board.c:	blk2 = &board->gmac_block[2];
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[3].valid = 0;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[3].valid = 0;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[3].valid = 0;
/usr/src/sys/mips/rmi/board.c:	struct xlr_gmac_block_t *blk1, *blk2;
/usr/src/sys/mips/rmi/board.c:	blk1 = &board->gmac_block[1];
/usr/src/sys/mips/rmi/board.c:	blk2 = &board->gmac_block[2];
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].valid = 1;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].valid = 1;
/usr/src/sys/mips/rmi/board.c:	struct xlr_gmac_block_t *blk0, *blk1;
/usr/src/sys/mips/rmi/board.c:	blk0 = &board->gmac_block[0];
/usr/src/sys/mips/rmi/board.c:	blk1 = &board->gmac_block[1];
/usr/src/sys/mips/rmi/board.c:		blk0->gmac_port[3].valid = 0;
/usr/src/sys/mips/rmi/board.c:	struct xlr_gmac_block_t *blk0, *blk1;
/usr/src/sys/mips/rmi/board.c:	blk0 = &board->gmac_block[0];
/usr/src/sys/mips/rmi/board.c:	blk1 = &board->gmac_block[1];
/usr/src/sys/mips/rmi/board.c:		blk0->gmac_port[0].type = XLR_RGMII;
/usr/src/sys/mips/rmi/board.c:		blk0->gmac_port[0].phy_addr = 0;
/usr/src/sys/mips/rmi/board.c:		blk0->gmac_port[0].mii_addr = XLR_IO_GMAC_4_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[1].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[2].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[3].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[1].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[2].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[3].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk0->gmac_port[0].mdint_id = 1;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[1].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[2].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[3].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:				blk1->gmac_port[2].valid = 0;
/usr/src/sys/mips/rmi/board.c:				blk1->gmac_port[3].valid = 0;
/usr/src/sys/mips/rmi/board.c:				blk1->gmac_port[i].mii_addr =
/usr/src/sys/mips/rmi/board.c:				blk1->gmac_port[i].mdint_id = 0; 
/usr/src/sys/mips/rmi/board.c:				memset(&blk0->gmac_port[i], 0,
/usr/src/sys/mips/rmi/board.c:				    sizeof(blk0->gmac_port[i]));
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[0].type = XLR_XAUI;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[0].phy_addr = 16;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[0].tx_bucket_id = blk0->station_txbase;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[0].type = XLR_RGMII;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[0].phy_addr = 0;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[0].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:				memset(&blk1->gmac_port[i], 0,
/usr/src/sys/mips/rmi/board.c:				    sizeof(blk1->gmac_port[i]));
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[0].type = XLR_XAUI;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[0].phy_addr = 16;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[0].tx_bucket_id = blk1->station_txbase;
/usr/src/sys/mips/rmi/board.c:	struct xlr_gmac_block_t *blk0, *blk1, *blk2;
/usr/src/sys/mips/rmi/board.c:	blk0 = &xlr_board_info.gmac_block[0];
/usr/src/sys/mips/rmi/board.c:	blk1 = &xlr_board_info.gmac_block[1];
/usr/src/sys/mips/rmi/board.c:	blk2 = &xlr_board_info.gmac_block[2];
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].valid = 1;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].instance = i + blk0->baseinst;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].type = XLR_SGMII;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].phy_addr = i + 16;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].tx_bucket_id = 
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].base_addr = XLR_IO_GMAC_0_OFFSET + i * 0x1000;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].pcs_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].valid = 1;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].instance = i + blk1->baseinst;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].type = XLR_SGMII;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].phy_addr = i + 20;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].tx_bucket_id = 
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].mdint_id = 1;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].base_addr = XLR_IO_GMAC_4_OFFSET +  i * 0x1000;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].mii_addr = XLR_IO_GMAC_4_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].pcs_addr = XLR_IO_GMAC_4_OFFSET;
/usr/src/sys/mips/rmi/board.c:			blk1->gmac_port[i].serdes_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		xlr_board_info.gmac_block[2].enabled = 0;  /* disabled on XLS */
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].valid = 1;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].instance = i + blk0->baseinst;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].type = XLR_RGMII;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].phy_addr = i;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].tx_bucket_id = 
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].mdint_id = 0;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].base_addr = XLR_IO_GMAC_0_OFFSET + i * 0x1000;
/usr/src/sys/mips/rmi/board.c:			blk0->gmac_port[i].mii_addr = XLR_IO_GMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].type 	= XLR_XGMII;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].instance 	= 0;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].phy_addr 	= 0;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].base_addr 	= XLR_IO_XGMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].mii_addr 	= XLR_IO_XGMAC_0_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].tx_bucket_id = blk1->station_txbase;
/usr/src/sys/mips/rmi/board.c:		blk1->gmac_port[0].mdint_id 	= 1;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].type 	= XLR_XGMII;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].instance 	= 0;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].phy_addr 	= 0;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].base_addr 	= XLR_IO_XGMAC_1_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].mii_addr 	= XLR_IO_XGMAC_1_OFFSET;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].tx_bucket_id = blk2->station_txbase;
/usr/src/sys/mips/rmi/board.c:		blk2->gmac_port[0].mdint_id 	= 2;
/usr/src/sys/mips/rmi/dev/iic/at24co2n.c:	uint8_t		sc_mac_addr[6];
/usr/src/sys/mips/rmi/dev/iic/at24co2n.c:at24co2n_mac_sysctl(SYSCTL_HANDLER_ARGS)
/usr/src/sys/mips/rmi/dev/iic/at24co2n.c:	p = sc->sc_mac_addr;
/usr/src/sys/mips/rmi/dev/iic/at24co2n.c:		at24co2n_mac_sysctl, "A", "mac address");
/usr/src/sys/mips/rmi/dev/iic/at24co2n.c:	     { sc->sc_addr, IIC_M_RD, 6, sc->sc_mac_addr},
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:#include <mips/rmi/dev/xlr/xgmac_mdio.h>
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void	nlge_mac_mii_statchg(device_t);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_block_t *blk);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_block_t *blk);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static int	nlge_gmac_config_speed(struct nlge_softc *, int quick);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void 	nlge_read_mac_addr(struct nlge_softc *sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_port *port_info);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void 	nlge_set_mac_addr(struct nlge_softc *sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_port *);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void	nlge_mac_set_rx_mode(struct nlge_softc *sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static int	mac_debug = 1;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:            if (mac_debug) {\
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void	dump_gmac_registers(struct nlge_softc *);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:static void	dump_mac_stats(struct nlge_softc *sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:#define dump_gmac_registers(a)		/* nop */
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:#define dump_mac_stats(sc)		/* nop */
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	DEVMETHOD(miibus_statchg, nlge_mac_mii_statchg),
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_block_t *block_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	device_t		 gmac_dev;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			gmac_dev = device_add_child(dev, "nlge", -1);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			device_set_ivars(gmac_dev, &block_info->gmac_port[i]);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		gmac_dev = device_add_child(dev, "nlge", -1);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		device_set_ivars(gmac_dev, &block_info->gmac_port[0]);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_port	*port_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	nlge_gmac_config_speed(sc, 1);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	dump_gmac_registers(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	dump_mac_stats(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:				nlge_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:				nlge_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlge_mac_mii_statchg(device_t dev)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	if (sc->link == xlr_mac_link_down)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlna_sc_init(device_t dev, struct xlr_gmac_block_t *blk)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	sc->mac_type = blk->mode;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_port *port_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	return (id == 2 || xlr_board_info.gmac_block[id + 1].enabled == 0);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	if (sc->mac_type == XLR_XGMII) {	/* TBD: XGMII init sequence */
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_block_t *block_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct stn_cc 		*gmac_cc_config;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	gmac_cc_config = block_info->credit_config;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		    gmac_cc_config->counters[i >> 3][i & 0x07]);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	switch (sc->mac_type) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		if (sc->mac_type == XLR_XAUI) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlna_reset_ports(struct nlna_softc *sc, struct xlr_gmac_block_t *blk)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		addr = xlr_io_mmio(blk->gmac_port[i].base_addr);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		switch (sc->mac_type) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			    sc->mac_type);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_port  *self;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlge_mac_set_rx_mode(struct nlge_softc *sc)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:				nlge_gmac_config_speed(port_sc, 1);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_block_t *block_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_port  *port_info;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	nlge_set_mac_addr(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_port *port_info)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			nlge_gmac_config_speed(sc, 1);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlge_read_mac_addr(struct nlge_softc *sc)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		sc->dev_addr[i] = (xlr_boot1_info.mac_addr >> j) & 0xff;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlge_set_mac_addr(struct nlge_softc *sc)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	nlge_read_mac_addr(sc);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:nlge_gmac_config_speed(struct nlge_softc *sc, int quick)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		sc->link = (bmsr == 0) ? xlr_mac_link_down : xlr_mac_link_up;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		if (sc->link == xlr_mac_link_up) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	if (sc->speed == xlr_mac_speed_10 || sc->speed == xlr_mac_speed_100 ||
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	    sc->speed == xlr_mac_speed_rsvd) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	} else if (sc->speed == xlr_mac_speed_1000) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:    struct xlr_gmac_port *port_info)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:dump_gmac_registers(struct nlge_softc *sc)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:dump_fmn_cpu_credits_for_gmac(struct xlr_board_info *board, int gmac_id)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	int gmac_bucket_ids[] = { 97, 98, 99, 100, 101, 103 };
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	int n_gmac_buckets;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	n_gmac_buckets = sizeof (gmac_bucket_ids) / sizeof (gmac_bucket_ids[0]);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		for (k = 0; k < n_gmac_buckets; k++) {
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			r = gmac_bucket_ids[k] / 8;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			c = gmac_bucket_ids[k] % 8;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:			printf ("    --> gmac%d_bucket_%-3d: credits=%d\n", gmac_id,
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:				gmac_bucket_ids[k], cc->counters[r][c]);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:dump_fmn_gmac_credits(struct xlr_board_info *board, int gmac_id)
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	cc = board->gmac_block[gmac_id].credit_config;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	printf("Credits for Station: GMAC_%d ---> CPU buckets (rx path)\n", gmac_id);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	struct xlr_gmac_block_t *gm;
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:	    "gmac_ports=%d\n", board->is_xls, board->nr_cpus,
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		gm = &board->gmac_block[i];
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:		dump_fmn_gmac_credits(board, k);
/usr/src/sys/mips/rmi/dev/nlge/if_nlge.c:dump_mac_stats(struct nlge_softc *sc)
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	uint32_t hmac_flag = 0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_flag = 1;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_flag = 1;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_flag = 1;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_flag = 1;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_flag = 1;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	if (hmac_flag == 1) {
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	if (hmac_flag || hash_flag) {
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	}			/* hmac_flag */
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	uint64_t *hmac_key = NULL;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	uint32_t hmac_keylen = 0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoHMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateHMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoDESHMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.info3DESHMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8HMAC.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoHMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateHMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoDESHMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.info3DESHMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8HMAC2.hmacKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(HMAC2_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoGCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateGCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoDESGCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.info3DESGCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8GCM.GCMH0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(GCM_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoF9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateF9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoDESF9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.info3DESF9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8F9.authKey0;
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		hmac_keylen = sizeof(F9_t);
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:	if ((hmac_key != NULL) && !(flags & XLR_SEC_SETUP_OP_PRESERVE_HMAC_KEY))
/usr/src/sys/mips/rmi/dev/sec/rmilib.c:		memcpy(hmac_key, &op->mac_key[0], hmac_keylen);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:#include <mips/rmi/dev/xlr/xgmac_mdio.h>
/usr/src/sys/mips/rmi/dev/xlr/rge.c:int mac_debug = 1;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:            if (mac_debug) {\
/usr/src/sys/mips/rmi/dev/xlr/rge.c:int mac_debug = 0;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:/* #define mac_stats_add(x, val) ({(x) += (val);}) */
/usr/src/sys/mips/rmi/dev/xlr/rge.c:#define mac_stats_add(x, val) xlr_ldaddwu(val, &x)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int dev_mac_xgs0;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int dev_mac_gmac0;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int gmac_common_init_done;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void xlr_mac_get_hwaddr(struct rge_softc *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void xlr_mac_setup_hwaddr(struct driver_data *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_mac_set_enable(struct driver_data *priv, int flag);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_xgmac_init(struct driver_data *priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_gmac_init(struct driver_data *priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void mac_common_init(void);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_mac_mii_statchg(device_t);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_mediachange(struct ifnet *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_mac_mediastatus(struct ifnet *, struct ifmediareq *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void xlr_mac_set_rx_mode(struct rge_softc *sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_msgring_handler(int bucket, int size, int code,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void mac_frin_replenish(void *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_open(struct rge_softc *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_close(struct rge_softc *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:mac_xmit(struct mbuf *, struct rge_softc *,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_xmit(struct mbuf *, struct rge_softc *, int, struct p2d_tx_desc *);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static struct rge_softc_stats *rmi_xlr_mac_get_stats(struct rge_softc *sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static void rmi_xlr_mac_set_multicast_list(struct rge_softc *sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_change_mtu(struct rge_softc *sc, int new_mtu);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_fill_rxfr(struct rge_softc *sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_mac_set_speed(struct driver_data *s, xlr_mac_speed_t speed);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_set_duplex(struct driver_data *s,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:    xlr_mac_duplex_t duplex, xlr_mac_fc_t fc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:static int rmi_xlr_gmac_reset(struct driver_data *priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	DEVMETHOD(miibus_statchg, rmi_xlr_mac_mii_statchg),
/usr/src/sys/mips/rmi/dev/xlr/rge.c:mac_make_desc_rfr(struct msgrng_msg *msg,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_set_enable(struct driver_data *priv, int flag)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:xlr_mac_send_fr(struct driver_data *priv,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	mac_make_desc_rfr(&msg, addr);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	dbg_msg("mac_%d: Sending free packet %lx to stid %d\n",
/usr/src/sys/mips/rmi/dev/xlr/rge.c:xgmac_mdio_setup(volatile unsigned int *_mmio)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_mii_init(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_mediachange(struct ifnet *ifp)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_mii_statchg(struct device *dev)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		rmi_xlr_mac_set_enable(priv, 0);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		rmi_xlr_mac_set_enable(priv, 1);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_gmac_config_speed(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	if (priv->speed == xlr_mac_speed_10) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	} else if (priv->speed == xlr_mac_speed_100) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		if (priv->speed != xlr_mac_speed_1000) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_xgmac_init(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	xgmac_mdio_setup(mmio);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_gmac_reset(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_gmac_init(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	struct stn_cc *gmac_cc_config;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 0);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_mii_init(priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_gmac_config_speed(priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	gmac_cc_config = xlr_board_info.gmac_block[blk].credit_config;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		    gmac_cc_config->counters[i >> 3][i & 0x07]);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		    R_CC_CPU0_0 + i, gmac_cc_config->counters[i >> 3][i & 0x07]);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:xlr_mac_set_rx_mode(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_set_speed(struct driver_data *s, xlr_mac_speed_t speed)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_set_duplex(struct driver_data *s,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:    xlr_mac_duplex_t duplex, xlr_mac_fc_t fc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:mac_xmit(struct mbuf *m, struct rge_softc *sc,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_xmit(struct mbuf *m, struct rge_softc *sc, int len, struct p2d_tx_desc *tx_desc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	ret = mac_xmit(m, sc, priv, len, tx_desc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:mac_frin_replenish(void *args /* ignored */ )
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				panic("BUG?: [%s]: gmac_%d illegal value for frin_to_be_sent=%d\n",
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			if (xlr_mac_send_fr(priv, vtophys(m), MAX_FRAME_SIZE)) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_msgring_handler(int bucket, int size, int code,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		sc = dev_mac[dev_mac_gmac0 + port];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			sc = dev_mac[dev_mac_xgs0];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			sc = dev_mac[dev_mac_xgs0 + 1];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			sc = dev_mac[dev_mac_gmac0 + port];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			mac_frin_replenish(NULL);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		dbg_msg("gmac_%d: rx packet: phys_addr = %jx, length = %x\n",
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		mac_stats_add(priv->stats.rx_packets, 1);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		mac_stats_add(priv->stats.rx_bytes, length);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	struct xlr_gmac_block_t *gmac_conf = device_get_ivars(dev);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	if (gmac_conf->type == XLR_GMAC) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		priv->mmio = (xlr_reg_t *) (xlr_io_base + gmac_conf->baseaddr +
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		if ((ret = rmi_xlr_gmac_reset(priv)) == -1)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	} else if (gmac_conf->type == XLR_XGMAC) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		priv->mmio = (xlr_reg_t *) (xlr_io_base + gmac_conf->baseaddr);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	priv->pcs_mmio = (xlr_reg_t *) (xlr_io_base + gmac_conf->baseaddr);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->get_stats = rmi_xlr_mac_get_stats;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	priv->type = gmac_conf->type;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	priv->mode = gmac_conf->mode;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		if (gmac_conf->mode == XLR_PORT0_RGMII &&
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	priv->txbucket = gmac_conf->station_txbase + priv->instance % 4;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	priv->rfrbucket = gmac_conf->station_rfr;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->irq = gmac_conf->baseirq + priv->instance % 4;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	xlr_mac_get_hwaddr(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	xlr_mac_setup_hwaddr(priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->rge_mii.mii_statchg = rmi_xlr_mac_mii_statchg;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	ifmedia_init(&sc->rge_mii.mii_media, 0, rmi_xlr_mac_mediachange,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	    rmi_xlr_mac_mediastatus);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		rmi_xlr_gmac_init(priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		rmi_xlr_xgmac_init(priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		dev_mac_xgs0 = sc->unit;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		dev_mac_gmac0 = sc->unit;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	if (!gmac_common_init_done) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		mac_common_init();
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		gmac_common_init_done = 1;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	if ((ret = rmi_xlr_mac_open(sc)) == -1) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:uint32_t gmac_rx_fail[32];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:uint32_t gmac_rx_pass[32];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			rmi_xlr_gmac_config_speed(phy_priv);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		struct rge_softc *xgs0_dev = dev_mac[dev_mac_xgs0];
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		prepend_pkt = rmi_xlr_mac_xmit(m, sc, 0, tx_desc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		error = rmi_xlr_mac_change_mtu(sc, ifr->ifr_mtu);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				xlr_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				xlr_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				rmi_xlr_mac_set_multicast_list(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				xlr_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:				xlr_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:			rmi_xlr_mac_set_multicast_list(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 1);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_close(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_open(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	if (rmi_xlr_mac_fill_rxfr(sc)) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	xlr_mac_set_rx_mode(sc);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_speed(priv, priv->speed);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_duplex(priv, priv->duplex, priv->flow_ctrl);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 0);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_close(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 0);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_get_stats(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_set_multicast_list(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_change_mtu(struct rge_softc *sc, int new_mtu)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 0);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	rmi_xlr_mac_set_enable(priv, 1);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:rmi_xlr_mac_fill_rxfr(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		xlr_mac_send_fr(priv, vtophys(ptr), MAX_FRAME_SIZE);
/usr/src/sys/mips/rmi/dev/xlr/rge.c:xlr_mac_setup_hwaddr(struct driver_data *priv)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:xlr_mac_get_hwaddr(struct rge_softc *sc)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[0] = (xlr_boot1_info.mac_addr >> 40) & 0xff;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[1] = (xlr_boot1_info.mac_addr >> 32) & 0xff;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[2] = (xlr_boot1_info.mac_addr >> 24) & 0xff;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[3] = (xlr_boot1_info.mac_addr >> 16) & 0xff;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[4] = (xlr_boot1_info.mac_addr >> 8) & 0xff;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	sc->dev_addr[5] = ((xlr_boot1_info.mac_addr >> 0) & 0xff) + priv->instance;
/usr/src/sys/mips/rmi/dev/xlr/rge.c:mac_common_init(void)
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		   MSGRNG_STNID_GMAC + 1, rmi_xlr_mac_msgring_handler,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		    MSGRNG_STNID_GMAC1 + 1, rmi_xlr_mac_msgring_handler,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:		   MSGRNG_STNID_GMAC + 1, rmi_xlr_mac_msgring_handler,
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	 * (TX_STN_XGS_0, rmi_xlr_mac_msgring_handler, NULL)) {
/usr/src/sys/mips/rmi/dev/xlr/rge.c:	 * rmi_xlr_mac_msgring_handler, NULL)) { panic("Couldn't register
/usr/src/sys/mips/rmi/iodi.c:#include <mips/rmi/dev/xlr/xgmac_mdio.h>
/usr/src/sys/mips/rmi/iodi.c:	if (xlr_board_info.gmac_block[0].enabled) {
/usr/src/sys/mips/rmi/iodi.c:		device_set_ivars(tmpd, &xlr_board_info.gmac_block[0]);
/usr/src/sys/mips/rmi/iodi.c:		device_set_ivars(tmpd, &xlr_board_info.gmac_block[0]);
/usr/src/sys/mips/rmi/iodi.c:		device_set_ivars(tmpd, &xlr_board_info.gmac_block[0]);
/usr/src/sys/mips/rmi/iodi.c:		device_set_ivars(tmpd, &xlr_board_info.gmac_block[0]);
/usr/src/sys/mips/rmi/iodi.c:	if (xlr_board_info.gmac_block[1].enabled) {
/usr/src/sys/mips/rmi/iodi.c:		if (xlr_board_info.gmac_block[1].type == XLR_GMAC) {
/usr/src/sys/mips/rmi/iodi.c:			device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:			device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:			if (xlr_board_info.gmac_block[1].enabled & 0x4) {
/usr/src/sys/mips/rmi/iodi.c:				device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:			if (xlr_board_info.gmac_block[1].enabled & 0x8) {
/usr/src/sys/mips/rmi/iodi.c:				device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:		} else if (xlr_board_info.gmac_block[1].type == XLR_XGMAC) {
/usr/src/sys/mips/rmi/iodi.c:			device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:			device_set_ivars(tmpd, &xlr_board_info.gmac_block[1]);
/usr/src/sys/mips/rmi/iodi.c:		if (xlr_board_info.gmac_block[i].enabled == 0)
/usr/src/sys/mips/rmi/iodi.c:		device_set_ivars(tmpd, &xlr_board_info.gmac_block[i]);
/usr/src/sys/net/bpf.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/bpf.c:	mac_bpfdesc_destroy(d);
/usr/src/sys/net/bpf.c:	mac_bpfdesc_init(d);
/usr/src/sys/net/bpf.c:	mac_bpfdesc_create(td->td_ucred, d);
/usr/src/sys/net/bpf.c:	mac_bpfdesc_create_mbuf(d, m);
/usr/src/sys/net/bpf.c:		mac_bpfdesc_create_mbuf(d, mc);
/usr/src/sys/net/bpf.c:			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
/usr/src/sys/net/bpf.c:			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
/usr/src/sys/net/bpf.c:			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
/usr/src/sys/net/if.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if.c:	mac_ifnet_init(ifp);
/usr/src/sys/net/if.c:	mac_ifnet_destroy(ifp);
/usr/src/sys/net/if.c:		mac_ifnet_create(ifp);
/usr/src/sys/net/if.c:		error = mac_ifnet_ioctl_get(td->td_ucred, ifr, ifp);
/usr/src/sys/net/if.c:		error = mac_ifnet_ioctl_set(td->td_ucred, ifr, ifp);
/usr/src/sys/net/if_atmsubr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_atmsubr.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_atmsubr.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_ethersubr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_ethersubr.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_ethersubr.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_fddisubr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_fddisubr.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_fddisubr.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_fwsubr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_fwsubr.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_fwsubr.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_gif.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_gif.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_gif.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_iso88025subr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_iso88025subr.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_iso88025subr.c:	int mac_hdr_len;
/usr/src/sys/net/if_iso88025subr.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_iso88025subr.c:	mac_hdr_len = ISO88025_HDR_LEN;
/usr/src/sys/net/if_iso88025subr.c:		mac_hdr_len += TR_RCF_RIFLEN(th->rcf);
/usr/src/sys/net/if_iso88025subr.c:	m_adj(m, mac_hdr_len);
/usr/src/sys/net/if_loop.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_loop.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_loop.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_stf.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_stf.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net/if_stf.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net/if_tun.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net/if_tun.c:	error = mac_ifnet_check_transmit(ifp, m0);
/usr/src/sys/net/if_tun.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/net80211/ieee80211.c:ieee80211_mac_hash(const struct ieee80211com *ic,
/usr/src/sys/net80211/ieee80211_hwmp.c:		ieee80211_mac_hash(ic, rt->rt_dest));
/usr/src/sys/net80211/ieee80211_hwmp.c:			    ieee80211_mac_hash(ic, dest);
/usr/src/sys/net80211/ieee80211_mesh.c:		   (void *)(uintptr_t) ieee80211_mac_hash(ic, dest));
/usr/src/sys/net80211/ieee80211_mesh.c:	   (void *)(uintptr_t) ieee80211_mac_hash(ic, ni->ni_macaddr));
/usr/src/sys/net80211/ieee80211_output.c:#include <security/mac/mac_framework.h>
/usr/src/sys/net80211/ieee80211_output.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/net80211/ieee80211_wds.c:	    (void *)(uintptr_t) ieee80211_mac_hash(ic, ni->ni_macaddr));
/usr/src/sys/net80211/ieee80211_wds.c:	    ieee80211_mac_hash(ic, ni->ni_macaddr);
/usr/src/sys/netatalk/aarp.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netatalk/aarp.c:	mac_netatalk_aarp_send(ifp, m);
/usr/src/sys/netatalk/aarp.c:	mac_netatalk_aarp_send(ifp, m);
/usr/src/sys/netatalk/ddp_input.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netatalk/ddp_input.c:	if (mac_socket_check_deliver(ddp->ddp_socket, m) != 0)
/usr/src/sys/netatalk/ddp_output.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netatalk/ddp_output.c:	mac_socket_create_mbuf(so, m);
/usr/src/sys/netatalk/ddp_output.c:	 * removing mac_mbuf_copy().
/usr/src/sys/netatalk/ddp_output.c:		mac_mbuf_copy(m, m0);
/usr/src/sys/netinet/if_ether.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/if_ether.c:	mac_netinet_arp_send(ifp, m);
/usr/src/sys/netinet/igmp.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/igmp.c:	mac_netinet_igmp_send(ifp, m0);
/usr/src/sys/netinet/in_pcb.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/in_pcb.c:	error = mac_inpcb_init(inp, M_NOWAIT);
/usr/src/sys/netinet/in_pcb.c:	mac_inpcb_create(so, inp);
/usr/src/sys/netinet/in_pcb.c:		mac_inpcb_destroy(inp);
/usr/src/sys/netinet/in_pcb.c:	mac_inpcb_destroy(inp);
/usr/src/sys/netinet/in_pcb.c:	mac_inpcb_sosetlabel(so, inp);
/usr/src/sys/netinet/ip_carp.c:static void	carp_hmac_prepare(struct carp_softc *);
/usr/src/sys/netinet/ip_carp.c:static void	carp_hmac_generate(struct carp_softc *, u_int32_t *,
/usr/src/sys/netinet/ip_carp.c:static int	carp_hmac_verify(struct carp_softc *, u_int32_t *,
/usr/src/sys/netinet/ip_carp.c:carp_hmac_prepare(struct carp_softc *sc)
/usr/src/sys/netinet/ip_carp.c:carp_hmac_generate(struct carp_softc *sc, u_int32_t counter[2],
/usr/src/sys/netinet/ip_carp.c:carp_hmac_verify(struct carp_softc *sc, u_int32_t counter[2],
/usr/src/sys/netinet/ip_carp.c:	carp_hmac_generate(sc, counter, md2);
/usr/src/sys/netinet/ip_carp.c:	if (carp_hmac_verify(sc, ch->carp_counter, ch->carp_md)) {
/usr/src/sys/netinet/ip_carp.c:	carp_hmac_generate(sc, ch->carp_counter, ch->carp_md);
/usr/src/sys/netinet/ip_carp.c:	carp_hmac_prepare(sc);
/usr/src/sys/netinet/ip_divert.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/ip_divert.c:		mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netinet/ip_divert.c:		mac_socket_create_mbuf(so, m);
/usr/src/sys/netinet/ip_icmp.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/ip_icmp.c:	mac_netinet_icmp_reply(n, m);
/usr/src/sys/netinet/ip_icmp.c:	mac_netinet_icmp_replyinplace(m);
/usr/src/sys/netinet/ip_input.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/ip_input.c:		    mac_ipq_match(m, fp) &&
/usr/src/sys/netinet/ip_input.c:		if (mac_ipq_init(fp, M_NOWAIT) != 0) {
/usr/src/sys/netinet/ip_input.c:		mac_ipq_create(m, fp);
/usr/src/sys/netinet/ip_input.c:		mac_ipq_update(m, fp);
/usr/src/sys/netinet/ip_input.c:	mac_ipq_reassemble(fp, m);
/usr/src/sys/netinet/ip_input.c:	mac_ipq_destroy(fp);
/usr/src/sys/netinet/ip_output.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/ip_output.c:		mac_netinet_fragment(m0, m);
/usr/src/sys/netinet/raw_ip.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/raw_ip.c:	if (!policyfail && mac_inpcb_check_deliver(last, n) != 0)
/usr/src/sys/netinet/raw_ip.c:	mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netinet/sctp_auth.c:sctp_auth_add_hmacid(sctp_hmaclist_t * list, uint16_t hmac_id)
/usr/src/sys/netinet/sctp_auth.c:		    "SCTP: HMAC id list full, ignoring add %u\n", hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	if ((hmac_id != SCTP_AUTH_HMAC_ID_SHA1) &&
/usr/src/sys/netinet/sctp_auth.c:	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA224) &&
/usr/src/sys/netinet/sctp_auth.c:	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA256) &&
/usr/src/sys/netinet/sctp_auth.c:	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA384) &&
/usr/src/sys/netinet/sctp_auth.c:	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA512) &&
/usr/src/sys/netinet/sctp_auth.c:		if (list->hmac[i] == hmac_id) {
/usr/src/sys/netinet/sctp_auth.c:	SCTPDBG(SCTP_DEBUG_AUTH1, "SCTP: add HMAC id %u to list\n", hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	list->hmac[list->num_algo++] = hmac_id;
/usr/src/sys/netinet/sctp_auth.c:	uint16_t hmac_id;
/usr/src/sys/netinet/sctp_auth.c:		hmac_id = htons(list->hmac[i]);
/usr/src/sys/netinet/sctp_auth.c:		bcopy(&hmac_id, ptr, sizeof(hmac_id));
/usr/src/sys/netinet/sctp_auth.c:		ptr += sizeof(hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	return (list->num_algo * sizeof(hmac_id));
/usr/src/sys/netinet/sctp_auth.c:sctp_verify_hmac_param(struct sctp_auth_hmac_algo *hmacs, uint32_t num_hmacs)
/usr/src/sys/netinet/sctp_auth.c:	uint16_t hmac_id;
/usr/src/sys/netinet/sctp_auth.c:		hmac_id = ntohs(hmacs->hmac_ids[i]);
/usr/src/sys/netinet/sctp_auth.c:		if (hmac_id == SCTP_AUTH_HMAC_ID_SHA1)
/usr/src/sys/netinet/sctp_auth.c:sctp_get_auth_chunk_len(uint16_t hmac_algo)
/usr/src/sys/netinet/sctp_auth.c:	size = sizeof(struct sctp_auth_chunk) + sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:sctp_get_hmac_digest_len(uint16_t hmac_algo)
/usr/src/sys/netinet/sctp_auth.c:	switch (hmac_algo) {
/usr/src/sys/netinet/sctp_auth.c:sctp_get_hmac_block_len(uint16_t hmac_algo)
/usr/src/sys/netinet/sctp_auth.c:	switch (hmac_algo) {
/usr/src/sys/netinet/sctp_auth.c:sctp_hmac_init(uint16_t hmac_algo, sctp_hash_context_t * ctx)
/usr/src/sys/netinet/sctp_auth.c:	switch (hmac_algo) {
/usr/src/sys/netinet/sctp_auth.c:sctp_hmac_update(uint16_t hmac_algo, sctp_hash_context_t * ctx,
/usr/src/sys/netinet/sctp_auth.c:	switch (hmac_algo) {
/usr/src/sys/netinet/sctp_auth.c:sctp_hmac_final(uint16_t hmac_algo, sctp_hash_context_t * ctx,
/usr/src/sys/netinet/sctp_auth.c:	switch (hmac_algo) {
/usr/src/sys/netinet/sctp_auth.c:sctp_hmac(uint16_t hmac_algo, uint8_t * key, uint32_t keylen,
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:	blocklen = sctp_get_hmac_block_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_update(hmac_algo, &ctx, key, keylen);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, text, textlen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, opad, blocklen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, temp, digestlen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_final(hmac_algo, &ctx, digest);
/usr/src/sys/netinet/sctp_auth.c:sctp_hmac_m(uint16_t hmac_algo, uint8_t * key, uint32_t keylen,
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:	blocklen = sctp_get_hmac_block_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_update(hmac_algo, &ctx, key, keylen);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);
/usr/src/sys/netinet/sctp_auth.c:			sctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,
/usr/src/sys/netinet/sctp_auth.c:			sctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, opad, blocklen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_update(hmac_algo, &ctx, temp, digestlen);
/usr/src/sys/netinet/sctp_auth.c:	sctp_hmac_final(hmac_algo, &ctx, digest);
/usr/src/sys/netinet/sctp_auth.c:sctp_verify_hmac(uint16_t hmac_algo, uint8_t * key, uint32_t keylen,
/usr/src/sys/netinet/sctp_auth.c:	len = sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:	if (sctp_hmac(hmac_algo, key, keylen, text, textlen, temp) != len)
/usr/src/sys/netinet/sctp_auth.c:sctp_compute_hmac(uint16_t hmac_algo, sctp_key_t * key, uint8_t * text,
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:	blocklen = sctp_get_hmac_block_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	return (sctp_hmac(hmac_algo, key->key, key->keylen, text, textlen,
/usr/src/sys/netinet/sctp_auth.c:sctp_compute_hmac_m(uint16_t hmac_algo, sctp_key_t * key, struct mbuf *m,
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:	blocklen = sctp_get_hmac_block_len(hmac_algo);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_init(hmac_algo, &ctx);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);
/usr/src/sys/netinet/sctp_auth.c:		sctp_hmac_final(hmac_algo, &ctx, temp);
/usr/src/sys/netinet/sctp_auth.c:	return (sctp_hmac_m(hmac_algo, key->key, key->keylen, m, m_offset, digest, 0));
/usr/src/sys/netinet/sctp_auth.c:	struct sctp_auth_hmac_algo *hmacs = NULL;
/usr/src/sys/netinet/sctp_auth.c:			hmacs = (struct sctp_auth_hmac_algo *)phdr;
/usr/src/sys/netinet/sctp_auth.c:			num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);
/usr/src/sys/netinet/sctp_auth.c:					    ntohs(hmacs->hmac_ids[i]));
/usr/src/sys/netinet/sctp_auth.c:	stcb->asoc.peer_hmac_id = sctp_negotiate_hmacid(stcb->asoc.peer_hmacs,
/usr/src/sys/netinet/sctp_auth.c:sctp_fill_hmac_digest_m(struct mbuf *m, uint32_t auth_offset,
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	(void)sctp_compute_hmac_m(stcb->asoc.peer_hmac_id, stcb->asoc.authinfo.assoc_key,
/usr/src/sys/netinet/sctp_auth.c:	uint16_t hmac_id;
/usr/src/sys/netinet/sctp_auth.c:	hmac_id = ntohs(auth->hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	    shared_key_id, hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	if (!sctp_auth_is_supported_hmac(stcb->asoc.local_hmacs, hmac_id)) {
/usr/src/sys/netinet/sctp_auth.c:		    hmac_id);
/usr/src/sys/netinet/sctp_auth.c:			err->hmac_id = ntohs(hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	digestlen = sctp_get_hmac_digest_len(hmac_id);
/usr/src/sys/netinet/sctp_auth.c:	(void)sctp_compute_hmac_m(hmac_id, stcb->asoc.authinfo.recv_key,
/usr/src/sys/netinet/sctp_auth.c:			struct sctp_auth_hmac_algo *hmacs;
/usr/src/sys/netinet/sctp_auth.c:			hmacs = (struct sctp_auth_hmac_algo *)phdr;
/usr/src/sys/netinet/sctp_auth.c:			    sizeof(hmacs->hmac_ids[0]);
/usr/src/sys/netinet/sctp_auth.c:			if (sctp_verify_hmac_param(hmacs, num_hmacs)) {
/usr/src/sys/netinet/sctp_input.c:	stcb->asoc.peer_hmac_id = sctp_negotiate_hmacid(stcb->asoc.peer_hmacs,
/usr/src/sys/netinet/sctp_input.c:	 * calculated in the sctp_hmac_m() call).
/usr/src/sys/netinet/sctp_input.c:		(void)sctp_hmac_m(SCTP_HMAC,
/usr/src/sys/netinet/sctp_input.c:		(void)sctp_hmac_m(SCTP_HMAC,
/usr/src/sys/netinet/sctp_input.c:			(void)sctp_hmac_m(SCTP_HMAC,
/usr/src/sys/netinet/sctp_output.c:		sctp_fill_hmac_digest_m(m, auth_offset, auth, stcb, auth_keyid);
/usr/src/sys/netinet/sctp_output.c:			struct sctp_auth_hmac_algo *hmacs;
/usr/src/sys/netinet/sctp_output.c:			hmacs = (struct sctp_auth_hmac_algo *)(mtod(m, caddr_t)+chunk_len);
/usr/src/sys/netinet/sctp_output.c:			parameter_len = (uint16_t) (sizeof(struct sctp_auth_hmac_algo) +
/usr/src/sys/netinet/sctp_output.c:			sctp_serialize_hmaclist(stcb->asoc.local_hmacs, (uint8_t *) hmacs->hmac_ids);
/usr/src/sys/netinet/sctp_output.c:		struct sctp_auth_hmac_algo *hmacs;
/usr/src/sys/netinet/sctp_output.c:		hmacs = (struct sctp_auth_hmac_algo *)(mtod(m, caddr_t)+SCTP_BUF_LEN(m));
/usr/src/sys/netinet/sctp_output.c:		    (uint8_t *) hmacs->hmac_ids);
/usr/src/sys/netinet/sctp_output.c:	(void)sctp_hmac_m(SCTP_HMAC,
/usr/src/sys/netinet/sctp_output.c:		siz -= sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:				omtu = sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:				omtu = sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:			mtu -= sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:			dmtu = sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:					dmtu = sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:	    sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_output.c:	auth->hmac_id = htons(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_pcb.c:	struct sctp_auth_hmac_algo *hmacs = NULL;
/usr/src/sys/netinet/sctp_pcb.c:			hmacs = (struct sctp_auth_hmac_algo *)phdr;
/usr/src/sys/netinet/sctp_pcb.c:			num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);
/usr/src/sys/netinet/sctp_pcb.c:			if (sctp_verify_hmac_param(hmacs, num_hmacs)) {
/usr/src/sys/netinet/sctp_pcb.c:					    ntohs(hmacs->hmac_ids[i]));
/usr/src/sys/netinet/sctp_usrreq.c:		overhead += sctp_get_auth_chunk_len(stcb->asoc.peer_hmac_id);
/usr/src/sys/netinet/sctp_usrreq.c:			    sizeof(shmac->shmac_idents[0]));
/usr/src/sys/netinet/sctp_usrreq.c:			shmac->shmac_number_of_idents = hmaclist->num_algo;
/usr/src/sys/netinet/sctp_usrreq.c:				shmac->shmac_idents[i] = hmaclist->hmac[i];
/usr/src/sys/netinet/sctp_usrreq.c:			if (optsize < sizeof(struct sctp_hmacalgo) + shmac->shmac_number_of_idents * sizeof(uint16_t)) {
/usr/src/sys/netinet/sctp_usrreq.c:			hmaclist = sctp_alloc_hmaclist(shmac->shmac_number_of_idents);
/usr/src/sys/netinet/sctp_usrreq.c:			for (i = 0; i < shmac->shmac_number_of_idents; i++) {
/usr/src/sys/netinet/sctp_usrreq.c:				hmacid = shmac->shmac_idents[i];
/usr/src/sys/netinet/sctp_usrreq.c:					goto sctp_set_hmac_done;
/usr/src/sys/netinet/sctp_usrreq.c:	sctp_set_hmac_done:
/usr/src/sys/netinet/tcp_input.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/tcp_input.c:	if (mac_inpcb_check_deliver(inp, m))
/usr/src/sys/netinet/tcp_input.c:			mac_socketpeer_set_from_mbuf(m, so);
/usr/src/sys/netinet/tcp_output.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/tcp_output.c:	mac_inpcb_create_mbuf(tp->t_inpcb, m);
/usr/src/sys/netinet/tcp_subr.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/tcp_subr.c:		mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netinet/tcp_subr.c:		mac_netinet_tcp_reply(m);
/usr/src/sys/netinet/tcp_syncache.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/tcp_syncache.c:	mac_syncache_destroy(&sc->sc_label);
/usr/src/sys/netinet/tcp_syncache.c:	mac_socketpeer_set_from_mbuf(m, so);
/usr/src/sys/netinet/tcp_syncache.c:	if (mac_syncache_init(&maclabel) != 0) {
/usr/src/sys/netinet/tcp_syncache.c:		mac_syncache_create(maclabel, inp);
/usr/src/sys/netinet/tcp_syncache.c:		mac_syncache_destroy(&maclabel);
/usr/src/sys/netinet/tcp_syncache.c:		mac_syncache_destroy(&maclabel);
/usr/src/sys/netinet/tcp_syncache.c:	mac_syncache_create_mbuf(sc->sc_label, m);
/usr/src/sys/netinet/tcp_timewait.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/tcp_timewait.c:	mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netinet/udp_usrreq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet/udp_usrreq.c:	if (mac_inpcb_check_deliver(inp, n) != 0) {
/usr/src/sys/netinet/udp_usrreq.c:	mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netinet6/frag6.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet6/frag6.c:		    && mac_ip6q_match(m, q6)
/usr/src/sys/netinet6/frag6.c:		if (mac_ip6q_init(q6, M_NOWAIT) != 0) {
/usr/src/sys/netinet6/frag6.c:		mac_ip6q_create(m, q6);
/usr/src/sys/netinet6/frag6.c:		mac_ip6q_update(m, q6);
/usr/src/sys/netinet6/frag6.c:			mac_ip6q_destroy(q6);
/usr/src/sys/netinet6/frag6.c:	mac_ip6q_reassemble(q6, m);
/usr/src/sys/netinet6/frag6.c:	mac_ip6q_destroy(q6);
/usr/src/sys/netinet6/frag6.c:	mac_ip6q_destroy(q6);
/usr/src/sys/netinet6/in6.c:		memcpy(gateway.sdl_data, &ln->ll_addr.mac_aligned,
/usr/src/sys/netinet6/mld6.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet6/nd6.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet6/nd6.c:	mac_netinet6_nd6_send(ifp, m);
/usr/src/sys/netinet6/udp6_usrreq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netinet6/udp6_usrreq.c:	if (mac_inpcb_check_deliver(inp, n) != 0) {
/usr/src/sys/netinet6/udp6_usrreq.c:	mac_inpcb_create_mbuf(inp, m);
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_md5;
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_sha1;
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_ripemd_160;
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_sha2_256;
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_sha2_384;
/usr/src/sys/netipsec/xform_ah.c:		return &auth_hash_hmac_sha2_512;
/usr/src/sys/netipx/ipx_usrreq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netipx/ipx_usrreq.c:	if (mac_socket_check_deliver(ipxp->ipxp_socket, m) != 0) {
/usr/src/sys/netipx/ipx_usrreq.c:	mac_socket_create_mbuf(so, m);
/usr/src/sys/netipx/spx_usrreq.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netipx/spx_usrreq.c:	if (mac_socket_check_deliver(so, m) != 0)
/usr/src/sys/netipx/spx_usrreq.c:	mac_socket_create_mbuf(so, m);
/usr/src/sys/netpfil/ipfw/ip_fw2.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netpfil/ipfw/ip_fw_dynamic.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netpfil/ipfw/ip_fw_dynamic.c:		mac_netinet_firewall_reply(replyto, m);
/usr/src/sys/netpfil/ipfw/ip_fw_dynamic.c:		mac_netinet_firewall_send(m);
/usr/src/sys/netpfil/ipfw/ip_fw_log.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netpfil/ipfw/ip_fw_sockopt.c:#include <security/mac/mac_framework.h>
/usr/src/sys/netpfil/ipfw/ip_fw_table.c:#include <security/mac/mac_framework.h>
/usr/src/sys/nfsserver/nfs_srvkrpc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/nfsserver/nfs_srvkrpc.c:		mac_cred_associate_nfsd(nd.nd_cr);
/usr/src/sys/ofed/drivers/infiniband/core/cma.c:	iboe_mac_vlan_to_ll(&route->path_rec->sgid, addr->dev_addr.src_dev_addr, vid);
/usr/src/sys/ofed/drivers/infiniband/core/cma.c:	iboe_mac_vlan_to_ll(&route->path_rec->dgid, addr->dev_addr.dst_dev_addr, vid);
/usr/src/sys/ofed/drivers/infiniband/core/ucma.c:		iboe_mac_vlan_to_ll((union ib_gid *) &resp->ib_route[0].dgid,
/usr/src/sys/ofed/drivers/infiniband/core/ud_header.c:	{ STRUCT_FIELD(eth, dmac_h),
/usr/src/sys/ofed/drivers/infiniband/core/ud_header.c:	{ STRUCT_FIELD(eth, dmac_l),
/usr/src/sys/ofed/drivers/infiniband/core/ud_header.c:	{ STRUCT_FIELD(eth, smac_h),
/usr/src/sys/ofed/drivers/infiniband/core/ud_header.c:	{ STRUCT_FIELD(eth, smac_l),
/usr/src/sys/ofed/drivers/infiniband/hw/mlx4/qp.c:		memcpy(sqp->ud_header.eth.dmac_h, ah->av.eth.mac, 6);
/usr/src/sys/ofed/drivers/infiniband/hw/mlx4/qp.c:		memcpy(sqp->ud_header.eth.smac_h, smac, 6);
/usr/src/sys/ofed/drivers/infiniband/hw/mlx4/qp.c:		if (!memcmp(sqp->ud_header.eth.smac_h, sqp->ud_header.eth.dmac_h, 6))
/usr/src/sys/ofed/drivers/infiniband/ulp/ipoib/ipoib_ib.c:#include <security/mac/mac_framework.h>
/usr/src/sys/ofed/drivers/infiniband/ulp/ipoib/ipoib_main.c:	error = mac_ifnet_check_transmit(ifp, m);
/usr/src/sys/ofed/drivers/infiniband/ulp/ipoib/ipoib_main.c:	mac_ifnet_create_mbuf(ifp, m);
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:u64 mlx4_en_mac_to_u64(u8 *addr)
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:		mcaddr[i++] = mlx4_en_mac_to_u64(
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:				mlx4_en_mac_to_u64(IF_LLADDR(dev)),
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:				&priv->mac_index);
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:	mdev->mac_removed[priv->port] = 0;
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:		goto mac_err;
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:mac_err:
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:	mlx4_unregister_mac(mdev->dev, priv->port, priv->mac_index);
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:	mlx4_unregister_mac(mdev->dev, priv->port, priv->mac_index);
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:	mdev->mac_removed[priv->port] = 1;
/usr/src/sys/ofed/drivers/net/mlx4/en_netdev.c:	priv->mac_index = -1;
/usr/src/sys/ofed/drivers/net/mlx4/en_selftest.c:	mb_set_mac_header(mb, 0);
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:		u32 mac_l, mac_h;
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:		mac = mlx4_en_mac_to_u64(ethh->ether_dhost);
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:			mac_h = (u32) ((mac & 0xffff00000000ULL) >> 16);
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:			mac_l = (u32) (mac & 0xffffffff);
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:			tx_desc->ctrl.srcrb_flags |= cpu_to_be32(mac_h);
/usr/src/sys/ofed/drivers/net/mlx4/en_tx.c:			tx_desc->ctrl.imm = cpu_to_be32(mac_l);
/usr/src/sys/ofed/drivers/net/mlx4/main.c:	mlx4_init_mac_table(dev, &info->mac_table);
/usr/src/sys/ofed/drivers/net/mlx4/port.c:void mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)
/usr/src/sys/ofed/drivers/net/mlx4/port.c:static int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port,
/usr/src/sys/ofed/drivers/net/mlx4/port.c:	struct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;
/usr/src/sys/ofed/drivers/net/mlx4/port.c:	err = mlx4_set_port_mac_table(dev, port, table->entries);
/usr/src/sys/ofed/drivers/net/mlx4/port.c:	struct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;
/usr/src/sys/ofed/drivers/net/mlx4/port.c:	mlx4_set_port_mac_table(dev, port, table->entries);
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_md5;
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_sha1;
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_sha2_256;
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_sha2_384;
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_sha2_512;
/usr/src/sys/opencrypto/cryptodev.c:			thash = &auth_hash_hmac_ripemd_160;
/usr/src/sys/opencrypto/cryptosoft.c:u_int8_t hmac_ipad_buffer[HMAC_MAX_BLOCK_LEN];
/usr/src/sys/opencrypto/cryptosoft.c:u_int8_t hmac_opad_buffer[HMAC_MAX_BLOCK_LEN];
/usr/src/sys/opencrypto/cryptosoft.c:		axf->Update(sw->sw_ictx, hmac_ipad_buffer, axf->blocksize - klen);
/usr/src/sys/opencrypto/cryptosoft.c:		axf->Update(sw->sw_octx, hmac_opad_buffer, axf->blocksize - klen);
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_md5;
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_sha1;
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_sha2_256;
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_sha2_384;
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_sha2_512;
/usr/src/sys/opencrypto/cryptosoft.c:			axf = &auth_hash_hmac_ripemd_160;
/usr/src/sys/opencrypto/cryptosoft.c:	memset(hmac_ipad_buffer, HMAC_IPAD_VAL, HMAC_MAX_BLOCK_LEN);
/usr/src/sys/opencrypto/cryptosoft.c:	memset(hmac_opad_buffer, HMAC_OPAD_VAL, HMAC_MAX_BLOCK_LEN);
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_md5 = {
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_sha1 = {
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_ripemd_160 = {
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_sha2_256 = {
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_sha2_384 = {
/usr/src/sys/opencrypto/xform.c:struct auth_hash auth_hash_hmac_sha2_512 = {
/usr/src/sys/powerpc/powermac/fcu.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/powerpc/powermac/fcu.c:	struct	pmac_fan fan;
/usr/src/sys/powerpc/powermac/fcu.c:			    (int (*)(struct pmac_fan *))(fcu_fan_get_rpm);
/usr/src/sys/powerpc/powermac/fcu.c:			    (int (*)(struct pmac_fan *, int))(fcu_fan_set_rpm);
/usr/src/sys/powerpc/powermac/fcu.c:			    (int (*)(struct pmac_fan *, int))(fcu_fan_set_pwm);
/usr/src/sys/powerpc/powermac/fcu.c:	/* Register fans with pmac_thermal */
/usr/src/sys/powerpc/powermac/fcu.c:		pmac_thermal_fan_register(&sc->sc_fans[i].fan);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static int powermac_probe(platform_t);
/usr/src/sys/powerpc/powermac/platform_powermac.c:void powermac_mem_regions(platform_t, struct mem_region **phys, int *physsz,
/usr/src/sys/powerpc/powermac/platform_powermac.c:static u_long powermac_timebase_freq(platform_t, struct cpuref *cpuref);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static int powermac_smp_first_cpu(platform_t, struct cpuref *cpuref);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static int powermac_smp_next_cpu(platform_t, struct cpuref *cpuref);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static int powermac_smp_get_bsp(platform_t, struct cpuref *cpuref);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static int powermac_smp_start_cpu(platform_t, struct pcpu *cpu);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static void powermac_reset(platform_t);
/usr/src/sys/powerpc/powermac/platform_powermac.c:static platform_method_t powermac_methods[] = {
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_probe, 		powermac_probe),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_mem_regions,	powermac_mem_regions),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_timebase_freq,	powermac_timebase_freq),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_smp_first_cpu,	powermac_smp_first_cpu),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_smp_next_cpu,	powermac_smp_next_cpu),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_smp_get_bsp,	powermac_smp_get_bsp),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_smp_start_cpu,	powermac_smp_start_cpu),
/usr/src/sys/powerpc/powermac/platform_powermac.c:	PLATFORMMETHOD(platform_reset,		powermac_reset),
/usr/src/sys/powerpc/powermac/platform_powermac.c:static platform_def_t powermac_platform = {
/usr/src/sys/powerpc/powermac/platform_powermac.c:	powermac_methods,
/usr/src/sys/powerpc/powermac/platform_powermac.c:PLATFORM_DEF(powermac_platform);
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_probe(platform_t plat)
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_mem_regions(platform_t plat, struct mem_region **phys, int *physsz,
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_timebase_freq(platform_t plat, struct cpuref *cpuref)
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_smp_fill_cpuref(struct cpuref *cpuref, phandle_t cpu)
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_smp_first_cpu(platform_t plat, struct cpuref *cpuref)
/usr/src/sys/powerpc/powermac/platform_powermac.c:	return (powermac_smp_fill_cpuref(cpuref, cpu));
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_smp_next_cpu(platform_t plat, struct cpuref *cpuref)
/usr/src/sys/powerpc/powermac/platform_powermac.c:	return (powermac_smp_fill_cpuref(cpuref, cpu));
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_smp_get_bsp(platform_t plat, struct cpuref *cpuref)
/usr/src/sys/powerpc/powermac/platform_powermac.c:	return (powermac_smp_fill_cpuref(cpuref, bsp));
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_smp_start_cpu(platform_t plat, struct pcpu *pc)
/usr/src/sys/powerpc/powermac/platform_powermac.c:powermac_reset(platform_t platform)
/usr/src/sys/powerpc/powermac/powermac_thermal.c:__FBSDID("$FreeBSD: stable/9/sys/powerpc/powermac/powermac_thermal.c 249132 2013-04-05 08:22:11Z mav $");
/usr/src/sys/powerpc/powermac/powermac_thermal.c:#include "powermac_thermal.h"
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static void pmac_therm_manage_fans(void);
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static struct proc *pmac_them_proc;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static int enable_pmac_thermal = 1;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static struct kproc_desc pmac_therm_kp = {
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	"pmac_thermal",
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	&pmac_them_proc
/usr/src/sys/powerpc/powermac/powermac_thermal.c:SYSINIT(pmac_therm_setup, SI_SUB_KTHREAD_IDLE, SI_ORDER_ANY, kproc_start,
/usr/src/sys/powerpc/powermac/powermac_thermal.c:    &pmac_therm_kp);
/usr/src/sys/powerpc/powermac/powermac_thermal.c:    &enable_pmac_thermal, 1, "Enable automatic fan management");
/usr/src/sys/powerpc/powermac/powermac_thermal.c:struct pmac_fan_le {
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_fan			*fan;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	SLIST_ENTRY(pmac_fan_le)	entries;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:struct pmac_sens_le {
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_therm		*sensor;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	SLIST_ENTRY(pmac_sens_le)	entries;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static SLIST_HEAD(pmac_fans, pmac_fan_le) fans = SLIST_HEAD_INITIALIZER(fans);
/usr/src/sys/powerpc/powermac/powermac_thermal.c:static SLIST_HEAD(pmac_sensors, pmac_sens_le) sensors =
/usr/src/sys/powerpc/powermac/powermac_thermal.c:		pmac_therm_manage_fans();
/usr/src/sys/powerpc/powermac/powermac_thermal.c:		pause("pmac_therm", hz);
/usr/src/sys/powerpc/powermac/powermac_thermal.c:pmac_therm_manage_fans(void)
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_sens_le *sensor;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_fan_le *fan;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	if (!enable_pmac_thermal)
/usr/src/sys/powerpc/powermac/powermac_thermal.c:pmac_thermal_fan_register(struct pmac_fan *fan)
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_fan_le *list_entry;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	list_entry = malloc(sizeof(struct pmac_fan_le), M_PMACTHERM,
/usr/src/sys/powerpc/powermac/powermac_thermal.c:pmac_thermal_sensor_register(struct pmac_therm *sensor)
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	struct pmac_sens_le *list_entry;
/usr/src/sys/powerpc/powermac/powermac_thermal.c:	list_entry = malloc(sizeof(struct pmac_sens_le), M_PMACTHERM,
/usr/src/sys/powerpc/powermac/smu.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/powerpc/powermac/smu.c:	struct pmac_fan fan;
/usr/src/sys/powerpc/powermac/smu.c:	struct pmac_therm therm;
/usr/src/sys/powerpc/powermac/smu.c:	/* Register fans with pmac_thermal */
/usr/src/sys/powerpc/powermac/smu.c:		pmac_thermal_fan_register(&sc->sc_fans[i].fan);
/usr/src/sys/powerpc/powermac/smu.c:			fan->fan.read = (int (*)(struct pmac_fan *))smu_fan_read_rpm;
/usr/src/sys/powerpc/powermac/smu.c:			fan->fan.set = (int (*)(struct pmac_fan *, int))smu_fan_set_rpm;
/usr/src/sys/powerpc/powermac/smu.c:			fan->fan.set = (int (*)(struct pmac_fan *, int))smu_fan_set_pwm;
/usr/src/sys/powerpc/powermac/smu.c:			    (int (*)(struct pmac_therm *))smu_sensor_read;
/usr/src/sys/powerpc/powermac/smu.c:			pmac_thermal_sensor_register(&sens->therm);
/usr/src/sys/powerpc/powermac/smusat.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/powerpc/powermac/smusat.c:	struct pmac_therm therm;
/usr/src/sys/powerpc/powermac/smusat.c:			    (int (*)(struct pmac_therm *))smusat_sensor_read;
/usr/src/sys/powerpc/powermac/smusat.c:			pmac_thermal_sensor_register(&sens->therm);
/usr/src/sys/powerpc/powermac/windtunnel.c:#include <powerpc/powermac/powermac_thermal.h>
/usr/src/sys/powerpc/powermac/windtunnel.c:	struct pmac_fan fan;
/usr/src/sys/powerpc/powermac/windtunnel.c:	sc->fan.set = (int (*)(struct pmac_fan *, int))adm1030_set;
/usr/src/sys/powerpc/powermac/windtunnel.c:	pmac_thermal_fan_register(&sc->fan);
/usr/src/sys/rpc/svc_vc.c:#include <security/mac/mac_framework.h>
/usr/src/sys/rpc/svc_vc.c:	error = mac_socket_check_accept(curthread->td_ucred, head);
/usr/src/sys/security/audit/audit_syscalls.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_system_check_audit(td->td_ucred, rec, uap->length);
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_system_check_auditon(td->td_ucred, uap->cmd);
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_cred_check_setauid(oldcred, id);
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_cred_check_setaudit(oldcred, &ai);
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_cred_check_setaudit_addr(oldcred, &aia);
/usr/src/sys/security/audit/audit_syscalls.c:	error = mac_system_check_auditctl(td->td_ucred, vp);
/usr/src/sys/security/mac/mac_atalk.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_atalk.c 193391 2009-06-03 18:46:28Z rwatson $");
/usr/src/sys/security/mac/mac_atalk.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_atalk.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_atalk.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_atalk.c:mac_netatalk_aarp_send(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_atalk.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_atalk.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_audit.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_audit.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_audit.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_audit.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_audit.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_audit.c:mac_cred_check_setaudit(struct ucred *cred, struct auditinfo *ai)
/usr/src/sys/security/mac/mac_audit.c:mac_cred_check_setaudit_addr(struct ucred *cred, struct auditinfo_addr *aia)
/usr/src/sys/security/mac/mac_audit.c:mac_cred_check_setauid(struct ucred *cred, uid_t auid)
/usr/src/sys/security/mac/mac_audit.c:mac_system_check_audit(struct ucred *cred, void *record, int length)
/usr/src/sys/security/mac/mac_audit.c:mac_system_check_auditctl(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_audit.c:	ASSERT_VOP_LOCKED(vp, "mac_system_check_auditctl");
/usr/src/sys/security/mac/mac_audit.c:mac_system_check_auditon(struct ucred *cred, int cmd)
/usr/src/sys/security/mac/mac_cred.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_cred.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_cred.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_cred.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_cred.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_cred.c:mac_cred_label_alloc(void)
/usr/src/sys/security/mac/mac_cred.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_cred.c:mac_cred_init(struct ucred *cred)
/usr/src/sys/security/mac/mac_cred.c:	if (mac_labeled & MPC_OBJECT_CRED)
/usr/src/sys/security/mac/mac_cred.c:		cred->cr_label = mac_cred_label_alloc();
/usr/src/sys/security/mac/mac_cred.c:mac_cred_label_free(struct label *label)
/usr/src/sys/security/mac/mac_cred.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_cred.c:mac_cred_destroy(struct ucred *cred)
/usr/src/sys/security/mac/mac_cred.c:		mac_cred_label_free(cred->cr_label);
/usr/src/sys/security/mac/mac_cred.c:mac_cred_associate_nfsd(struct ucred *cred)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_create_swapper(struct ucred *cred)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_create_init(struct ucred *cred)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_cred.c:mac_cred_internalize_label(struct label *label, char *string)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_copy(struct ucred *src, struct ucred *dest)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_relabel(struct ucred *cred, struct label *newlabel)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_relabel(struct ucred *cred, struct label *newlabel)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setuid(struct ucred *cred, uid_t uid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_seteuid(struct ucred *cred, uid_t euid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setgid(struct ucred *cred, gid_t gid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setegid(struct ucred *cred, gid_t egid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setgroups(struct ucred *cred, int ngroups, gid_t *gidset)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setreuid(struct ucred *cred, uid_t ruid, uid_t euid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setregid(struct ucred *cred, gid_t rgid, gid_t egid)
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setresuid(struct ucred *cred, uid_t ruid, uid_t euid,
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_setresgid(struct ucred *cred, gid_t rgid, gid_t egid,
/usr/src/sys/security/mac/mac_cred.c:mac_cred_check_visible(struct ucred *cr1, struct ucred *cr2)
/usr/src/sys/security/mac/mac_framework.c: * - The kernel MAC interface, defined in mac_framework.h, and invoked
/usr/src/sys/security/mac/mac_framework.c: * - The MAC policy module interface, defined in mac_policy.h, which is
/usr/src/sys/security/mac/mac_framework.c: * src/sys/security/mac_*.
/usr/src/sys/security/mac/mac_framework.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_framework.c 230167 2012-01-15 21:58:51Z avg $");
/usr/src/sys/security/mac/mac_framework.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_framework.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_framework.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_framework.c:SDT_PROVIDER_DEFINE(mac_framework);
/usr/src/sys/security/mac/mac_framework.c:    "struct mac_policy_conf *mpc");
/usr/src/sys/security/mac/mac_framework.c:    "struct mac_policy_conf *");
/usr/src/sys/security/mac/mac_framework.c:    "struct mac_policy_conf *");
/usr/src/sys/security/mac/mac_framework.c:MODULE_VERSION(kernel_mac_support, MAC_VERSION);
/usr/src/sys/security/mac/mac_framework.c:static unsigned int	mac_version = MAC_VERSION;
/usr/src/sys/security/mac/mac_framework.c:SYSCTL_UINT(_security_mac, OID_AUTO, version, CTLFLAG_RD, &mac_version, 0,
/usr/src/sys/security/mac/mac_framework.c:static unsigned int mac_max_slots = MAC_MAX_SLOTS;
/usr/src/sys/security/mac/mac_framework.c:static unsigned int mac_slot_offsets_free = (1 << MAC_MAX_SLOTS) - 1;
/usr/src/sys/security/mac/mac_framework.c:SYSCTL_UINT(_security_mac, OID_AUTO, max_slots, CTLFLAG_RD, &mac_max_slots,
/usr/src/sys/security/mac/mac_framework.c:static int	mac_late = 0;
/usr/src/sys/security/mac/mac_framework.c:uint64_t	mac_labeled;
/usr/src/sys/security/mac/mac_framework.c:SYSCTL_UQUAD(_security_mac, OID_AUTO, labeled, CTLFLAG_RD, &mac_labeled, 0,
/usr/src/sys/security/mac/mac_framework.c: * MAC policy modules are placed in one of two lists: mac_static_policy_list,
/usr/src/sys/security/mac/mac_framework.c: * mac_policy_list, which holds policies either loaded later in the boot
/usr/src/sys/security/mac/mac_framework.c: * mac_policy_rm, is acquired over policy entry points that will never sleep;
/usr/src/sys/security/mac/mac_framework.c: * the other, mac_policy_sx, is acquire over policy entry points that may
/usr/src/sys/security/mac/mac_framework.c:static struct rmlock mac_policy_rm;	/* Non-sleeping entry points. */
/usr/src/sys/security/mac/mac_framework.c:static struct sx mac_policy_sx;		/* Sleeping entry points. */
/usr/src/sys/security/mac/mac_framework.c:struct mac_policy_list_head mac_policy_list;
/usr/src/sys/security/mac/mac_framework.c:struct mac_policy_list_head mac_static_policy_list;
/usr/src/sys/security/mac/mac_framework.c:u_int mac_policy_count;			/* Registered policy count. */
/usr/src/sys/security/mac/mac_framework.c:static void	mac_policy_xlock(void);
/usr/src/sys/security/mac/mac_framework.c:static void	mac_policy_xlock_assert(void);
/usr/src/sys/security/mac/mac_framework.c:static void	mac_policy_xunlock(void);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_slock_nosleep(struct rm_priotracker *tracker)
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	rm_rlock(&mac_policy_rm, tracker);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_slock_sleep(void)
/usr/src/sys/security/mac/mac_framework.c: 	    "mac_policy_slock_sleep");
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	sx_slock(&mac_policy_sx);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_sunlock_nosleep(struct rm_priotracker *tracker)
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	rm_runlock(&mac_policy_rm, tracker);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_sunlock_sleep(void)
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	sx_sunlock(&mac_policy_sx);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_xlock(void)
/usr/src/sys/security/mac/mac_framework.c: 	    "mac_policy_xlock()");
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	sx_xlock(&mac_policy_sx);
/usr/src/sys/security/mac/mac_framework.c:	rm_wlock(&mac_policy_rm);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_xunlock(void)
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	rm_wunlock(&mac_policy_rm);
/usr/src/sys/security/mac/mac_framework.c:	sx_xunlock(&mac_policy_sx);
/usr/src/sys/security/mac/mac_framework.c:mac_policy_xlock_assert(void)
/usr/src/sys/security/mac/mac_framework.c:	if (!mac_late)
/usr/src/sys/security/mac/mac_framework.c:	/* XXXRW: rm_assert(&mac_policy_rm, RA_WLOCKED); */
/usr/src/sys/security/mac/mac_framework.c:	sx_assert(&mac_policy_sx, SA_XLOCKED);
/usr/src/sys/security/mac/mac_framework.c:mac_init(void)
/usr/src/sys/security/mac/mac_framework.c:	LIST_INIT(&mac_static_policy_list);
/usr/src/sys/security/mac/mac_framework.c:	LIST_INIT(&mac_policy_list);
/usr/src/sys/security/mac/mac_framework.c:	mac_labelzone_init();
/usr/src/sys/security/mac/mac_framework.c:	rm_init_flags(&mac_policy_rm, "mac_policy_rm", RM_NOWITNESS);
/usr/src/sys/security/mac/mac_framework.c:	sx_init_flags(&mac_policy_sx, "mac_policy_sx", SX_NOWITNESS);
/usr/src/sys/security/mac/mac_framework.c: * set the mac_late flag once we've processed modules either linked into the
/usr/src/sys/security/mac/mac_framework.c:mac_late_init(void)
/usr/src/sys/security/mac/mac_framework.c:	mac_late = 1;
/usr/src/sys/security/mac/mac_framework.c:mac_policy_getlabeled(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac/mac_framework.c: * and built mac_labeled, a bitmask representing the union of all objects
/usr/src/sys/security/mac/mac_framework.c:mac_policy_update(void)
/usr/src/sys/security/mac/mac_framework.c:	struct mac_policy_conf *mpc;
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_xlock_assert();
/usr/src/sys/security/mac/mac_framework.c:	mac_labeled = 0;
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_count = 0;
/usr/src/sys/security/mac/mac_framework.c:	LIST_FOREACH(mpc, &mac_static_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_framework.c:		mac_labeled |= mac_policy_getlabeled(mpc);
/usr/src/sys/security/mac/mac_framework.c:		mac_policy_count++;
/usr/src/sys/security/mac/mac_framework.c:	LIST_FOREACH(mpc, &mac_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_framework.c:		mac_labeled |= mac_policy_getlabeled(mpc);
/usr/src/sys/security/mac/mac_framework.c:		mac_policy_count++;
/usr/src/sys/security/mac/mac_framework.c:mac_policy_register(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac/mac_framework.c:	struct mac_policy_conf *tmpc;
/usr/src/sys/security/mac/mac_framework.c:	 * We don't technically need exclusive access while !mac_late, but
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_xlock();
/usr/src/sys/security/mac/mac_framework.c:	static_entry = (!mac_late &&
/usr/src/sys/security/mac/mac_framework.c:		LIST_FOREACH(tmpc, &mac_static_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_framework.c:		LIST_FOREACH(tmpc, &mac_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_framework.c:		slot = ffs(mac_slot_offsets_free);
/usr/src/sys/security/mac/mac_framework.c:		mac_slot_offsets_free &= ~(1 << slot);
/usr/src/sys/security/mac/mac_framework.c:		LIST_INSERT_HEAD(&mac_static_policy_list, mpc, mpc_list);
/usr/src/sys/security/mac/mac_framework.c:		LIST_INSERT_HEAD(&mac_policy_list, mpc, mpc_list);
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_update();
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_xunlock();
/usr/src/sys/security/mac/mac_framework.c:mac_policy_unregister(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_xlock();
/usr/src/sys/security/mac/mac_framework.c:		mac_policy_xunlock();
/usr/src/sys/security/mac/mac_framework.c:		mac_policy_xunlock();
/usr/src/sys/security/mac/mac_framework.c:		mac_policy_xunlock();
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_update();
/usr/src/sys/security/mac/mac_framework.c:	mac_policy_xunlock();
/usr/src/sys/security/mac/mac_framework.c:mac_policy_modevent(module_t mod, int type, void *data)
/usr/src/sys/security/mac/mac_framework.c:	struct mac_policy_conf *mpc;
/usr/src/sys/security/mac/mac_framework.c:	mpc = (struct mac_policy_conf *) data;
/usr/src/sys/security/mac/mac_framework.c:	if (mac_late) {
/usr/src/sys/security/mac/mac_framework.c:		printf("mac_policy_modevent: MAC_STATIC and late\n");
/usr/src/sys/security/mac/mac_framework.c:		    mac_late) {
/usr/src/sys/security/mac/mac_framework.c:			printf("mac_policy_modevent: can't load %s policy "
/usr/src/sys/security/mac/mac_framework.c:		error = mac_policy_register(mpc);
/usr/src/sys/security/mac/mac_framework.c:			error = mac_policy_unregister(mpc);
/usr/src/sys/security/mac/mac_framework.c:mac_error_select(int error1, int error2)
/usr/src/sys/security/mac/mac_framework.c:mac_check_structmac_consistent(struct mac *mac)
/usr/src/sys/security/mac/mac_framework.c:SYSINIT(mac, SI_SUB_MAC, SI_ORDER_FIRST, mac_init, NULL);
/usr/src/sys/security/mac/mac_framework.c:SYSINIT(mac_late, SI_SUB_MAC_LATE, SI_ORDER_FIRST, mac_late_init, NULL);
/usr/src/sys/security/mac/mac_inet.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_inet.c 193391 2009-06-03 18:46:28Z rwatson $");
/usr/src/sys/security/mac/mac_inet.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_inet.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_inet.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_label_alloc(int flag)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_labelzone_alloc(flag);
/usr/src/sys/security/mac/mac_inet.c:		mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_init(struct inpcb *inp, int flag)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_labeled & MPC_OBJECT_INPCB) {
/usr/src/sys/security/mac/mac_inet.c:		inp->inp_label = mac_inpcb_label_alloc(flag);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_label_alloc(int flag)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_labelzone_alloc(flag);
/usr/src/sys/security/mac/mac_inet.c:		mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_init(struct ipq *q, int flag)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_labeled & MPC_OBJECT_IPQ) {
/usr/src/sys/security/mac/mac_inet.c:		q->ipq_label = mac_ipq_label_alloc(flag);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_label_free(struct label *label)
/usr/src/sys/security/mac/mac_inet.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_destroy(struct inpcb *inp)
/usr/src/sys/security/mac/mac_inet.c:		mac_inpcb_label_free(inp->inp_label);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_label_free(struct label *label)
/usr/src/sys/security/mac/mac_inet.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_destroy(struct ipq *q)
/usr/src/sys/security/mac/mac_inet.c:		mac_ipq_label_free(q->ipq_label);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_create(struct socket *so, struct inpcb *inp)
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_reassemble(struct ipq *q, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_fragment(struct mbuf *m, struct mbuf *frag)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:	fraglabel = mac_mbuf_to_label(frag);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_create(struct mbuf *m, struct ipq *q)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_create_mbuf(struct inpcb *inp, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_match(struct mbuf *m, struct ipq *q)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_arp_send(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_icmp_reply(struct mbuf *mrecv, struct mbuf *msend)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mrecvlabel = mac_mbuf_to_label(mrecv);
/usr/src/sys/security/mac/mac_inet.c:	msendlabel = mac_mbuf_to_label(msend);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_icmp_replyinplace(struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_igmp_send(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_tcp_reply(struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_ipq_update(struct mbuf *m, struct ipq *q)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_check_deliver(struct inpcb *inp, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_check_visible(struct ucred *cred, struct inpcb *inp)
/usr/src/sys/security/mac/mac_inet.c:mac_inpcb_sosetlabel(struct socket *so, struct inpcb *inp)
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_firewall_reply(struct mbuf *mrecv, struct mbuf *msend)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mrecvlabel = mac_mbuf_to_label(mrecv);
/usr/src/sys/security/mac/mac_inet.c:	msendlabel = mac_mbuf_to_label(msend);
/usr/src/sys/security/mac/mac_inet.c:mac_netinet_firewall_send(struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet.c:mac_syncache_destroy(struct label **label)
/usr/src/sys/security/mac/mac_inet.c:		mac_labelzone_free(*label);
/usr/src/sys/security/mac/mac_inet.c:mac_syncache_init(struct label **label)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_labeled & MPC_OBJECT_SYNCACHE) {
/usr/src/sys/security/mac/mac_inet.c:		*label = mac_labelzone_alloc(M_NOWAIT);
/usr/src/sys/security/mac/mac_inet.c:			mac_labelzone_free(*label);
/usr/src/sys/security/mac/mac_inet.c:mac_syncache_create(struct label *label, struct inpcb *inp)
/usr/src/sys/security/mac/mac_inet.c:mac_syncache_create_mbuf(struct label *sc_label, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet6.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_inet6.c 193391 2009-06-03 18:46:28Z rwatson $");
/usr/src/sys/security/mac/mac_inet6.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_inet6.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_inet6.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_label_alloc(int flag)
/usr/src/sys/security/mac/mac_inet6.c:	label = mac_labelzone_alloc(flag);
/usr/src/sys/security/mac/mac_inet6.c:		mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_init(struct ip6q *q6, int flag)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_labeled & MPC_OBJECT_IP6Q) {
/usr/src/sys/security/mac/mac_inet6.c:		q6->ip6q_label = mac_ip6q_label_alloc(flag);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_label_free(struct label *label)
/usr/src/sys/security/mac/mac_inet6.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_destroy(struct ip6q *q6)
/usr/src/sys/security/mac/mac_inet6.c:		mac_ip6q_label_free(q6->ip6q_label);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_reassemble(struct ip6q *q6, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet6.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_create(struct mbuf *m, struct ip6q *q6)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet6.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_match(struct mbuf *m, struct ip6q *q6)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet6.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet6.c:mac_ip6q_update(struct mbuf *m, struct ip6q *q6)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet6.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_inet6.c:mac_netinet6_nd6_send(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_inet6.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_inet6.c:	mlabel = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_label.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_label.c 166533 2007-02-06 14:19:25Z rwatson $");
/usr/src/sys/security/mac/mac_label.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_label.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_label.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_label.c:static int	mac_labelzone_ctor(void *mem, int size, void *arg, int flags);
/usr/src/sys/security/mac/mac_label.c:static void	mac_labelzone_dtor(void *mem, int size, void *arg);
/usr/src/sys/security/mac/mac_label.c:mac_labelzone_init(void)
/usr/src/sys/security/mac/mac_label.c:	    mac_labelzone_ctor, mac_labelzone_dtor, NULL, NULL,
/usr/src/sys/security/mac/mac_label.c: * mac_init_label() and mac_destroy_label() are exported so that they can be
/usr/src/sys/security/mac/mac_label.c:mac_init_label(struct label *label)
/usr/src/sys/security/mac/mac_label.c:mac_destroy_label(struct label *label)
/usr/src/sys/security/mac/mac_label.c:mac_labelzone_ctor(void *mem, int size, void *arg, int flags)
/usr/src/sys/security/mac/mac_label.c:	KASSERT(size == sizeof(*label), ("mac_labelzone_ctor: wrong size\n"));
/usr/src/sys/security/mac/mac_label.c:	mac_init_label(label);
/usr/src/sys/security/mac/mac_label.c:mac_labelzone_dtor(void *mem, int size, void *arg)
/usr/src/sys/security/mac/mac_label.c:	KASSERT(size == sizeof(*label), ("mac_labelzone_dtor: wrong size\n"));
/usr/src/sys/security/mac/mac_label.c:	mac_destroy_label(label);
/usr/src/sys/security/mac/mac_label.c:mac_labelzone_alloc(int flags)
/usr/src/sys/security/mac/mac_label.c:mac_labelzone_free(struct label *label)
/usr/src/sys/security/mac/mac_label.c:mac_label_get(struct label *l, int slot)
/usr/src/sys/security/mac/mac_label.c:	KASSERT(l != NULL, ("mac_label_get: NULL label"));
/usr/src/sys/security/mac/mac_label.c:mac_label_set(struct label *l, int slot, intptr_t v)
/usr/src/sys/security/mac/mac_label.c:	KASSERT(l != NULL, ("mac_label_set: NULL label"));
/usr/src/sys/security/mac/mac_net.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_net.c 247629 2013-03-02 15:11:20Z melifaro $");
/usr/src/sys/security/mac/mac_net.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_net.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_net.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_net.c:struct mtx mac_ifnet_mtx;
/usr/src/sys/security/mac/mac_net.c:MTX_SYSINIT(mac_ifnet_mtx, &mac_ifnet_mtx, "mac_ifnet", MTX_DEF);
/usr/src/sys/security/mac/mac_net.c: * Depending on the value of mac_labelmbufs, it's possible that a label will
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_to_label(struct mbuf *m)
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_label_alloc(void)
/usr/src/sys/security/mac/mac_net.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_init(struct bpf_d *d)
/usr/src/sys/security/mac/mac_net.c:	if (mac_labeled & MPC_OBJECT_BPFDESC)
/usr/src/sys/security/mac/mac_net.c:		d->bd_label = mac_bpfdesc_label_alloc();
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_label_alloc(void)
/usr/src/sys/security/mac/mac_net.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_init(struct ifnet *ifp)
/usr/src/sys/security/mac/mac_net.c:	if (mac_labeled & MPC_OBJECT_IFNET)
/usr/src/sys/security/mac/mac_net.c:		ifp->if_label = mac_ifnet_label_alloc();
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_tag_init(struct m_tag *tag, int flag)
/usr/src/sys/security/mac/mac_net.c:	mac_init_label(label);
/usr/src/sys/security/mac/mac_net.c:		mac_destroy_label(label);
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_init(struct mbuf *m, int flag)
/usr/src/sys/security/mac/mac_net.c:	if (mac_labeled & MPC_OBJECT_MBUF) {
/usr/src/sys/security/mac/mac_net.c:		error = mac_mbuf_tag_init(tag, flag);
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_label_free(struct label *label)
/usr/src/sys/security/mac/mac_net.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_destroy(struct bpf_d *d)
/usr/src/sys/security/mac/mac_net.c:		mac_bpfdesc_label_free(d->bd_label);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_label_free(struct label *label)
/usr/src/sys/security/mac/mac_net.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_destroy(struct ifnet *ifp)
/usr/src/sys/security/mac/mac_net.c:		mac_ifnet_label_free(ifp->if_label);
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_tag_destroy(struct m_tag *tag)
/usr/src/sys/security/mac/mac_net.c:	mac_destroy_label(label);
/usr/src/sys/security/mac/mac_net.c: * mac_mbuf_tag_copy is called when an mbuf header is duplicated, in which
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_tag_copy(struct m_tag *src, struct m_tag *dest)
/usr/src/sys/security/mac/mac_net.c:	 * mac_mbuf_tag_init() is called on the target tag in m_tag_copy(),
/usr/src/sys/security/mac/mac_net.c:mac_mbuf_copy(struct mbuf *m_from, struct mbuf *m_to)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:	src_label = mac_mbuf_to_label(m_from);
/usr/src/sys/security/mac/mac_net.c:	dest_label = mac_mbuf_to_label(m_to);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_copy_label(struct label *src, struct label *dest)
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_internalize_label(struct label *label, char *string)
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_create(struct ifnet *ifp)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_create(struct ucred *cred, struct bpf_d *d)
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_create_mbuf(struct bpf_d *d, struct mbuf *m)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_create_mbuf(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_net.c:mac_bpfdesc_check_receive(struct bpf_d *d, struct ifnet *ifp)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_check_transmit(struct ifnet *ifp, struct mbuf *m)
/usr/src/sys/security/mac/mac_net.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_net.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_ioctl_get(struct ucred *cred, struct ifreq *ifr,
/usr/src/sys/security/mac/mac_net.c:	if (!(mac_labeled & MPC_OBJECT_IFNET))
/usr/src/sys/security/mac/mac_net.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_net.c:	intlabel = mac_ifnet_label_alloc();
/usr/src/sys/security/mac/mac_net.c:	mac_ifnet_copy_label(ifp->if_label, intlabel);
/usr/src/sys/security/mac/mac_net.c:	error = mac_ifnet_externalize_label(intlabel, elements, buffer,
/usr/src/sys/security/mac/mac_net.c:	mac_ifnet_label_free(intlabel);
/usr/src/sys/security/mac/mac_net.c:mac_ifnet_ioctl_set(struct ucred *cred, struct ifreq *ifr, struct ifnet *ifp)
/usr/src/sys/security/mac/mac_net.c:	if (!(mac_labeled & MPC_OBJECT_IFNET))
/usr/src/sys/security/mac/mac_net.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_net.c:	intlabel = mac_ifnet_label_alloc();
/usr/src/sys/security/mac/mac_net.c:	error = mac_ifnet_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_net.c:		mac_ifnet_label_free(intlabel);
/usr/src/sys/security/mac/mac_net.c:		mac_ifnet_label_free(intlabel);
/usr/src/sys/security/mac/mac_net.c:		mac_ifnet_label_free(intlabel);
/usr/src/sys/security/mac/mac_net.c:	mac_ifnet_label_free(intlabel);
/usr/src/sys/security/mac/mac_pipe.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_pipe.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_pipe.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_pipe.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_pipe.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_label_alloc(void)
/usr/src/sys/security/mac/mac_pipe.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_init(struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:	if (mac_labeled & MPC_OBJECT_PIPE)
/usr/src/sys/security/mac/mac_pipe.c:		pp->pp_label = mac_pipe_label_alloc();
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_label_free(struct label *label)
/usr/src/sys/security/mac/mac_pipe.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_destroy(struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:		mac_pipe_label_free(pp->pp_label);
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_copy_label(struct label *src, struct label *dest)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_internalize_label(struct label *label, char *string)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_create(struct ucred *cred, struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_relabel(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_ioctl(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_poll(struct ucred *cred, struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_read(struct ucred *cred, struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_relabel(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_stat(struct ucred *cred, struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_check_write(struct ucred *cred, struct pipepair *pp)
/usr/src/sys/security/mac/mac_pipe.c:mac_pipe_label_set(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac/mac_pipe.c:	error = mac_pipe_check_relabel(cred, pp, label);
/usr/src/sys/security/mac/mac_pipe.c:	mac_pipe_relabel(cred, pp, label);
/usr/src/sys/security/mac/mac_posix_sem.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_posix_sem.c 224914 2011-08-16 20:07:47Z kib $");
/usr/src/sys/security/mac/mac_posix_sem.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_posix_sem.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_posix_sem.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_label_alloc(void)
/usr/src/sys/security/mac/mac_posix_sem.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_init(struct ksem *ks)
/usr/src/sys/security/mac/mac_posix_sem.c:	if (mac_labeled & MPC_OBJECT_POSIXSEM)
/usr/src/sys/security/mac/mac_posix_sem.c:		ks->ks_label = mac_posixsem_label_alloc();
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_label_free(struct label *label)
/usr/src/sys/security/mac/mac_posix_sem.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_destroy(struct ksem *ks)
/usr/src/sys/security/mac/mac_posix_sem.c:		mac_posixsem_label_free(ks->ks_label);
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_create(struct ucred *cred, struct ksem *ks)
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_open(struct ucred *cred, struct ksem *ks)
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_getvalue(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_post(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_stat(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_unlink(struct ucred *cred, struct ksem *ks)
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_wait(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_setmode(struct ucred *cred, struct ksem *ks, mode_t mode)
/usr/src/sys/security/mac/mac_posix_sem.c:mac_posixsem_check_setowner(struct ucred *cred, struct ksem *ks, uid_t uid,
/usr/src/sys/security/mac/mac_posix_shm.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_posix_shm.c 225344 2011-09-02 17:40:39Z rwatson $");
/usr/src/sys/security/mac/mac_posix_shm.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_posix_shm.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_posix_shm.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_label_alloc(void)
/usr/src/sys/security/mac/mac_posix_shm.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_init(struct shmfd *shmfd)
/usr/src/sys/security/mac/mac_posix_shm.c:	if (mac_labeled & MPC_OBJECT_POSIXSHM)
/usr/src/sys/security/mac/mac_posix_shm.c:		shmfd->shm_label = mac_posixshm_label_alloc();
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_label_free(struct label *label)
/usr/src/sys/security/mac/mac_posix_shm.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_destroy(struct shmfd *shmfd)
/usr/src/sys/security/mac/mac_posix_shm.c:		mac_posixshm_label_free(shmfd->shm_label);
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_create(struct ucred *cred, struct shmfd *shmfd)
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_create(struct ucred *cred, const char *path)
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_mmap(struct ucred *cred, struct shmfd *shmfd, int prot,
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_open(struct ucred *cred, struct shmfd *shmfd,
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_stat(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_truncate(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_unlink(struct ucred *cred, struct shmfd *shmfd)
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_setmode(struct ucred *cred, struct shmfd *shmfd, mode_t mode)
/usr/src/sys/security/mac/mac_posix_shm.c:mac_posixshm_check_setowner(struct ucred *cred, struct shmfd *shmfd, uid_t uid,
/usr/src/sys/security/mac/mac_priv.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_priv.c 235404 2012-05-13 17:01:32Z avg $");
/usr/src/sys/security/mac/mac_priv.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_priv.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_priv.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_priv.c:mac_priv_check(struct ucred *cred, int priv)
/usr/src/sys/security/mac/mac_priv.c:mac_priv_grant(struct ucred *cred, int priv)
/usr/src/sys/security/mac/mac_process.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_process.c 218345 2011-02-05 21:21:27Z alc $");
/usr/src/sys/security/mac/mac_process.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_process.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_process.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_process.c:static int	mac_mmap_revocation = 1;
/usr/src/sys/security/mac/mac_process.c:    &mac_mmap_revocation, 0, "Revoke mmap access to files on subject "
/usr/src/sys/security/mac/mac_process.c:static int	mac_mmap_revocation_via_cow = 0;
/usr/src/sys/security/mac/mac_process.c:    &mac_mmap_revocation_via_cow, 0, "Revoke mmap access to files via "
/usr/src/sys/security/mac/mac_process.c:static void	mac_proc_vm_revoke_recurse(struct thread *td,
/usr/src/sys/security/mac/mac_process.c:mac_proc_label_alloc(void)
/usr/src/sys/security/mac/mac_process.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_process.c:mac_proc_init(struct proc *p)
/usr/src/sys/security/mac/mac_process.c:	if (mac_labeled & MPC_OBJECT_PROC)
/usr/src/sys/security/mac/mac_process.c:		p->p_label = mac_proc_label_alloc();
/usr/src/sys/security/mac/mac_process.c:mac_proc_label_free(struct label *label)
/usr/src/sys/security/mac/mac_process.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_process.c:mac_proc_destroy(struct proc *p)
/usr/src/sys/security/mac/mac_process.c:		mac_proc_label_free(p->p_label);
/usr/src/sys/security/mac/mac_process.c:mac_thread_userret(struct thread *td)
/usr/src/sys/security/mac/mac_process.c:mac_execve_enter(struct image_params *imgp, struct mac *mac_p)
/usr/src/sys/security/mac/mac_process.c:	if (mac_p == NULL)
/usr/src/sys/security/mac/mac_process.c:	if (!(mac_labeled & MPC_OBJECT_CRED))
/usr/src/sys/security/mac/mac_process.c:	error = copyin(mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_process.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_process.c:	label = mac_cred_label_alloc();
/usr/src/sys/security/mac/mac_process.c:	error = mac_cred_internalize_label(label, buffer);
/usr/src/sys/security/mac/mac_process.c:		mac_cred_label_free(label);
/usr/src/sys/security/mac/mac_process.c:mac_execve_exit(struct image_params *imgp)
/usr/src/sys/security/mac/mac_process.c:		mac_cred_label_free(imgp->execlabel);
/usr/src/sys/security/mac/mac_process.c:mac_execve_interpreter_enter(struct vnode *interpvp,
/usr/src/sys/security/mac/mac_process.c:	if (mac_labeled & MPC_OBJECT_VNODE) {
/usr/src/sys/security/mac/mac_process.c:		*interpvplabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_process.c:		mac_vnode_copy_label(interpvp->v_label, *interpvplabel);
/usr/src/sys/security/mac/mac_process.c:mac_execve_interpreter_exit(struct label *interpvplabel)
/usr/src/sys/security/mac/mac_process.c:		mac_vnode_label_free(interpvplabel);
/usr/src/sys/security/mac/mac_process.c:mac_proc_vm_revoke(struct thread *td)
/usr/src/sys/security/mac/mac_process.c:	mac_proc_vm_revoke_recurse(td, cred,
/usr/src/sys/security/mac/mac_process.c:mac_proc_vm_revoke_recurse(struct thread *td, struct ucred *cred,
/usr/src/sys/security/mac/mac_process.c:	if (!mac_mmap_revocation)
/usr/src/sys/security/mac/mac_process.c:			mac_proc_vm_revoke_recurse(td, cred,
/usr/src/sys/security/mac/mac_process.c:		mac_vnode_check_mmap_downgrade(cred, vp, &result);
/usr/src/sys/security/mac/mac_process.c:				if (!mac_mmap_revocation_via_cow) {
/usr/src/sys/security/mac/mac_process.c:mac_proc_check_debug(struct ucred *cred, struct proc *p)
/usr/src/sys/security/mac/mac_process.c:mac_proc_check_sched(struct ucred *cred, struct proc *p)
/usr/src/sys/security/mac/mac_process.c:mac_proc_check_signal(struct ucred *cred, struct proc *p, int signum)
/usr/src/sys/security/mac/mac_process.c:mac_proc_check_wait(struct ucred *cred, struct proc *p)
/usr/src/sys/security/mac/mac_socket.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_socket.c 193391 2009-06-03 18:46:28Z rwatson $");
/usr/src/sys/security/mac/mac_socket.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_socket.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_socket.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_socket.c:mac_socket_label_alloc(int flag)
/usr/src/sys/security/mac/mac_socket.c:	label = mac_labelzone_alloc(flag);
/usr/src/sys/security/mac/mac_socket.c:		mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_socket.c:mac_socketpeer_label_alloc(int flag)
/usr/src/sys/security/mac/mac_socket.c:	label = mac_labelzone_alloc(flag);
/usr/src/sys/security/mac/mac_socket.c:		mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_init(struct socket *so, int flag)
/usr/src/sys/security/mac/mac_socket.c:	if (mac_labeled & MPC_OBJECT_SOCKET) {
/usr/src/sys/security/mac/mac_socket.c:		so->so_label = mac_socket_label_alloc(flag);
/usr/src/sys/security/mac/mac_socket.c:		so->so_peerlabel = mac_socketpeer_label_alloc(flag);
/usr/src/sys/security/mac/mac_socket.c:			mac_socket_label_free(so->so_label);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_label_free(struct label *label)
/usr/src/sys/security/mac/mac_socket.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_socket.c:mac_socketpeer_label_free(struct label *label)
/usr/src/sys/security/mac/mac_socket.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_destroy(struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:		mac_socket_label_free(so->so_label);
/usr/src/sys/security/mac/mac_socket.c:		mac_socketpeer_label_free(so->so_peerlabel);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_copy_label(struct label *src, struct label *dest)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_socket.c:mac_socketpeer_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_socket.c:mac_socket_internalize_label(struct label *label, char *string)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_create(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_newconn(struct socket *oldso, struct socket *newso)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_relabel(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:mac_socketpeer_set_from_mbuf(struct mbuf *m, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_socket.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_socket.c:mac_socketpeer_set_from_socket(struct socket *oldso, struct socket *newso)
/usr/src/sys/security/mac/mac_socket.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_create_mbuf(struct socket *so, struct mbuf *m)
/usr/src/sys/security/mac/mac_socket.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_socket.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_accept(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_bind(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_connect(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_create(struct ucred *cred, int domain, int type, int proto)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_deliver(struct socket *so, struct mbuf *m)
/usr/src/sys/security/mac/mac_socket.c:	if (mac_policy_count == 0)
/usr/src/sys/security/mac/mac_socket.c:	label = mac_mbuf_to_label(m);
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_listen(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_poll(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_receive(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_relabel(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_send(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_stat(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_check_visible(struct ucred *cred, struct socket *so)
/usr/src/sys/security/mac/mac_socket.c:mac_socket_label_set(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:	error = mac_socket_check_relabel(cred, so, label);
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_relabel(cred, so, label);
/usr/src/sys/security/mac/mac_socket.c:mac_setsockopt_label(struct ucred *cred, struct socket *so, struct mac *mac)
/usr/src/sys/security/mac/mac_socket.c:	if (!(mac_labeled & MPC_OBJECT_SOCKET))
/usr/src/sys/security/mac/mac_socket.c:	error = mac_check_structmac_consistent(mac);
/usr/src/sys/security/mac/mac_socket.c:	intlabel = mac_socket_label_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_socket.c:	error = mac_socket_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_socket.c:	error = mac_socket_label_set(cred, so, intlabel);
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_label_free(intlabel);
/usr/src/sys/security/mac/mac_socket.c:mac_getsockopt_label(struct ucred *cred, struct socket *so, struct mac *mac)
/usr/src/sys/security/mac/mac_socket.c:	if (!(mac_labeled & MPC_OBJECT_SOCKET))
/usr/src/sys/security/mac/mac_socket.c:	error = mac_check_structmac_consistent(mac);
/usr/src/sys/security/mac/mac_socket.c:	intlabel = mac_socket_label_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_copy_label(so->so_label, intlabel);
/usr/src/sys/security/mac/mac_socket.c:	error = mac_socket_externalize_label(intlabel, elements, buffer,
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_label_free(intlabel);
/usr/src/sys/security/mac/mac_socket.c:mac_getsockopt_peerlabel(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac/mac_socket.c:	if (!(mac_labeled & MPC_OBJECT_SOCKET))
/usr/src/sys/security/mac/mac_socket.c:	error = mac_check_structmac_consistent(mac);
/usr/src/sys/security/mac/mac_socket.c:	intlabel = mac_socket_label_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_copy_label(so->so_peerlabel, intlabel);
/usr/src/sys/security/mac/mac_socket.c:	error = mac_socketpeer_externalize_label(intlabel, elements, buffer,
/usr/src/sys/security/mac/mac_socket.c:	mac_socket_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_syscalls.c 238285 2012-07-09 08:42:54Z rwatson $");
/usr/src/sys/security/mac/mac_syscalls.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_syscalls.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_syscalls.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_pid(struct thread *td, struct __mac_get_pid_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_cred_externalize_label(tcred->cr_label, elements,
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_proc(struct thread *td, struct __mac_get_proc_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_cred_externalize_label(td->td_ucred->cr_label,
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_proc(struct thread *td, struct __mac_set_proc_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	if (!(mac_labeled & MPC_OBJECT_CRED))
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	intlabel = mac_cred_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_cred_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_cred_check_relabel(oldcred, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:	mac_cred_relabel(newcred, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:	mac_proc_vm_revoke(td);
/usr/src/sys/security/mac/mac_syscalls.c:	mac_cred_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_fd(struct thread *td, struct __mac_get_fd_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_VNODE)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:		mac_vnode_copy_label(vp->v_label, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_vnode_externalize_label(intlabel, elements,
/usr/src/sys/security/mac/mac_syscalls.c:		mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_PIPE)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_pipe_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:		mac_pipe_copy_label(pipe->pipe_pair->pp_label, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_pipe_externalize_label(intlabel, elements,
/usr/src/sys/security/mac/mac_syscalls.c:		mac_pipe_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_SOCKET)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_socket_label_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_syscalls.c:		mac_socket_copy_label(so->so_label, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_socket_externalize_label(intlabel, elements,
/usr/src/sys/security/mac/mac_syscalls.c:		mac_socket_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_file(struct thread *td, struct __mac_get_file_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	if (!(mac_labeled & MPC_OBJECT_VNODE))
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_copy_label(nd.ni_vp->v_label, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_vnode_externalize_label(intlabel, elements, buffer,
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_link(struct thread *td, struct __mac_get_link_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	if (!(mac_labeled & MPC_OBJECT_VNODE))
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_copy_label(nd.ni_vp->v_label, intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_vnode_externalize_label(intlabel, elements, buffer,
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_fd(struct thread *td, struct __mac_set_fd_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_VNODE)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_vnode_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:			mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:			mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_PIPE)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_pipe_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_pipe_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:			error = mac_pipe_label_set(td->td_ucred,
/usr/src/sys/security/mac/mac_syscalls.c:		mac_pipe_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:		if (!(mac_labeled & MPC_OBJECT_SOCKET)) {
/usr/src/sys/security/mac/mac_syscalls.c:		intlabel = mac_socket_label_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_syscalls.c:		error = mac_socket_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:			error = mac_socket_label_set(td->td_ucred, so,
/usr/src/sys/security/mac/mac_syscalls.c:		mac_socket_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_file(struct thread *td, struct __mac_set_file_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	if (!(mac_labeled & MPC_OBJECT_VNODE))
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_vnode_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_link(struct thread *td, struct __mac_set_link_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	if (!(mac_labeled & MPC_OBJECT_VNODE))
/usr/src/sys/security/mac/mac_syscalls.c:	error = copyin(uap->mac_p, &mac, sizeof(mac));
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_check_structmac_consistent(&mac);
/usr/src/sys/security/mac/mac_syscalls.c:	intlabel = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_syscalls.c:	error = mac_vnode_internalize_label(intlabel, buffer);
/usr/src/sys/security/mac/mac_syscalls.c:	mac_vnode_label_free(intlabel);
/usr/src/sys/security/mac/mac_syscalls.c:sys_mac_syscall(struct thread *td, struct mac_syscall_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:	struct mac_policy_conf *mpc;
/usr/src/sys/security/mac/mac_syscalls.c:	LIST_FOREACH(mpc, &mac_static_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_syscalls.c:	if (!LIST_EMPTY(&mac_policy_list)) {
/usr/src/sys/security/mac/mac_syscalls.c:		mac_policy_slock_sleep();
/usr/src/sys/security/mac/mac_syscalls.c:		LIST_FOREACH(mpc, &mac_policy_list, mpc_list) {
/usr/src/sys/security/mac/mac_syscalls.c:		mac_policy_sunlock_sleep();
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_pid(struct thread *td, struct __mac_get_pid_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_proc(struct thread *td, struct __mac_get_proc_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_proc(struct thread *td, struct __mac_set_proc_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_fd(struct thread *td, struct __mac_get_fd_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_file(struct thread *td, struct __mac_get_file_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_get_link(struct thread *td, struct __mac_get_link_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_fd(struct thread *td, struct __mac_set_fd_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_file(struct thread *td, struct __mac_set_file_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys___mac_set_link(struct thread *td, struct __mac_set_link_args *uap)
/usr/src/sys/security/mac/mac_syscalls.c:sys_mac_syscall(struct thread *td, struct mac_syscall_args *uap)
/usr/src/sys/security/mac/mac_system.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_system.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_system.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_system.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_system.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_system.c:mac_kenv_check_dump(struct ucred *cred)
/usr/src/sys/security/mac/mac_system.c:mac_kenv_check_get(struct ucred *cred, char *name)
/usr/src/sys/security/mac/mac_system.c:mac_kenv_check_set(struct ucred *cred, char *name, char *value)
/usr/src/sys/security/mac/mac_system.c:mac_kenv_check_unset(struct ucred *cred, char *name)
/usr/src/sys/security/mac/mac_system.c:mac_kld_check_load(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_system.c:	ASSERT_VOP_LOCKED(vp, "mac_kld_check_load");
/usr/src/sys/security/mac/mac_system.c:mac_kld_check_stat(struct ucred *cred)
/usr/src/sys/security/mac/mac_system.c:mac_system_check_acct(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_system.c:		ASSERT_VOP_LOCKED(vp, "mac_system_check_acct");
/usr/src/sys/security/mac/mac_system.c:mac_system_check_reboot(struct ucred *cred, int howto)
/usr/src/sys/security/mac/mac_system.c:mac_system_check_swapon(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_system.c:	ASSERT_VOP_LOCKED(vp, "mac_system_check_swapon");
/usr/src/sys/security/mac/mac_system.c:mac_system_check_swapoff(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_system.c:	ASSERT_VOP_LOCKED(vp, "mac_system_check_swapoff");
/usr/src/sys/security/mac/mac_system.c:mac_system_check_sysctl(struct ucred *cred, struct sysctl_oid *oidp,
/usr/src/sys/security/mac/mac_sysv_msg.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_sysv_msg.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_sysv_msg.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_sysv_msg.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_sysv_msg.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysv_msgmsg_label_alloc(void)
/usr/src/sys/security/mac/mac_sysv_msg.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsg_init(struct msg *msgptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:	if (mac_labeled & MPC_OBJECT_SYSVMSG)
/usr/src/sys/security/mac/mac_sysv_msg.c:		msgptr->label = mac_sysv_msgmsg_label_alloc();
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysv_msgqueue_label_alloc(void)
/usr/src/sys/security/mac/mac_sysv_msg.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_init(struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:	if (mac_labeled & MPC_OBJECT_SYSVMSQ)
/usr/src/sys/security/mac/mac_sysv_msg.c:		msqkptr->label = mac_sysv_msgqueue_label_alloc();
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysv_msgmsg_label_free(struct label *label)
/usr/src/sys/security/mac/mac_sysv_msg.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsg_destroy(struct msg *msgptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:		mac_sysv_msgmsg_label_free(msgptr->label);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysv_msgqueue_label_free(struct label *label)
/usr/src/sys/security/mac/mac_sysv_msg.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_destroy(struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:		mac_sysv_msgqueue_label_free(msqkptr->label);
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsg_create(struct ucred *cred, struct msqid_kernel *msqkptr,
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_create(struct ucred *cred, struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsg_cleanup(struct msg *msgptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_cleanup(struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msgmsq(struct ucred *cred, struct msg *msgptr,
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msgrcv(struct ucred *cred, struct msg *msgptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msgrmid(struct ucred *cred, struct msg *msgptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msqget(struct ucred *cred, struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msqsnd(struct ucred *cred, struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msqrcv(struct ucred *cred, struct msqid_kernel *msqkptr)
/usr/src/sys/security/mac/mac_sysv_msg.c:mac_sysvmsq_check_msqctl(struct ucred *cred, struct msqid_kernel *msqkptr,
/usr/src/sys/security/mac/mac_sysv_sem.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_sysv_sem.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_sysv_sem.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_sysv_sem.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_sysv_sem.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysv_sem_label_alloc(void)
/usr/src/sys/security/mac/mac_sysv_sem.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_init(struct semid_kernel *semakptr)
/usr/src/sys/security/mac/mac_sysv_sem.c:	if (mac_labeled & MPC_OBJECT_SYSVSEM)
/usr/src/sys/security/mac/mac_sysv_sem.c:		semakptr->label = mac_sysv_sem_label_alloc();
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysv_sem_label_free(struct label *label)
/usr/src/sys/security/mac/mac_sysv_sem.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_destroy(struct semid_kernel *semakptr)
/usr/src/sys/security/mac/mac_sysv_sem.c:		mac_sysv_sem_label_free(semakptr->label);
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_create(struct ucred *cred, struct semid_kernel *semakptr)
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_cleanup(struct semid_kernel *semakptr)
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_check_semctl(struct ucred *cred, struct semid_kernel *semakptr,
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_check_semget(struct ucred *cred, struct semid_kernel *semakptr)
/usr/src/sys/security/mac/mac_sysv_sem.c:mac_sysvsem_check_semop(struct ucred *cred, struct semid_kernel *semakptr,
/usr/src/sys/security/mac/mac_vfs.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_vfs.c 214249 2010-10-23 16:59:39Z rwatson $");
/usr/src/sys/security/mac/mac_vfs.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_vfs.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_vfs.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_vfs.c:static int	mac_vnode_setlabel_extattr(struct ucred *cred,
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_label_alloc(void)
/usr/src/sys/security/mac/mac_vfs.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_init(struct devfs_dirent *de)
/usr/src/sys/security/mac/mac_vfs.c:	if (mac_labeled & MPC_OBJECT_DEVFS)
/usr/src/sys/security/mac/mac_vfs.c:		de->de_label = mac_devfs_label_alloc();
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_label_alloc(void)
/usr/src/sys/security/mac/mac_vfs.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_init(struct mount *mp)
/usr/src/sys/security/mac/mac_vfs.c:	if (mac_labeled & MPC_OBJECT_MOUNT)
/usr/src/sys/security/mac/mac_vfs.c:		mp->mnt_label = mac_mount_label_alloc();
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_label_alloc(void)
/usr/src/sys/security/mac/mac_vfs.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_init(struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:	if (mac_labeled & MPC_OBJECT_VNODE)
/usr/src/sys/security/mac/mac_vfs.c:		vp->v_label = mac_vnode_label_alloc();
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_label_free(struct label *label)
/usr/src/sys/security/mac/mac_vfs.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_destroy(struct devfs_dirent *de)
/usr/src/sys/security/mac/mac_vfs.c:		mac_devfs_label_free(de->de_label);
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_label_free(struct label *label)
/usr/src/sys/security/mac/mac_vfs.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_destroy(struct mount *mp)
/usr/src/sys/security/mac/mac_vfs.c:		mac_mount_label_free(mp->mnt_label);
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_label_free(struct label *label)
/usr/src/sys/security/mac/mac_vfs.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_destroy(struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:		mac_vnode_label_free(vp->v_label);
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_copy_label(struct label *src, struct label *dest)
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_externalize_label(struct label *label, char *elements,
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_internalize_label(struct label *label, char *string)
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_update(struct mount *mp, struct devfs_dirent *de, struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_vnode_associate(struct mount *mp, struct devfs_dirent *de,
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_associate_extattr(struct mount *mp, struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_associate_extattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_associate_singlelabel(struct mount *mp, struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_create_extattr(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_create_extattr");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_create_extattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_setlabel_extattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_setlabel_extattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_execve_transition(struct ucred *old, struct ucred *new,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_execve_transition");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_execve_will_transition(struct ucred *old, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_execve_will_transition");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_access(struct ucred *cred, struct vnode *vp, accmode_t accmode)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_access");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_chdir(struct ucred *cred, struct vnode *dvp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_chdir");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_chroot(struct ucred *cred, struct vnode *dvp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_chroot");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_create(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_create");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_post_create(struct ucred *cred, struct vnode *dvp, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_post_create");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_post_create");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_deleteacl(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_deleteacl");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_deleteextattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_deleteextattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_exec(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_exec");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_getacl(struct ucred *cred, struct vnode *vp, acl_type_t type)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_getacl");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_getextattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_getextattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_link(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_link");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_link");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_listextattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_listextattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_lookup(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_lookup");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_post_lookup(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_post_lookup");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_post_lookup");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_mmap(struct ucred *cred, struct vnode *vp, int prot,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_mmap");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_mmap_downgrade(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_mmap_downgrade");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_mprotect(struct ucred *cred, struct vnode *vp, int prot)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_mprotect");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_open(struct ucred *cred, struct vnode *vp, accmode_t accmode)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_open");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_poll(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_poll");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_read(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_read");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_readdir(struct ucred *cred, struct vnode *dvp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_readdir");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_readlink(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_readlink");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_relabel(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_relabel");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_rename_from(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_rename_from");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_rename_from");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_rename_to(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_rename_to");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_rename_to");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_revoke(struct ucred *cred, struct vnode *vp)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_revoke");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setacl(struct ucred *cred, struct vnode *vp, acl_type_t type,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setacl");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setextattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setextattr");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setflags(struct ucred *cred, struct vnode *vp, u_long flags)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setflags");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setmode(struct ucred *cred, struct vnode *vp, mode_t mode)
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setmode");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setowner(struct ucred *cred, struct vnode *vp, uid_t uid,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setowner");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_setutimes(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_setutimes");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_stat(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_stat");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_unlink(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(dvp, "mac_vnode_check_unlink");
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_unlink");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_check_write(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac/mac_vfs.c:	ASSERT_VOP_LOCKED(vp, "mac_vnode_check_write");
/usr/src/sys/security/mac/mac_vfs.c:mac_vnode_relabel(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_create(struct ucred *cred, struct mount *mp)
/usr/src/sys/security/mac/mac_vfs.c:mac_mount_check_stat(struct ucred *cred, struct mount *mount)
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_create_device(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_create_symlink(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac/mac_vfs.c:mac_devfs_create_directory(struct mount *mp, char *dirname, int dirnamelen,
/usr/src/sys/security/mac/mac_vfs.c:	error = mac_vnode_setlabel_extattr(ap->a_cred, vp, intlabel);
/usr/src/sys/security/mac/mac_vfs.c:	mac_vnode_relabel(ap->a_cred, vp, intlabel);
/usr/src/sys/security/mac/mac_vfs.c:	error = mac_vnode_check_relabel(cred, vp, intlabel);
/usr/src/sys/security/mac/mac_sysv_shm.c:__FBSDID("$FreeBSD: stable/9/sys/security/mac/mac_sysv_shm.c 191731 2009-05-01 21:05:40Z rwatson $");
/usr/src/sys/security/mac/mac_sysv_shm.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac/mac_sysv_shm.c:#include <security/mac/mac_internal.h>
/usr/src/sys/security/mac/mac_sysv_shm.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysv_shm_label_alloc(void)
/usr/src/sys/security/mac/mac_sysv_shm.c:	label = mac_labelzone_alloc(M_WAITOK);
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_init(struct shmid_kernel *shmsegptr)
/usr/src/sys/security/mac/mac_sysv_shm.c:	if (mac_labeled & MPC_OBJECT_SYSVSHM)
/usr/src/sys/security/mac/mac_sysv_shm.c:		shmsegptr->label = mac_sysv_shm_label_alloc();
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysv_shm_label_free(struct label *label)
/usr/src/sys/security/mac/mac_sysv_shm.c:	mac_labelzone_free(label);
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_destroy(struct shmid_kernel *shmsegptr)
/usr/src/sys/security/mac/mac_sysv_shm.c:		mac_sysv_shm_label_free(shmsegptr->label);
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_create(struct ucred *cred, struct shmid_kernel *shmsegptr)
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_cleanup(struct shmid_kernel *shmsegptr)
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_check_shmat(struct ucred *cred, struct shmid_kernel *shmsegptr,
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_check_shmctl(struct ucred *cred, struct shmid_kernel *shmsegptr,
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_check_shmdt(struct ucred *cred, struct shmid_kernel *shmsegptr)
/usr/src/sys/security/mac/mac_sysv_shm.c:mac_sysvshm_check_shmget(struct ucred *cred, struct shmid_kernel *shmsegptr,
/usr/src/sys/security/mac_biba/mac_biba.c: * $FreeBSD: stable/9/sys/security/mac_biba/mac_biba.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_biba/mac_biba.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_biba/mac_biba.c:#include <security/mac_biba/mac_biba.h>
/usr/src/sys/security/mac_biba/mac_biba.c:    "TrustedBSD mac_biba policy controls");
/usr/src/sys/security/mac_biba/mac_biba.c:static int	biba_label_size = sizeof(struct mac_biba);
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, label_size, CTLFLAG_RD,
/usr/src/sys/security/mac_biba/mac_biba.c:    &biba_label_size, 0, "Size of struct mac_biba");
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, enabled, CTLFLAG_RW, &biba_enabled,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, destroyed_not_inited, CTLFLAG_RD,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, trust_all_interfaces, CTLFLAG_RD,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_STRING(_security_mac_biba, OID_AUTO, trusted_interfaces, CTLFLAG_RD,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, max_compartments, CTLFLAG_RD,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, ptys_equal, CTLFLAG_RW, &ptys_equal,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, interfaces_equal, CTLFLAG_RW,
/usr/src/sys/security/mac_biba/mac_biba.c:SYSCTL_INT(_security_mac_biba, OID_AUTO, revocation_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_biba/mac_biba.c:#define	SLOT(l)	((struct mac_biba *)mac_label_get((l), biba_slot))
/usr/src/sys/security/mac_biba/mac_biba.c:#define	SLOT_SET(l, val) mac_label_set((l), biba_slot, (uintptr_t)(val))
/usr/src/sys/security/mac_biba/mac_biba.c:static struct mac_biba *
/usr/src/sys/security/mac_biba/mac_biba.c:biba_free(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_atmostflags(struct mac_biba *mb, int flags)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_dominate_element(struct mac_biba_element *a, struct mac_biba_element *b)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_subject_dominate_high(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba_element *element;
/usr/src/sys/security/mac_biba/mac_biba.c:biba_range_in_range(struct mac_biba *rangea, struct mac_biba *rangeb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_effective_in_range(struct mac_biba *effective, struct mac_biba *range)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_dominate_effective(struct mac_biba *a, struct mac_biba *b)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_equal_element(struct mac_biba_element *a, struct mac_biba_element *b)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_equal_effective(struct mac_biba *a, struct mac_biba *b)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_contains_equal(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_subject_privileged(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_high_effective(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_valid(struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_set_range(struct mac_biba *mb, u_short typelow, u_short gradelow,
/usr/src/sys/security/mac_biba/mac_biba.c:biba_set_effective(struct mac_biba *mb, u_short type, u_short grade,
/usr/src/sys/security/mac_biba/mac_biba.c:biba_copy_range(struct mac_biba *labelfrom, struct mac_biba *labelto)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_copy_effective(struct mac_biba *labelfrom, struct mac_biba *labelto)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_copy(struct mac_biba *source, struct mac_biba *dest)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_init(struct mac_policy_conf *conf)
/usr/src/sys/security/mac_biba/mac_biba.c:	zone_biba = uma_zcreate("mac_biba", sizeof(struct mac_biba), NULL,
/usr/src/sys/security/mac_biba/mac_biba.c:biba_element_to_string(struct sbuf *sb, struct mac_biba_element *element)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_to_string(struct sbuf *sb, struct mac_biba *mb)
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *mb;
/usr/src/sys/security/mac_biba/mac_biba.c:biba_parse_element(struct mac_biba_element *element, char *string)
/usr/src/sys/security/mac_biba/mac_biba.c:biba_parse(struct mac_biba *mb, char *string)
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *mb, mb_temp;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *a, *b;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *label;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *new;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *mb;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *mb;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *new;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *p, *i;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:				printf("mac_biba warning: interface name "
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *p, *i;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *a, *b;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *a, *b;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj, *new;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *p, *s;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj, *new;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj;
/usr/src/sys/security/mac_biba/mac_biba.c:	bzero(SLOT(msglabel), sizeof(struct mac_biba));
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	bzero(SLOT(msqlabel), sizeof(struct mac_biba));
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	bzero(SLOT(semalabel), sizeof(struct mac_biba));
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	bzero(SLOT(shmlabel), sizeof(struct mac_biba));
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba mb_temp, *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj, *exec;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *old, *new, *subj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *subj, *obj;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest, mb_temp;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, *dest;
/usr/src/sys/security/mac_biba/mac_biba.c:	struct mac_biba *source, mb_temp;
/usr/src/sys/security/mac_biba/mac_biba.c:static struct mac_policy_ops mac_biba_ops =
/usr/src/sys/security/mac_biba/mac_biba.c:MAC_POLICY_SET(&mac_biba_ops, mac_biba, "TrustedBSD MAC/Biba",
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c: * $FreeBSD: stable/9/sys/security/mac_bsdextended/mac_bsdextended.c 249132 2013-04-05 08:22:11Z mav $
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:#include <security/mac_bsdextended/ugidfw_internal.h>
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:static MALLOC_DEFINE(M_MACBSDEXTENDED, "mac_bsdextended",
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:static struct mac_bsdextended_rule *rules[MAC_BSDEXTENDED_MAXRULES];
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, rule_count, CTLFLAG_RD,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, rule_slots, CTLFLAG_RD,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, rule_version, CTLFLAG_RD,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, logging, CTLFLAG_RW,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, firstmatch_enabled,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:ugidfw_rule_valid(struct mac_bsdextended_rule *rule)
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	struct mac_bsdextended_rule temprule, *ruleptr;
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:static SYSCTL_NODE(_security_mac_bsdextended, OID_AUTO, rules,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:ugidfw_init(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	mtx_init(&ugidfw_mtx, "mac_bsdextended lock", NULL, MTX_DEF);
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:ugidfw_destroy(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:ugidfw_rulecheck(struct mac_bsdextended_rule *rule,
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	int mac_granted, match, priv_granted;
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	mac_granted = rule->mbr_mode;
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if ((acc_mode & MBI_ADMIN) && (mac_granted & MBI_ADMIN) == 0 &&
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if ((acc_mode & MBI_EXEC) && (mac_granted & MBI_EXEC) == 0 &&
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if ((acc_mode & MBI_READ) && (mac_granted & MBI_READ) == 0 &&
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if ((acc_mode & MBI_STAT) && (mac_granted & MBI_STAT) == 0 &&
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if ((acc_mode & MBI_WRITE) && (mac_granted & MBI_WRITE) == 0 &&
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:	if (((mac_granted | priv_granted) & acc_mode) != acc_mode) {
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:			log(LOG_AUTHPRIV, "mac_bsdextended: %d:%d request %d"
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:static struct mac_policy_ops ugidfw_ops =
/usr/src/sys/security/mac_bsdextended/mac_bsdextended.c:MAC_POLICY_SET(&ugidfw_ops, mac_bsdextended, "TrustedBSD MAC/BSD Extended",
/usr/src/sys/security/mac_bsdextended/ugidfw_system.c: * $FreeBSD: stable/9/sys/security/mac_bsdextended/ugidfw_system.c 185539 2008-12-02 02:26:15Z peter $
/usr/src/sys/security/mac_bsdextended/ugidfw_system.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_bsdextended/ugidfw_system.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/sys/security/mac_bsdextended/ugidfw_system.c:#include <security/mac_bsdextended/ugidfw_internal.h>
/usr/src/sys/security/mac_bsdextended/ugidfw_vnode.c: * $FreeBSD: stable/9/sys/security/mac_bsdextended/ugidfw_vnode.c 189533 2009-03-08 12:32:06Z rwatson $
/usr/src/sys/security/mac_bsdextended/ugidfw_vnode.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_bsdextended/ugidfw_vnode.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/sys/security/mac_bsdextended/ugidfw_vnode.c:#include <security/mac_bsdextended/ugidfw_internal.h>
/usr/src/sys/security/mac_ifoff/mac_ifoff.c: * $FreeBSD: stable/9/sys/security/mac_ifoff/mac_ifoff.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:    "TrustedBSD mac_ifoff policy controls");
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:SYSCTL_INT(_security_mac_ifoff, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:SYSCTL_INT(_security_mac_ifoff, OID_AUTO, lo_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:SYSCTL_INT(_security_mac_ifoff, OID_AUTO, other_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:SYSCTL_INT(_security_mac_ifoff, OID_AUTO, bpfrecv_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:static struct mac_policy_ops ifoff_ops =
/usr/src/sys/security/mac_ifoff/mac_ifoff.c:MAC_POLICY_SET(&ifoff_ops, mac_ifoff, "TrustedBSD MAC/ifoff",
/usr/src/sys/security/mac_lomac/mac_lomac.c: * $FreeBSD: stable/9/sys/security/mac_lomac/mac_lomac.c 249132 2013-04-05 08:22:11Z mav $
/usr/src/sys/security/mac_lomac/mac_lomac.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_lomac/mac_lomac.c:#include <security/mac/mac_framework.h>
/usr/src/sys/security/mac_lomac/mac_lomac.c:#include <security/mac_lomac/mac_lomac.h>
/usr/src/sys/security/mac_lomac/mac_lomac.c:struct mac_lomac_proc {
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac mac_lomac;
/usr/src/sys/security/mac_lomac/mac_lomac.c:    "TrustedBSD mac_lomac policy controls");
/usr/src/sys/security/mac_lomac/mac_lomac.c:static int	lomac_label_size = sizeof(struct mac_lomac);
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, label_size, CTLFLAG_RD,
/usr/src/sys/security/mac_lomac/mac_lomac.c:    &lomac_label_size, 0, "Size of struct mac_lomac");
/usr/src/sys/security/mac_lomac/mac_lomac.c:static int	lomac_enabled = 1;
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_lomac/mac_lomac.c:    &lomac_enabled, 0, "Enforce MAC/LOMAC policy");
/usr/src/sys/security/mac_lomac/mac_lomac.c:TUNABLE_INT("security.mac.lomac.enabled", &lomac_enabled);
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, destroyed_not_inited, CTLFLAG_RD,
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, trust_all_interfaces, CTLFLAG_RD,
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_STRING(_security_mac_lomac, OID_AUTO, trusted_interfaces, CTLFLAG_RD,
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, ptys_equal, CTLFLAG_RW,
/usr/src/sys/security/mac_lomac/mac_lomac.c:SYSCTL_INT(_security_mac_lomac, OID_AUTO, revocation_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_lomac/mac_lomac.c:static int	lomac_slot;
/usr/src/sys/security/mac_lomac/mac_lomac.c:#define	SLOT(l)	((struct mac_lomac *)mac_label_get((l), lomac_slot))
/usr/src/sys/security/mac_lomac/mac_lomac.c:#define	SLOT_SET(l, val) mac_label_set((l), lomac_slot, (uintptr_t)(val))
/usr/src/sys/security/mac_lomac/mac_lomac.c:#define	PSLOT(l) ((struct mac_lomac_proc *)				\
/usr/src/sys/security/mac_lomac/mac_lomac.c:    mac_label_get((l), lomac_slot))
/usr/src/sys/security/mac_lomac/mac_lomac.c:#define	PSLOT_SET(l, val) mac_label_set((l), lomac_slot, (uintptr_t)(val))
/usr/src/sys/security/mac_lomac/mac_lomac.c:static MALLOC_DEFINE(M_LOMAC, "mac_lomac_label", "MAC/LOMAC labels");
/usr/src/sys/security/mac_lomac/mac_lomac.c:static struct mac_lomac *
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_alloc(int flag)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *ml;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_free(struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_atmostflags(struct mac_lomac *ml, int flags)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_dominate_element(struct mac_lomac_element *a,
/usr/src/sys/security/mac_lomac/mac_lomac.c:    struct mac_lomac_element *b)
/usr/src/sys/security/mac_lomac/mac_lomac.c:			panic("lomac_dominate_element: b->mle_type invalid");
/usr/src/sys/security/mac_lomac/mac_lomac.c:			panic("lomac_dominate_element: b->mle_type invalid");
/usr/src/sys/security/mac_lomac/mac_lomac.c:		panic("lomac_dominate_element: a->mle_type invalid");
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_range_in_range(struct mac_lomac *rangea, struct mac_lomac *rangeb)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_dominate_element(&rangeb->ml_rangehigh,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    lomac_dominate_element(&rangea->ml_rangelow,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_single_in_range(struct mac_lomac *single, struct mac_lomac *range)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_single_in_range: a not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_single_in_range: b not range"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_dominate_element(&range->ml_rangehigh,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    &single->ml_single) && lomac_dominate_element(&single->ml_single,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_auxsingle_in_range(struct mac_lomac *single, struct mac_lomac *range)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_single_in_range: a not auxsingle"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_single_in_range: b not range"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_dominate_element(&range->ml_rangehigh,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    lomac_dominate_element(&single->ml_auxsingle,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_dominate_single(struct mac_lomac *a, struct mac_lomac *b)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_dominate_single: a not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_dominate_single: b not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_dominate_element(&a->ml_single, &b->ml_single));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_subject_dominate(struct mac_lomac *a, struct mac_lomac *b)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_dominate_single: a not subject"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_dominate_single: b not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_dominate_element(&a->ml_rangehigh, &b->ml_single));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_equal_element(struct mac_lomac_element *a, struct mac_lomac_element *b)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_equal_single(struct mac_lomac *a, struct mac_lomac *b)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_equal_single: a not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_equal_single: b not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_equal_element(&a->ml_single, &b->ml_single));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_contains_equal(struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_subject_privileged(struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_subject_privileged: subject doesn't have both labels"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_high_single(struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_high_single: mac_lomac not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_valid(struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_dominate_element(&ml->ml_rangehigh,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_set_range(struct mac_lomac *ml, u_short typelow, u_short gradelow,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_set_single(struct mac_lomac *ml, u_short type, u_short grade)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_copy_range(struct mac_lomac *labelfrom, struct mac_lomac *labelto)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_copy_range: labelfrom not range"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_copy_single(struct mac_lomac *labelfrom, struct mac_lomac *labelto)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_copy_single: labelfrom not single"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_copy_auxsingle(struct mac_lomac *labelfrom, struct mac_lomac *labelto)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_copy_auxsingle: labelfrom not auxsingle"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_copy(struct mac_lomac *source, struct mac_lomac *dest)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_auxsingle(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_range(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:static int	lomac_to_string(struct sbuf *sb, struct mac_lomac *ml);
/usr/src/sys/security/mac_lomac/mac_lomac.c:maybe_demote(struct mac_lomac *subjlabel, struct mac_lomac *objlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac cached_subjlabel;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac_proc *subj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:        if (subj->mac_lomac.ml_flags & MAC_LOMAC_FLAG_UPDATE) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_dominate_single(objlabel, &subj->mac_lomac)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:	bzero(&subj->mac_lomac, sizeof(subj->mac_lomac));
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(objlabel, &subj->mac_lomac);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_range(subjlabel, &subj->mac_lomac);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_element(&objlabel->ml_single,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    &subj->mac_lomac.ml_rangelow))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		subj->mac_lomac.ml_rangelow = objlabel->ml_single;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	subj->mac_lomac.ml_rangehigh = objlabel->ml_single;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	subj->mac_lomac.ml_flags |= MAC_LOMAC_FLAG_UPDATE;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(&subj->mac_lomac, &cached_subjlabel);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_to_string(&subjlabel_sb, subjlabel);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_to_string(&subjtext_sb, &subj->mac_lomac);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_to_string(&objlabel_sb, objlabel);
/usr/src/sys/security/mac_lomac/mac_lomac.c:try_relabel(struct mac_lomac *from, struct mac_lomac *to)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy(from, to);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_init(struct mac_policy_conf *conf)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_init_label(struct label *label)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	SLOT_SET(label, lomac_alloc(M_WAITOK));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_init_label_waitcheck(struct label *label, int flag)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	SLOT_SET(label, lomac_alloc(flag));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_destroy_label(struct label *label)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_free(SLOT(label));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_element_to_string(struct sbuf *sb, struct mac_lomac_element *element)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		panic("lomac_element_to_string: invalid type (%d)",
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_to_string(struct sbuf *sb, struct mac_lomac *ml)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_element_to_string(sb, &ml->ml_single) == -1)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_element_to_string(sb, &ml->ml_auxsingle) == -1)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_element_to_string(sb, &ml->ml_rangelow) == -1)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_element_to_string(sb, &ml->ml_rangehigh) == -1)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_externalize_label(struct label *label, char *element_name,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *ml;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_to_string(sb, ml));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_parse_element(struct mac_lomac_element *element, char *string)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_parse(struct mac_lomac *ml, char *string)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    ("lomac_internalize_label: range mismatch"));
/usr/src/sys/security/mac_lomac/mac_lomac.c:		error = lomac_parse_element(&ml->ml_single, single);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		error = lomac_parse_element(&ml->ml_auxsingle, auxsingle);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		error = lomac_parse_element(&ml->ml_rangelow, rangelow);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		error = lomac_parse_element(&ml->ml_rangehigh, rangehigh);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_valid(ml);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_internalize_label(struct label *label, char *element_name,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *ml, ml_temp;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_parse(&ml_temp, element_data);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_copy_label(struct label *src, struct label *dest)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_bpfdesc_check_receive(struct bpf_d *d, struct label *dlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *a, *b;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_equal_single(a, b))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_bpfdesc_create(struct ucred *cred, struct bpf_d *d,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_bpfdesc_create_mbuf(struct bpf_d *d, struct label *dlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_cred_check_relabel(struct ucred *cred, struct label *newlabel)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *new;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_atmostflags(new, MAC_LOMAC_FLAGS_BOTH);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			lomac_copy_single(subj, new);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			lomac_copy_range(subj, new);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_range_in_range(new, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_single_in_range(new, new))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_contains_equal(new)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:			error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_cred_check_visible(struct ucred *cr1, struct ucred *cr2)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_cred_create_init(struct ucred *cred)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_HIGH, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_range(dest, MAC_LOMAC_TYPE_LOW, 0, MAC_LOMAC_TYPE_HIGH, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_cred_create_swapper(struct ucred *cred)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_range(dest, MAC_LOMAC_TYPE_LOW, 0, MAC_LOMAC_TYPE_HIGH, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_cred_relabel(struct ucred *cred, struct label *newlabel)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_devfs_create_device(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *ml;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	int lomac_type;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_type = MAC_LOMAC_TYPE_EQUAL;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_type = MAC_LOMAC_TYPE_EQUAL;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_type = MAC_LOMAC_TYPE_HIGH;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(ml, lomac_type, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_devfs_create_directory(struct mount *mp, char *dirname, int dirnamelen,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *ml;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(ml, MAC_LOMAC_TYPE_HIGH, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_devfs_create_symlink(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_devfs_update(struct mount *mp, struct devfs_dirent *de,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_devfs_vnode_associate(struct mount *mp, struct label *mplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ifnet_check_relabel(struct ucred *cred, struct ifnet *ifp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *new;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_atmostflags(new, MAC_LOMAC_FLAGS_BOTH);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			lomac_copy_single(subj, new);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			lomac_copy_range(subj, new);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ifnet_check_transmit(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *p, *i;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_single_in_range(p, i) ? 0 : EACCES);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ifnet_create(struct ifnet *ifp, struct label *ifplabel)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, grade, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_range(dest, grade, 0, grade, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ifnet_create_mbuf(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ifnet_relabel(struct ucred *cred, struct ifnet *ifp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_inpcb_check_deliver(struct inpcb *inp, struct label *inplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *p, *i;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_equal_single(p, i) ? 0 : EACCES);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_inpcb_check_visible(struct ucred *cred, struct inpcb *inp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_inpcb_create(struct socket *so, struct label *solabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_inpcb_create_mbuf(struct inpcb *inp, struct label *inplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_inpcb_sosetlabel(struct socket *so, struct label *solabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ip6q_create(struct mbuf *m, struct label *mlabel, struct ip6q *q6,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ip6q_match(struct mbuf *m, struct label *mlabel, struct ip6q *q6,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *a, *b;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_equal_single(a, b));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ip6q_reassemble(struct ip6q *q6, struct label *q6label, struct mbuf *m,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ip6q_update(struct mbuf *m, struct label *mlabel, struct ip6q *q6,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ipq_create(struct mbuf *m, struct label *mlabel, struct ipq *q,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ipq_match(struct mbuf *m, struct label *mlabel, struct ipq *q,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *a, *b;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	return (lomac_equal_single(a, b));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ipq_reassemble(struct ipq *q, struct label *qlabel, struct mbuf *m,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_ipq_update(struct mbuf *m, struct label *mlabel, struct ipq *q,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_kld_check_load(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_high_single(obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_mount_create(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netatalk_aarp_send(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_arp_send(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_firewall_reply(struct mbuf *mrecv, struct label *mrecvlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_firewall_send(struct mbuf *m, struct label *mlabel)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_fragment(struct mbuf *m, struct label *mlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_icmp_reply(struct mbuf *mrecv, struct label *mrecvlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet_igmp_send(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_netinet6_nd6_send(struct ifnet *ifp, struct label *ifplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_set_single(dest, MAC_LOMAC_TYPE_EQUAL, 0);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_check_ioctl(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_check_read(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_check_relabel(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj, *new;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_atmostflags(new, MAC_LOMAC_FLAG_SINGLE);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_single_in_range(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_single_in_range(new, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_contains_equal(new)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:			error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_check_write(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_create(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_pipe_relabel(struct ucred *cred, struct pipepair *pp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_priv_check(struct ucred *cred, int priv)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_proc_check_debug(struct ucred *cred, struct proc *p)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_proc_check_sched(struct ucred *cred, struct proc *p)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_proc_check_signal(struct ucred *cred, struct proc *p, int signum)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_proc_destroy_label(struct label *label)
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_proc_init_label(struct label *label)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	PSLOT_SET(label, malloc(sizeof(struct mac_lomac_proc), M_LOMAC,
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_check_deliver(struct socket *so, struct label *solabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *p, *s;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_equal_single(p, s) ? 0 : EACCES;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_check_relabel(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj, *new;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_atmostflags(new, MAC_LOMAC_FLAG_SINGLE);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_single_in_range(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_single_in_range(new, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_contains_equal(new)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:			error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_check_visible(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_create(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_create_mbuf(struct socket *so, struct label *solabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_newconn(struct socket *oldso, struct label *oldsolabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(&source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socket_relabel(struct ucred *cred, struct socket *so,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socketpeer_set_from_mbuf(struct mbuf *m, struct label *mlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_socketpeer_set_from_socket(struct socket *oldso,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(&source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_syncache_create(struct label *label, struct inpcb *inp)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_syncache_create_mbuf(struct label *sc_label, struct mbuf *m,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_system_check_acct(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_high_single(obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_system_check_auditctl(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_high_single(obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_system_check_swapoff(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_system_check_swapon(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_high_single(obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_system_check_sysctl(struct ucred *cred, struct sysctl_oid *oidp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_subject_dominate_high(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_subject_privileged(subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_thread_userret(struct thread *td)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac_proc *subj = PSLOT(p->p_label);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (subj->mac_lomac.ml_flags & MAC_LOMAC_FLAG_UPDATE) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:		 * Prevent a lock order reversal in mac_proc_vm_revoke;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if ((subj->mac_lomac.ml_flags & MAC_LOMAC_FLAG_UPDATE) == 0) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy(&subj->mac_lomac, SLOT(newcred->cr_label));
/usr/src/sys/security/mac_lomac/mac_lomac.c:			mac_proc_vm_revoke(curthread);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_associate_extattr(struct mount *mp, struct label *mplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac ml_temp, *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			printf("lomac_vnode_associate_extattr: bad size %d\n",
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_valid(&ml_temp) != 0) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:		printf("lomac_vnode_associate_extattr: invalid\n");
/usr/src/sys/security/mac_lomac/mac_lomac.c:		printf("lomac_vnode_associate_extattr: not single\n");
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(&ml_temp, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_associate_singlelabel(struct mount *mp, struct label *mplabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_create(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    !lomac_dominate_element(&subj->ml_single, &obj->ml_auxsingle))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_deleteacl(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_link(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_mmap(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_mmap_downgrade(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled || !revocation_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_open(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_read(struct ucred *active_cred, struct ucred *file_cred,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled || !revocation_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_dominate_single(obj, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_relabel(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *old, *new, *subj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	error = lomac_atmostflags(new,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_single_in_range(old, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_single_in_range(new, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_contains_equal(new)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:			error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:			lomac_copy_single(subj, new);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_auxsingle_in_range(new, subj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (lomac_contains_equal(new)) {
/usr/src/sys/security/mac_lomac/mac_lomac.c:			error = lomac_subject_privileged(subj);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_rename_from(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_rename_to(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_revoke(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setacl(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setextattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setflags(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setmode(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setowner(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_setutimes(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_unlink(struct ucred *cred, struct vnode *dvp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_check_write(struct ucred *active_cred,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled || !revocation_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_subject_dominate(subj, obj))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_create_extattr(struct ucred *cred, struct mount *mp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest, *dir, temp;
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_auxsingle(dir, &temp);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_set_single(&temp, dir->ml_auxsingle.mle_type,
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy_single(source, &temp);
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_copy(&temp, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_execve_transition(struct ucred *old, struct ucred *new,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest, *obj, *robj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy(source, dest);
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    !lomac_dominate_element(&robj->ml_auxsingle, &dest->ml_single)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    && lomac_auxsingle_in_range(robj, dest))
/usr/src/sys/security/mac_lomac/mac_lomac.c:		lomac_set_single(dest, robj->ml_auxsingle.mle_type,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (lomac_enabled && revocation_enabled &&
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    !lomac_dominate_single(obj, source))
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_execve_will_transition(struct ucred *old, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *subj, *obj, *robj;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	if (!lomac_enabled || !revocation_enabled)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    !lomac_dominate_element(&robj->ml_auxsingle, &subj->ml_single)
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    && lomac_auxsingle_in_range(robj, subj)) ||
/usr/src/sys/security/mac_lomac/mac_lomac.c:	    !lomac_dominate_single(obj, subj));
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_relabel(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, *dest;
/usr/src/sys/security/mac_lomac/mac_lomac.c:lomac_vnode_setlabel_extattr(struct ucred *cred, struct vnode *vp,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	struct mac_lomac *source, temp;
/usr/src/sys/security/mac_lomac/mac_lomac.c:	lomac_copy_single(source, &temp);
/usr/src/sys/security/mac_lomac/mac_lomac.c:static struct mac_policy_ops lomac_ops =
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_init = lomac_init,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_bpfdesc_check_receive = lomac_bpfdesc_check_receive,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_bpfdesc_create = lomac_bpfdesc_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_bpfdesc_create_mbuf = lomac_bpfdesc_create_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_bpfdesc_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_bpfdesc_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_check_relabel = lomac_cred_check_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_check_visible = lomac_cred_check_visible,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_create_swapper = lomac_cred_create_swapper,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_create_init = lomac_cred_create_init,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_internalize_label = lomac_internalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_cred_relabel = lomac_cred_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_create_device = lomac_devfs_create_device,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_create_directory = lomac_devfs_create_directory,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_create_symlink = lomac_devfs_create_symlink,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_update = lomac_devfs_update,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_devfs_vnode_associate = lomac_devfs_vnode_associate,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_check_relabel = lomac_ifnet_check_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_check_transmit = lomac_ifnet_check_transmit,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_create = lomac_ifnet_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_create_mbuf = lomac_ifnet_create_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_internalize_label = lomac_internalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ifnet_relabel = lomac_ifnet_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_syncache_create = lomac_syncache_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_syncache_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_syncache_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_check_deliver = lomac_inpcb_check_deliver,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_check_visible = lomac_inpcb_check_visible,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_create = lomac_inpcb_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_create_mbuf = lomac_inpcb_create_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_inpcb_sosetlabel = lomac_inpcb_sosetlabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_create = lomac_ip6q_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_match = lomac_ip6q_match,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_reassemble = lomac_ip6q_reassemble,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ip6q_update = lomac_ip6q_update,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_create = lomac_ipq_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_match = lomac_ipq_match,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_reassemble = lomac_ipq_reassemble,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_ipq_update = lomac_ipq_update,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_kld_check_load = lomac_kld_check_load,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mbuf_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mbuf_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mbuf_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mount_create = lomac_mount_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mount_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_mount_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netatalk_aarp_send = lomac_netatalk_aarp_send,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_arp_send = lomac_netinet_arp_send,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_firewall_reply = lomac_netinet_firewall_reply,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_firewall_send = lomac_netinet_firewall_send,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_fragment = lomac_netinet_fragment,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_icmp_reply = lomac_netinet_icmp_reply,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet_igmp_send = lomac_netinet_igmp_send,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_netinet6_nd6_send = lomac_netinet6_nd6_send,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_check_ioctl = lomac_pipe_check_ioctl,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_check_read = lomac_pipe_check_read,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_check_relabel = lomac_pipe_check_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_check_write = lomac_pipe_check_write,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_create = lomac_pipe_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_internalize_label = lomac_internalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_pipe_relabel = lomac_pipe_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_priv_check = lomac_priv_check,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_proc_check_debug = lomac_proc_check_debug,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_proc_check_sched = lomac_proc_check_sched,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_proc_check_signal = lomac_proc_check_signal,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_proc_destroy_label = lomac_proc_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_proc_init_label = lomac_proc_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_check_deliver = lomac_socket_check_deliver,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_check_relabel = lomac_socket_check_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_check_visible = lomac_socket_check_visible,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_create = lomac_socket_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_create_mbuf = lomac_socket_create_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_internalize_label = lomac_internalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_newconn = lomac_socket_newconn,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socket_relabel = lomac_socket_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socketpeer_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socketpeer_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socketpeer_init_label = lomac_init_label_waitcheck,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socketpeer_set_from_mbuf = lomac_socketpeer_set_from_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_socketpeer_set_from_socket = lomac_socketpeer_set_from_socket,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_syncache_create_mbuf = lomac_syncache_create_mbuf,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_system_check_acct = lomac_system_check_acct,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_system_check_auditctl = lomac_system_check_auditctl,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_system_check_swapoff = lomac_system_check_swapoff,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_system_check_swapon = lomac_system_check_swapon,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_system_check_sysctl = lomac_system_check_sysctl,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_thread_userret = lomac_thread_userret,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_associate_extattr = lomac_vnode_associate_extattr,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_associate_singlelabel = lomac_vnode_associate_singlelabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_access = lomac_vnode_check_open,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_create = lomac_vnode_check_create,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_deleteacl = lomac_vnode_check_deleteacl,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_link = lomac_vnode_check_link,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_mmap = lomac_vnode_check_mmap,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_mmap_downgrade = lomac_vnode_check_mmap_downgrade,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_open = lomac_vnode_check_open,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_read = lomac_vnode_check_read,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_relabel = lomac_vnode_check_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_rename_from = lomac_vnode_check_rename_from,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_rename_to = lomac_vnode_check_rename_to,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_revoke = lomac_vnode_check_revoke,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setacl = lomac_vnode_check_setacl,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setextattr = lomac_vnode_check_setextattr,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setflags = lomac_vnode_check_setflags,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setmode = lomac_vnode_check_setmode,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setowner = lomac_vnode_check_setowner,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_setutimes = lomac_vnode_check_setutimes,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_unlink = lomac_vnode_check_unlink,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_check_write = lomac_vnode_check_write,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_copy_label = lomac_copy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_create_extattr = lomac_vnode_create_extattr,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_destroy_label = lomac_destroy_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_execve_transition = lomac_vnode_execve_transition,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_execve_will_transition = lomac_vnode_execve_will_transition,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_externalize_label = lomac_externalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_init_label = lomac_init_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_internalize_label = lomac_internalize_label,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_relabel = lomac_vnode_relabel,
/usr/src/sys/security/mac_lomac/mac_lomac.c:	.mpo_vnode_setlabel_extattr = lomac_vnode_setlabel_extattr,
/usr/src/sys/security/mac_lomac/mac_lomac.c:MAC_POLICY_SET(&lomac_ops, mac_lomac, "TrustedBSD MAC/LOMAC",
/usr/src/sys/security/mac_lomac/mac_lomac.c:    MPC_LOADTIME_FLAG_NOTLATE, &lomac_slot);
/usr/src/sys/security/mac_mls/mac_mls.c: * $FreeBSD: stable/9/sys/security/mac_mls/mac_mls.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_mls/mac_mls.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_mls/mac_mls.c:#include <security/mac_mls/mac_mls.h>
/usr/src/sys/security/mac_mls/mac_mls.c:    "TrustedBSD mac_mls policy controls");
/usr/src/sys/security/mac_mls/mac_mls.c:static int	mls_label_size = sizeof(struct mac_mls);
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, label_size, CTLFLAG_RD,
/usr/src/sys/security/mac_mls/mac_mls.c:    &mls_label_size, 0, "Size of struct mac_mls");
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, enabled, CTLFLAG_RW, &mls_enabled, 0,
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, destroyed_not_inited, CTLFLAG_RD,
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, ptys_equal, CTLFLAG_RW,
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, revocation_enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_mls/mac_mls.c:SYSCTL_INT(_security_mac_mls, OID_AUTO, max_compartments, CTLFLAG_RD,
/usr/src/sys/security/mac_mls/mac_mls.c:#define	SLOT(l)	((struct mac_mls *)mac_label_get((l), mls_slot))
/usr/src/sys/security/mac_mls/mac_mls.c:#define	SLOT_SET(l, val) mac_label_set((l), mls_slot, (uintptr_t)(val))
/usr/src/sys/security/mac_mls/mac_mls.c:static struct mac_mls *
/usr/src/sys/security/mac_mls/mac_mls.c:mls_free(struct mac_mls *mm)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_atmostflags(struct mac_mls *mm, int flags)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_dominate_element(struct mac_mls_element *a, struct mac_mls_element *b)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_range_in_range(struct mac_mls *rangea, struct mac_mls *rangeb)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_effective_in_range(struct mac_mls *effective, struct mac_mls *range)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_dominate_effective(struct mac_mls *a, struct mac_mls *b)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_equal_element(struct mac_mls_element *a, struct mac_mls_element *b)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_equal_effective(struct mac_mls *a, struct mac_mls *b)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_contains_equal(struct mac_mls *mm)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_subject_privileged(struct mac_mls *mm)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_valid(struct mac_mls *mm)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_set_range(struct mac_mls *mm, u_short typelow, u_short levellow,
/usr/src/sys/security/mac_mls/mac_mls.c:mls_set_effective(struct mac_mls *mm, u_short type, u_short level,
/usr/src/sys/security/mac_mls/mac_mls.c:mls_copy_range(struct mac_mls *labelfrom, struct mac_mls *labelto)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_copy_effective(struct mac_mls *labelfrom, struct mac_mls *labelto)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_copy(struct mac_mls *source, struct mac_mls *dest)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_init(struct mac_policy_conf *conf)
/usr/src/sys/security/mac_mls/mac_mls.c:	zone_mls = uma_zcreate("mac_mls", sizeof(struct mac_mls), NULL,
/usr/src/sys/security/mac_mls/mac_mls.c:mls_element_to_string(struct sbuf *sb, struct mac_mls_element *element)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_to_string(struct sbuf *sb, struct mac_mls *mm)
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *mm;
/usr/src/sys/security/mac_mls/mac_mls.c:mls_parse_element(struct mac_mls_element *element, char *string)
/usr/src/sys/security/mac_mls/mac_mls.c:mls_parse(struct mac_mls *mm, char *string)
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *mm, mm_temp;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *a, *b;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *label;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *new;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *mm;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *mm;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *new;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *p, *i;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *p, *i;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *a, *b;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *a, *b;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj, *new;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *p, *s;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj, *new;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	bzero(SLOT(msglabel), sizeof(struct mac_mls));
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	bzero(SLOT(msqlabel), sizeof(struct mac_mls));
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	bzero(SLOT(semalabel), sizeof(struct mac_mls));
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	bzero(SLOT(shmlabel), sizeof(struct mac_mls));
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls mm_temp, *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj, *exec;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *old, *new, *subj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *subj, *obj;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest, mm_temp;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, *dest;
/usr/src/sys/security/mac_mls/mac_mls.c:	struct mac_mls *source, mm_temp;
/usr/src/sys/security/mac_mls/mac_mls.c:static struct mac_policy_ops mls_ops =
/usr/src/sys/security/mac_mls/mac_mls.c:MAC_POLICY_SET(&mls_ops, mac_mls, "TrustedBSD MAC/MLS",
/usr/src/sys/security/mac_none/mac_none.c: * $FreeBSD: stable/9/sys/security/mac_none/mac_none.c 187016 2009-01-10 10:58:41Z rwatson $
/usr/src/sys/security/mac_none/mac_none.c: * on, try mac_stub.
/usr/src/sys/security/mac_none/mac_none.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_none/mac_none.c:static struct mac_policy_ops none_ops =
/usr/src/sys/security/mac_none/mac_none.c:MAC_POLICY_SET(&none_ops, mac_none, "TrustedBSD MAC/None",
/usr/src/sys/security/mac_partition/mac_partition.c: * $FreeBSD: stable/9/sys/security/mac_partition/mac_partition.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_partition/mac_partition.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_partition/mac_partition.c:#include <security/mac_partition/mac_partition.h>
/usr/src/sys/security/mac_partition/mac_partition.c:    "TrustedBSD mac_partition policy controls");
/usr/src/sys/security/mac_partition/mac_partition.c:SYSCTL_INT(_security_mac_partition, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_partition/mac_partition.c:#define	SLOT(l)	mac_label_get((l), partition_slot)
/usr/src/sys/security/mac_partition/mac_partition.c:#define	SLOT_SET(l, v)	mac_label_set((l), partition_slot, (v))
/usr/src/sys/security/mac_partition/mac_partition.c:static struct mac_policy_ops partition_ops =
/usr/src/sys/security/mac_partition/mac_partition.c:MAC_POLICY_SET(&partition_ops, mac_partition, "TrustedBSD MAC/Partition",
/usr/src/sys/security/mac_portacl/mac_portacl.c: * $FreeBSD: stable/9/sys/security/mac_portacl/mac_portacl.c 249132 2013-04-05 08:22:11Z mav $
/usr/src/sys/security/mac_portacl/mac_portacl.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_portacl/mac_portacl.c:    "TrustedBSD mac_portacl policy controls");
/usr/src/sys/security/mac_portacl/mac_portacl.c:SYSCTL_INT(_security_mac_portacl, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_portacl/mac_portacl.c:SYSCTL_INT(_security_mac_portacl, OID_AUTO, suser_exempt, CTLFLAG_RW,
/usr/src/sys/security/mac_portacl/mac_portacl.c:SYSCTL_INT(_security_mac_portacl, OID_AUTO, autoport_exempt, CTLFLAG_RW,
/usr/src/sys/security/mac_portacl/mac_portacl.c:SYSCTL_INT(_security_mac_portacl, OID_AUTO, port_high, CTLFLAG_RW,
/usr/src/sys/security/mac_portacl/mac_portacl.c:static MALLOC_DEFINE(M_PORTACL, "portacl_rule", "Rules for mac_portacl");
/usr/src/sys/security/mac_portacl/mac_portacl.c:destroy(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac_portacl/mac_portacl.c:init(struct mac_policy_conf *mpc)
/usr/src/sys/security/mac_portacl/mac_portacl.c:SYSCTL_PROC(_security_mac_portacl, OID_AUTO, rules,
/usr/src/sys/security/mac_portacl/mac_portacl.c:static struct mac_policy_ops portacl_ops =
/usr/src/sys/security/mac_portacl/mac_portacl.c:MAC_POLICY_SET(&portacl_ops, mac_portacl, "TrustedBSD MAC/portacl",
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c: * $FreeBSD: stable/9/sys/security/mac_seeotheruids/mac_seeotheruids.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:    "TrustedBSD mac_seeotheruids policy controls");
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:SYSCTL_INT(_security_mac_seeotheruids, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:SYSCTL_INT(_security_mac_seeotheruids, OID_AUTO, primarygroup_enabled,
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:SYSCTL_INT(_security_mac_seeotheruids, OID_AUTO, suser_privileged,
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:SYSCTL_INT(_security_mac_seeotheruids, OID_AUTO, specificgid_enabled,
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:SYSCTL_UINT(_security_mac_seeotheruids, OID_AUTO, specificgid, CTLFLAG_RW,
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:static struct mac_policy_ops seeotheruids_ops =
/usr/src/sys/security/mac_seeotheruids/mac_seeotheruids.c:MAC_POLICY_SET(&seeotheruids_ops, mac_seeotheruids,
/usr/src/sys/security/mac_stub/mac_stub.c: * $FreeBSD: stable/9/sys/security/mac_stub/mac_stub.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_stub/mac_stub.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_stub/mac_stub.c:    "TrustedBSD mac_stub policy controls");
/usr/src/sys/security/mac_stub/mac_stub.c:SYSCTL_INT(_security_mac_stub, OID_AUTO, enabled, CTLFLAG_RW,
/usr/src/sys/security/mac_stub/mac_stub.c:    &stub_enabled, 0, "Enforce mac_stub policy");
/usr/src/sys/security/mac_stub/mac_stub.c:stub_destroy(struct mac_policy_conf *conf)
/usr/src/sys/security/mac_stub/mac_stub.c:stub_init(struct mac_policy_conf *conf)
/usr/src/sys/security/mac_stub/mac_stub.c:static struct mac_policy_ops stub_ops =
/usr/src/sys/security/mac_stub/mac_stub.c:MAC_POLICY_SET(&stub_ops, mac_stub, "TrustedBSD MAC/Stub",
/usr/src/sys/security/mac_test/mac_test.c: * $FreeBSD: stable/9/sys/security/mac_test/mac_test.c 248085 2013-03-09 02:36:32Z marius $
/usr/src/sys/security/mac_test/mac_test.c:#include <security/mac/mac_policy.h>
/usr/src/sys/security/mac_test/mac_test.c:    "TrustedBSD mac_test policy controls");
/usr/src/sys/security/mac_test/mac_test.c:#define	SLOT(x)	mac_label_get((x), test_slot)
/usr/src/sys/security/mac_test/mac_test.c:#define	SLOT_SET(x, v)	mac_label_set((x), test_slot, (v))
/usr/src/sys/security/mac_test/mac_test.c:SYSCTL_INT(_security_mac_test, OID_AUTO, slot, CTLFLAG_RD,
/usr/src/sys/security/mac_test/mac_test.c:static SYSCTL_NODE(_security_mac_test, OID_AUTO, counter, CTLFLAG_RW, 0,
/usr/src/sys/security/mac_test/mac_test.c:    "TrustedBSD mac_test counters controls");
/usr/src/sys/security/mac_test/mac_test.c:	SYSCTL_INT(_security_mac_test_counter, OID_AUTO, variable,	\
/usr/src/sys/security/mac_test/mac_test.c:#define	DEBUGGER(func, string)	printf("mac_test: %s: %s\n", (func), (string))
/usr/src/sys/security/mac_test/mac_test.c:static struct mac_policy_ops test_ops =
/usr/src/sys/security/mac_test/mac_test.c:MAC_POLICY_SET(&test_ops, mac_test, "TrustedBSD MAC/Test",
/usr/src/sys/ufs/ffs/ffs_suspend.c:#include <security/mac/mac_framework.h>
/usr/src/sys/ufs/ffs/ffs_suspend.c:	if (mac_mount_check_stat(curthread->td_ucred, mp) != 0)
/usr/src/sys/ufs/ffs/ffs_vfsops.c:#include <security/mac/mac_framework.h>
/usr/src/sys/ufs/ffs/ffs_vfsops.c:		error = mac_vnode_associate_extattr(mp, vp);
/usr/src/sys/ufs/ufs/ufs_vnops.c:#include <security/mac/mac_framework.h>
/usr/src/sys/ufs/ufs/ufs_vnops.c:		error = mac_vnode_create_extattr(cnp->cn_cred, dvp->v_mount,
/usr/src/sys/ufs/ufs/ufs_vnops.c:		error = mac_vnode_create_extattr(cnp->cn_cred, dvp->v_mount,
/usr/src/sys/vm/swap_pager.c:#include <security/mac/mac_framework.h>
/usr/src/sys/vm/swap_pager.c:	error = mac_system_check_swapoff(cred, sp->sw_vp);
/usr/src/sys/vm/swap_pager.c:	error = mac_system_check_swapon(td->td_ucred, vp);
/usr/src/sys/vm/vm_mmap.c:#include <security/mac/mac_framework.h>
/usr/src/sys/vm/vm_mmap.c:	error = mac_vnode_check_mmap(cred, vp, prot, flags);
/usr/src/sys/vm/vm_mmap.c:	error = mac_cdev_check_mmap(td->td_ucred, cdev, prot);
/usr/src/sys/vm/vm_mmap.c:	error = mac_posixshm_check_mmap(td->td_ucred, shmfd, prot, *flagsp);
/usr/src/tools/regression/lib/libc/net/test-eui64_aton.c:	test_str(test_eui64_mac_ascii, &test_eui64_eui48);
/usr/src/tools/regression/lib/libc/net/test-eui64_aton.c:	test_str(test_eui64_mac_colon_ascii, &test_eui64_eui48);
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c: * $FreeBSD: stable/9/tools/regression/mac/mac_bsdextended/test_ugidfw.c 157986 2006-04-23 17:06:18Z dwmalone $
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c: * Starting point for a regression test for mac_bsdextended(4) and the
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:	struct mac_bsdextended_rule rule;
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:	 * mac_is_present().
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:	switch (mac_is_present("bsdextended")) {
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:		err(-1, "mac_is_present");
/usr/src/tools/regression/mac/mac_bsdextended/test_ugidfw.c:		errx(-1, "mac_bsdextended not loaded");
/usr/src/tools/tools/cxgbetool/reg_defs_t4.c:		{ "mac_ref_rst", 2, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t4.c:		{ "mac_rx_rst", 1, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t4.c:		{ "mac_tx_rst", 0, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t4.c:struct reg_info t4_xgmac_regs[] = {
/usr/src/tools/tools/cxgbetool/reg_defs_t5.c:		{ "mac_ref_rst", 2, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t5.c:		{ "mac_rx_rst", 1, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t5.c:		{ "mac_tx_rst", 0, 1 },
/usr/src/tools/tools/cxgbetool/reg_defs_t5.c:struct reg_info t5_mac_regs[] = {
/usr/src/tools/tools/cxgbtool/cxgbtool.c:		if (op.mac_addr_idx == 0xffff)
/usr/src/tools/tools/cxgbtool/cxgbtool.c:		else if (op.mac_hit)
/usr/src/tools/tools/cxgbtool/cxgbtool.c:			printf("%1u/%3u ", (op.mac_addr_idx >> 3) & 0x1,
/usr/src/tools/tools/cxgbtool/cxgbtool.c:			    (op.mac_addr_idx) & 0x7);
/usr/src/tools/tools/cxgbtool/cxgbtool.c:			printf("%1u/  * ", (op.mac_addr_idx >> 3) & 0x1);
/usr/src/tools/tools/cxgbtool/cxgbtool.c:	op.mac_addr_idx = 0xffff;
/usr/src/tools/tools/cxgbtool/cxgbtool.c:			op.mac_hit = val != (uint32_t)-1;
/usr/src/tools/tools/cxgbtool/cxgbtool.c:			op.mac_addr_idx = op.mac_hit ? val : 0;
/usr/src/tools/tools/netmap/pkt-gen.c:struct mac_range {
/usr/src/tools/tools/netmap/pkt-gen.c:	struct mac_range dst_mac;
/usr/src/tools/tools/netmap/pkt-gen.c:	struct mac_range src_mac;
/usr/src/tools/tools/netmap/pkt-gen.c:extract_mac_range(struct mac_range *r)
/usr/src/tools/tools/netmap/pkt-gen.c:		targ->src_mac_range = atoi(p+1);
/usr/src/tools/tools/netmap/pkt-gen.c:		targ->dst_mac_range = atoi(p+1);
/usr/src/tools/tools/netmap/pkt-gen.c:	extract_mac_range(&g.src_mac);
/usr/src/tools/tools/netmap/pkt-gen.c:	extract_mac_range(&g.dst_mac);
/usr/src/usr.bin/id/id.c:	mac_t label;
/usr/src/usr.bin/id/id.c:	error = mac_prepare_process_label(&label);
/usr/src/usr.bin/id/id.c:		errx(1, "mac_prepare_type: %s", strerror(errno));
/usr/src/usr.bin/id/id.c:	error = mac_get_proc(label);
/usr/src/usr.bin/id/id.c:		errx(1, "mac_get_proc: %s", strerror(errno));
/usr/src/usr.bin/id/id.c:	error = mac_to_text(label, &string);
/usr/src/usr.bin/id/id.c:		errx(1, "mac_to_text: %s", strerror(errno));
/usr/src/usr.bin/id/id.c:	mac_free(label);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_mac_crc_errs);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_mac_crc_ok);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_lmac_mcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_lmac_bcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_lmac_ucast_frags);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_lmac_ucasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_hmac_mcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_hmac_bcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_hmac_ucasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_hmac_failed);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_hmac_mcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_hmac_bcasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_hmac_ucasts);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_rx_hmac_discarded);
/usr/src/usr.sbin/ancontrol/ancontrol.c:	    stats->an_tx_hmac_accepted);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static void	wlan_mac_free_maclist(struct wlan_iface *);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static void	wlan_mac_update_aclmacs(void);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *		wlan_mac_find_mac(struct wlan_iface *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *	wlan_get_acl_mac(const struct asn_oid *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *	wlan_get_next_acl_mac(const struct asn_oid *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static int	wlan_mac_index_decode(const struct asn_oid *, uint, char *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static void	wlan_append_mac_index(struct asn_oid *, uint, char *, uint8_t *);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static int	wlan_acl_mac_set_status(struct snmp_context *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static int	wlan_mac_delete_mac(struct wlan_iface *, struct wlan_mac_mac *);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		wlan_append_mac_index(&val->var, sub, wif->wname, wip->pmac);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:op_wlan_mac_access_control(struct snmp_context *ctx, struct snmp_value *val,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			ctx->scratch->int1 = wif->mac_policy;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			wif->mac_policy = val->v.integer;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			if (wlan_set_mac_policy(wif) < 0) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:				wif->mac_policy = ctx->scratch->int1;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			if (wlan_flush_mac_mac(wif) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			wif->mac_policy = ctx->scratch->int1;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_get_mac_policy(wif) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		val->v.integer = wif->mac_policy;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		val->v.integer = wif->mac_nacls;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:op_wlan_mac_acl_mac(struct snmp_context *ctx, struct snmp_value *val,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *macl;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	wlan_mac_update_aclmacs();
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		wlan_append_mac_index(&val->var, sub, wif->wname, macl->mac);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			return(wlan_acl_mac_set_status(ctx, val, sub));
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		    wlan_mac_delete_mac(wif, macl) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		    wlan_mac_delete_mac(wif, macl) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		val->v.integer = macl->mac_status;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		wlan_append_mac_index(&val->var, sub, wif->wname,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		wlan_append_mac_index(&val->var, sub, wif->wname,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	wlan_mac_free_maclist(wif);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	(void)wlan_get_mac_policy(wif);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	(void)wlan_get_mac_acl_macs(wif);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_index_decode(const struct asn_oid *oid, uint sub,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	int mac_off;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	mac_off = sub + oid->subs[sub] + 1;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (oid->subs[mac_off] != IEEE80211_ADDR_LEN)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		mac[i] = oid->subs[mac_off + i + 1];
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_append_mac_index(struct asn_oid *oid, uint sub, char *wname, uint8_t *mac)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, pmac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, pmac) < 0 ||
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_free_maclist(struct wlan_iface *wif)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *wmm;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	while ((wmm = SLIST_FIRST(&wif->mac_maclist)) != NULL) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		SLIST_REMOVE_HEAD(&wif->mac_maclist, wm);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	SLIST_INIT(&wif->mac_maclist);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_find_mac(struct wlan_iface *wif, uint8_t *mac)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *wmm;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	SLIST_FOREACH(wmm, &wif->mac_maclist, wm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:struct wlan_mac_mac *
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_new_mac(const uint8_t *mac)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *wmm;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if ((wmm = (struct wlan_mac_mac *)malloc(sizeof(*wmm))) == NULL)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	wmm->mac_status = RowStatus_notReady;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_free_mac(struct wlan_mac_mac *wmm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_add_mac(struct wlan_iface *wif, struct wlan_mac_mac *wmm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *temp, *prev;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	SLIST_FOREACH(temp, &wif->mac_maclist, wm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if ((prev = SLIST_FIRST(&wif->mac_maclist)) == NULL ||
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	    	SLIST_INSERT_HEAD(&wif->mac_maclist, wmm, wm);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	SLIST_FOREACH(temp, &wif->mac_maclist, wm) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_delete_mac(struct wlan_iface *wif, struct wlan_mac_mac *wmm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wmm->mac_status == RowStatus_active &&
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	    wlan_del_mac_acl_mac(wif, wmm) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	SLIST_REMOVE(&wif->mac_maclist, wmm, wlan_mac_mac, wm);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_mac_update_aclmacs(void)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *wmm, *twmm;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		SLIST_FOREACH_SAFE(wmm, &wif->mac_maclist, wm, twmm)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			if (wmm->mac_status == RowStatus_active) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:				SLIST_REMOVE(&wif->mac_maclist, wmm,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:				    wlan_mac_mac, wm);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:				wlan_mac_free_mac(wmm);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		(void)wlan_get_mac_acl_macs(wif);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, mac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	return (wlan_mac_find_mac(*wif, mac));
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:static struct wlan_mac_mac *
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *wmm;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:			wmm = SLIST_FIRST(&(*wif)->mac_maclist);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, mac) < 0 ||
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	    (wmm = wlan_mac_find_mac(*wif, mac)) == NULL)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		if ((wmm = SLIST_FIRST(&(*wif)->mac_maclist)) != NULL)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:wlan_acl_mac_set_status(struct snmp_context *ctx, struct snmp_value *val,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	struct wlan_mac_mac *macl;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(&val->var, sub, wname, mac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if ((macl = wlan_mac_new_mac((const uint8_t *)mac)) == NULL)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_add_mac(wif, macl) < 0) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		wlan_mac_free_mac(macl);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_add_mac_acl_mac(wif, macl) < 0) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:		(void)wlan_mac_delete_mac(wif, macl);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, pmac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, pmac) < 0 ||
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, dstmac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(oid, sub, wname, dstmac) < 0 ||
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_snmp.c:	if (wlan_mac_index_decode(&val->var, sub, wname, mac) < 0)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:static int	wlan_add_mac_macinfo(struct wlan_iface *,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_get_mac_policy(struct wlan_iface *wif)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:			wif->mac_policy = wlanMACAccessControlPolicy_open;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_policy = wlanMACAccessControlPolicy_allow;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_policy = wlanMACAccessControlPolicy_deny;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_policy = wlanMACAccessControlPolicy_radius;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_policy = wlanMACAccessControlPolicy_open;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	wif->mac_nacls = argsize / sizeof(struct ieee80211req_maclist *);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_set_mac_policy(struct wlan_iface *wif)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	switch (wif->mac_policy) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_flush_mac_mac(struct wlan_iface *wif)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_add_mac_macinfo(struct wlan_iface *wif,
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	struct wlan_mac_mac *mmac;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	if ((mmac = wlan_mac_new_mac(ml->ml_macaddr)) == NULL)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	mmac->mac_status = RowStatus_active;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	if (wlan_mac_add_mac(wif, mmac) < 0) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wlan_mac_free_mac(mmac);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_get_mac_acl_macs(struct wlan_iface *wif)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	if (wif->mac_policy == wlanMACAccessControlPolicy_radius) {
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_nacls = 0;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		wif->mac_nacls = 0;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:		(void)wlan_add_mac_macinfo(wif, acllist + i);
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	wif->mac_nacls = nacls;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_add_mac_acl_mac(struct wlan_iface *wif, struct wlan_mac_mac *mmac)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	mmac->mac_status = RowStatus_active;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	if (wif->mac_policy != wlanMACAccessControlPolicy_deny)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:wlan_del_mac_acl_mac(struct wlan_iface *wif, struct wlan_mac_mac *mmac)
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	mmac->mac_status = RowStatus_active;
/usr/src/usr.sbin/bsnmpd/modules/snmp_wlan/wlan_sys.c:	if (wif->mac_policy != wlanMACAccessControlPolicy_allow)
/usr/src/usr.sbin/getfmac/getfmac.c:	mac_t label;
/usr/src/usr.sbin/getfmac/getfmac.c:			error = mac_prepare(&label, labellist);
/usr/src/usr.sbin/getfmac/getfmac.c:			error = mac_prepare_file_label(&label);
/usr/src/usr.sbin/getfmac/getfmac.c:			perror("mac_prepare");
/usr/src/usr.sbin/getfmac/getfmac.c:			error = mac_get_link(argv[i], label);
/usr/src/usr.sbin/getfmac/getfmac.c:			error = mac_get_file(argv[i], label);
/usr/src/usr.sbin/getfmac/getfmac.c:			mac_free(label);
/usr/src/usr.sbin/getfmac/getfmac.c:		error = mac_to_text(label, &string);
/usr/src/usr.sbin/getfmac/getfmac.c:			perror("mac_to_text");
/usr/src/usr.sbin/getfmac/getfmac.c:		mac_free(label);
/usr/src/usr.sbin/getpmac/getpmac.c:	mac_t label;
/usr/src/usr.sbin/getpmac/getpmac.c:		error = mac_prepare(&label, labellist);
/usr/src/usr.sbin/getpmac/getpmac.c:		error = mac_prepare_process_label(&label);
/usr/src/usr.sbin/getpmac/getpmac.c:		perror("mac_prepare");
/usr/src/usr.sbin/getpmac/getpmac.c:		error = mac_get_pid(pid, label);
/usr/src/usr.sbin/getpmac/getpmac.c:			perror("mac_get_pid");
/usr/src/usr.sbin/getpmac/getpmac.c:		error = mac_get_proc(label);
/usr/src/usr.sbin/getpmac/getpmac.c:			perror("mac_get_proc");
/usr/src/usr.sbin/getpmac/getpmac.c:		mac_free(label);
/usr/src/usr.sbin/getpmac/getpmac.c:	error = mac_to_text(label, &string);
/usr/src/usr.sbin/getpmac/getpmac.c:		perror("mac_to_text");
/usr/src/usr.sbin/getpmac/getpmac.c:	mac_free(label);
/usr/src/usr.sbin/makefs/cd9660/cd9660_eltorito.c:	struct boot_catalog_entry *x86_head, *mac_head, *ppc_head,
/usr/src/usr.sbin/makefs/cd9660/cd9660_eltorito.c:	x86_head = mac_head = ppc_head = NULL;
/usr/src/usr.sbin/makefs/cd9660/cd9660_eltorito.c:			headp = &mac_head;
/usr/src/usr.sbin/nvram/nvram.c:#include <dev/powermac_nvram/powermac_nvramvar.h>
/usr/src/usr.sbin/nvram/nvram.c:#define	DEVICE_NAME	(_PATH_DEV "powermac_nvram")
/usr/src/usr.sbin/ppp/radius.c:  char *mac_addr;
/usr/src/usr.sbin/ppp/radius.c:  if ((mac_addr = getenv("HISMACADDR")) != NULL &&
/usr/src/usr.sbin/ppp/radius.c:      rad_put_string(r->cx.rad, RAD_CALLING_STATION_ID, mac_addr) != 0) {
/usr/src/usr.sbin/ppp/radius.c:  char *mac_addr;
/usr/src/usr.sbin/ppp/radius.c:  if ((mac_addr = getenv("HISMACADDR")) != NULL &&
/usr/src/usr.sbin/ppp/radius.c:      rad_put_string(r->cx.rad, RAD_CALLING_STATION_ID, mac_addr) != 0) {
/usr/src/usr.sbin/setfmac/setfmac.c:void add_setfmac_specs(struct label_specs *, char *);
/usr/src/usr.sbin/setfmac/setfmac.c:		add_setfmac_specs(specs, *argv);
/usr/src/usr.sbin/setfmac/setfmac.c:add_setfmac_specs(struct label_specs *specs, char *label)
/usr/src/usr.sbin/setfmac/setfmac.c:	mac_t mac;
/usr/src/usr.sbin/setfmac/setfmac.c:	if (mac_from_text(&mac, macstr))
/usr/src/usr.sbin/setfmac/setfmac.c:		err(1, "mac_from_text(%s)", macstr);
/usr/src/usr.sbin/setfmac/setfmac.c:	if ((hflag == FTS_PHYSICAL ? mac_set_link(ftsent->fts_accpath, mac) :
/usr/src/usr.sbin/setfmac/setfmac.c:	    mac_set_file(ftsent->fts_accpath, mac)) != 0) {
/usr/src/usr.sbin/setfmac/setfmac.c:			mac_free(mac);
/usr/src/usr.sbin/setfmac/setfmac.c:		err(1, "mac_set_link(%s, %s)", ftsent->fts_path, macstr);
/usr/src/usr.sbin/setfmac/setfmac.c:	mac_free(mac);
/usr/src/usr.sbin/setpmac/setpmac.c:	mac_t label;
/usr/src/usr.sbin/setpmac/setpmac.c:	error = mac_from_text(&label, argv[1]);
/usr/src/usr.sbin/setpmac/setpmac.c:		perror("mac_from_text");
/usr/src/usr.sbin/setpmac/setpmac.c:	error = mac_set_proc(label);
/usr/src/usr.sbin/setpmac/setpmac.c:	mac_free(label);
/usr/src/usr.sbin/sysinstall/menus.c:	dmenuVarCheck,  dmenuToggleVariable, NULL, "lomac_enable=YES" },
/usr/src/usr.sbin/ugidfw/ugidfw.c:#include <security/mac_bsdextended/mac_bsdextended.h>
/usr/src/usr.sbin/ugidfw/ugidfw.c:	struct mac_bsdextended_rule rule;
/usr/src/usr.sbin/ugidfw/ugidfw.c:	struct mac_bsdextended_rule rule;
/usr/src/usr.sbin/ugidfw/ugidfw.c:		warnx("unable to get rule slots; mac_bsdextended.ko "
/usr/src/usr.sbin/ugidfw/ugidfw.c:	struct mac_bsdextended_rule rule;
0
