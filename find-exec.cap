#lang shill/cap

provide [find : forall [X:+path,+lookup,+contents] . [f: X] [filter: [_: X] -> boolean?] [cmd: [_: X] -> any] -> any ];

# filter functions
provide [name : [_: string?] -> [_ : pathable] -> boolean?]
        [fullname : [_: string?] ->  [_ : pathable] -> boolean?];

# actions
provide [grep : [regexp : or/c(string?, regexp?)] ->
        [file : file/c(+read, +path)]
        ->
        any ];

val pathable = or/c(file/c(+path),dir/c(+path));

val ls = fun(dir) { contents(dir); };

val find = fun(f, filter, cmd) {
  if and(file?(f),filter(f)) then
     cmd(f);

  # if f is a directory, recurse on its contents
  if dir?(f) then
    for g in ls(f) do {
      val fc = lookup(f,g);
      if not(sys-error?(fc)) then
        find(fc, filter, cmd);
    };
};

val grep = fun(regexp) {
  fun (file) {
    val contents = read(file);
    if not(empty?(regexp-match*(regexp, contents)))
    then {
      printf("File ~a matches\n", path(file));
    }
  };
};

val name = fun(r) { 
  val re = regexp(r);
  fun(f) regexp-match?(re, shortname(path(f))); 
};

val shortname = fun(path) {
  path-element->string(last(explode-path(string->path(path))));
};

val fullname = fun(r) { 
  val re = regexp(r);
  fun(f) regexp-match?(re, path(f));
};
